<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ddia, Distributed Data (Part 2): Partitioning</title>
      <link href="/ddia-distributed-data-part-2-partitioning/"/>
      <url>/ddia-distributed-data-part-2-partitioning/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是ddia第六章的阅读笔记。</p></blockquote><h2 id="0x00-Pre"><a href="#0x00-Pre" class="headerlink" title="0x00 Pre"></a>0x00 Pre</h2><p>&lt;img src=””<a href="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/6.partitioning.png&gt;" target="_blank" rel="noopener">https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/6.partitioning.png&gt;</a></p><p>第五章的复制有一个假设，数据副本可以在一台机器上存储。</p><p>如果不行的话，就需要将一个副本放在多个机器上了。</p><p>这就是<strong>分区（partitions）</strong>，也叫<strong>分片（sharding）</strong>。</p><p>分区一般和复制结合使用，每个分区在多个节点上都有副本。比如：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/replication%20and%20partitioning.png"><p>既然要将一个数据副本分成多块，那么第一个问题就是，怎么决定一个副本的记录放到那个分区上呢？</p><h2 id="0x1-键值数据的分区"><a href="#0x1-键值数据的分区" class="headerlink" title="0x1 键值数据的分区"></a>0x1 键值数据的分区</h2><p>将数据分到多个节点上，那么就应该尽量均衡，否则就会出现热点（Hotspot）。</p><p>避免热点最简单的就是将数据随机分配给所有的节点。</p><p>不过这样的话读取数据的时候就麻烦了。</p><p>如果数据是键值类型的话，可以简单改进。</p><h3 id="1-1-基于关键字区间分区"><a href="#1-1-基于关键字区间分区" class="headerlink" title="1.1 基于关键字区间分区"></a>1.1 基于关键字区间分区</h3><p>如下图：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/partitioning%20by%20key%20range.png"><p>每个分区的范围可以手动设置，也可以自动设置。</p><p>基于关键字区间的分区方式的缺点是某些访问模式会导致热点，比如按天分区。</p><h3 id="1-2-基于关键字哈希值分区"><a href="#1-2-基于关键字哈希值分区" class="headerlink" title="1.2 基于关键字哈希值分区"></a>1.2 基于关键字哈希值分区</h3><p>可以将key进行hash然后确定分区：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/partitioning%20by%20hash%20of%20key.png"><p>不过使用hash分区，就不能使用区间查询了。</p><p><strong>一致性哈希（consistent hashing）</strong>：是一种平均分配负载的方法，采用随机选择的分区边界来规避中央控制或分布式共识。这个和副本一致性、ACID一致性没有任何关联。</p><h3 id="1-3-负载倾斜与热点"><a href="#1-3-负载倾斜与热点" class="headerlink" title="1.3 负载倾斜与热点"></a>1.3 负载倾斜与热点</h3><p>热点不可避免。极端情况下，所有的读写都是针对同一个关键字。</p><p>这在社交网络的名人上是很有可能的。</p><p>避免这种热点可以在key之后加上一个随机数，就可以把一个key分到多个不同的key上。</p><p>不过读取的时候就要有额外的操作了。</p><p>可以只对少量的热点key进行这种操作。</p><h2 id="0x02-分区与二级索引"><a href="#0x02-分区与二级索引" class="headerlink" title="0x02 分区与二级索引"></a>0x02 分区与二级索引</h2><p>前面的是键值类型数据，如果涉及到二级索引的话就麻烦了。</p><p>二级索引的主要挑战是不能规整地映射到分区中，因为二级索引不能唯一标识一条记录。</p><p>不过可以通过两种方式来对二级索引进行分区。</p><h3 id="2-1-基于文档的二级索引"><a href="#2-1-基于文档的二级索引" class="headerlink" title="2.1 基于文档的二级索引"></a>2.1 基于文档的二级索引</h3><p>比如下面的一个例子：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/partitioning%20secondary%20indexes%20by%20document.png"><p>相当于每个分区有一个自己的索引，而不是全局索引。</p><p>所以想要搜索全部的话，需要对多个分区进行搜索然后合并结果。</p><h3 id="2-2-基于词条的二级索引分区"><a href="#2-2-基于词条的二级索引分区" class="headerlink" title="2.2 基于词条的二级索引分区"></a>2.2 基于词条的二级索引分区</h3><p>基于词条的分区可以维护一个全局索引，并且将这个全局索引也进行分区：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/partitioning%20secondary%20indexes%20by%20term.png"><p>全局索引的分区可以采用和数据关键字不同的策略。</p><p>这种方式读取简单，但是写入就比较复杂了。</p><p>主要是因为单个文档更新时，可能涉及到多个二级索引，而这些二级索引可能分布在不同的分区上，写放大。</p><p>理想情况下，索引应该时刻保持更新。</p><p>但是对于词条分区来说，这需要一个跨多个相关分区的分布式事务支持，影响写操作。</p><p>实践中，对全局二级索引的更新往往都是异步的。</p><h2 id="0x03-分区再平衡"><a href="#0x03-分区再平衡" class="headerlink" title="0x03 分区再平衡"></a>0x03 分区再平衡</h2><p>数据库在不断变化，所以一开始的分区可能到后面需要进行更改。</p><p>这要求数据和请求可以从一个节点转移到另一个节点上，这就是<strong>再平衡（Rebalancing）</strong>。</p><p>分区再平衡至少需要满足：</p><ul><li>平衡之后，负载、数据存储和读写请求等应该在集群范围内均匀分布；</li><li>再平衡过程中，数据库应该可以继续正常运行；</li><li>避免不必要的负载迁移，加快再平衡，并尽量减少网络和磁盘影响。</li></ul><h3 id="3-1-动态再平衡的策略"><a href="#3-1-动态再平衡的策略" class="headerlink" title="3.1 动态再平衡的策略"></a>3.1 动态再平衡的策略</h3><h4 id="3-1-1-取模"><a href="#3-1-1-取模" class="headerlink" title="3.1.1 取模"></a>3.1.1 取模</h4><p>对节点数取模方法的问题是，如果节点数N发生了变化，会导致很多关键字需要迁移。</p><p>不建议使用这种方法。</p><h4 id="3-1-2-固定数量的分区"><a href="#3-1-2-固定数量的分区" class="headerlink" title="3.1.2 固定数量的分区"></a>3.1.2 固定数量的分区</h4><p>可以首先创建数量远超节点数的分区数，然后为每个节点分配多个分区。</p><p>如果新加一个节点，那么可以从其他的节点上移走几个到这个新的节点上：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/fixed%20number%20of%20partitions.png"><p>选中的分区会在节点之间迁移，但是分区的总数不变，也不改变关键字到分区的映射，改变的是分区与节点的映射。</p><h4 id="3-1-3-动态分区"><a href="#3-1-3-动态分区" class="headerlink" title="3.1.3 动态分区"></a>3.1.3 动态分区</h4><p>HBase和RethinkDB采用的动态分区，如果分区的数据增长到一个阈值，就自动拆分成两个分区。</p><p>动态分区的一个优点是分区数量可以自动适配数据总量。</p><p>且不仅适用于关键字分区，也适用于基于哈希的分区。</p><h4 id="3-1-4-按节点比例分区"><a href="#3-1-4-按节点比例分区" class="headerlink" title="3.1.4 按节点比例分区"></a>3.1.4 按节点比例分区</h4><p>采用动态分区，每个分区的大小维持在设定的最小值和最大值之间，那么分区的数量就和数据总量有关。</p><p>而如果分区数量固定的话，每个分区的大小也和数据总量有关。</p><p>这两种方式的分区数量都与节点数量无关。</p><p>Cassandra和Ketama采用了第三种方式，分区数量和节点数量有关。</p><p>也就是说每个节点具有固定数量的分区。</p><p>当节点数固定时，分区数固定，分区大小和数据总量有关。</p><p>当新加节点时，随机选择固定数量的现有分区进行分裂，然后拿走一半的数据。</p><h3 id="3-2-自动与手动再平衡策略"><a href="#3-2-自动与手动再平衡策略" class="headerlink" title="3.2 自动与手动再平衡策略"></a>3.2 自动与手动再平衡策略</h3><p>再平衡可以手动，也可以自动执行。</p><p>全自动方便，但是也可能出现意想不到的问题。</p><p>最好是在再平衡过程中有管理员介入。</p><h2 id="0x04-请求路由"><a href="#0x04-请求路由" class="headerlink" title="0x04 请求路由"></a>0x04 请求路由</h2><p>现在的问题就是，客户端发送请求时，需要知道应该连接的是哪个节点。</p><p>这就是服务发现问题。</p><p>有以下几种策略：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/request%20routings.png"><ul><li>随机选择然后请求转发；</li><li>有一个路由层统一管理；</li><li>客户端感知节点与分区的关系。</li></ul><p>不管在哪里作出决策，都需要知道具体的节点与分区之间的关系。</p><p>那么怎么管理这些信息呢？</p><p>可以使用独立的协调服务（比如ZooKeeper）。</p><p>还可以自己实现协议，来同步这些信息。</p>]]></content>
      
      
      <categories>
          
          <category> cs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ddia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ddia, Distributed Data (Part 1): Replication</title>
      <link href="/ddia-distributed-data-part-1-replication/"/>
      <url>/ddia-distributed-data-part-1-replication/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是ddia第五章的阅读笔记。</p></blockquote><h2 id="0x00-Pre"><a href="#0x00-Pre" class="headerlink" title="0x00 Pre"></a>0x00 Pre</h2><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/5.Replication.png"><p>前面的部分都是在一台机器上。</p><p>出于一些原因，需要将数据复制到多台机器上：</p><ul><li><strong>就近部署</strong>：降低延迟；</li><li><strong>高可用性</strong>：一台出故障系统仍可用；</li><li><strong>高吞吐量</strong>：多台机器可以提高吞吐量。</li></ul><p>一个假设，一份副本足以存储在一台机器上。</p><p>如果副本过大，就需要<strong>分片</strong>了。</p><p>好的，为了达到复制的目的，应该怎么做呢？会有什么问题呢？该怎么解决呢？</p><h2 id="0x01-主节点与从节点"><a href="#0x01-主节点与从节点" class="headerlink" title="0x01 主节点与从节点"></a>0x01 主节点与从节点</h2><p>有三种复制的方式：<strong>主从复制</strong>、<strong>多主节点复制</strong>和<strong>无主节点复制</strong>。</p><p>首先看看主从复制。基本过程如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/leader-based%28master-slave%29%20replication.png"><ol><li>指定一个主节点。写请求都在这个节点上进行；</li><li>其他副本都是从节点，主节点把数据写入本地之后将数据更改作为复制日志发送给从节点。从节点根据日志进行更新，和主节点保持一致；</li><li>所有的从节点只处理读请求。</li></ol><p>主从复制是一种很常见的复制方式。不仅关系型数据库在用，好多NoSQL数据库也在用，比如MongoDB等。</p><h3 id="1-1-同步复制与异步复制"><a href="#1-1-同步复制与异步复制" class="headerlink" title="1.1 同步复制与异步复制"></a>1.1 同步复制与异步复制</h3><p>问题来了，主节点和从节点之间的更新，是同步复制呢还是异步复制？</p><p>下图展示了这两种方案：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/leader-based%20replication%20with%20one%20synchronous%20and%20one%20asynchronous%20follower.png"><p>同步复制的优点很明显，一旦确认成功那么数据已经处于最新版本；不过也有缺点，就是如果其他节点没有成功那么就需要等待。</p><p>实际使用中，<strong>如果数据库启用了同步复制，通常意味着其中某一个从节点是同步的，其余的从节点是异步的</strong>。</p><p>这就是<strong>半同步（semi-synchronous）</strong>。</p><p>还可以是<strong>全异步模式</strong>，如果这个时候主节点失败且不可恢复，那么所有尚未复制到从节点的写请求都会丢失。但是全异步模式下主节点可以处理更多的写请求，系统的吞吐量大。</p><p>还有一种方式是<strong>链式复制（chain replication）</strong>。</p><h3 id="1-2-配置新的从节点"><a href="#1-2-配置新的从节点" class="headerlink" title="1.2 配置新的从节点"></a>1.2 配置新的从节点</h3><p>添加新的从节点的步骤如下：</p><ol><li>在某个时间点对数据副本生成一个一致性快照，可以避免长时间锁定数据库。对于MySQL，需要使用innobackupex；</li><li>将快照复制到新的从节点；</li><li>从节点向主节点请求快照之后的更新日志。这个位置在MySQL中叫做binlog coordinates；</li><li>从节点获取日志后应用更新，来追上主节点。然后就可以继续处理数据变化了。</li></ol><h3 id="1-3-处理失效节点"><a href="#1-3-处理失效节点" class="headerlink" title="1.3 处理失效节点"></a>1.3 处理失效节点</h3><p>任何时候任何节点都有可能出现问题。</p><p>我们需要做到的是，尽管个别节点会出现中断，但要保持系统总体的持续运行，并尽可能减小节点中断带来的影响。</p><h4 id="1-3-1-从节点失效：Catch-up-recovery"><a href="#1-3-1-从节点失效：Catch-up-recovery" class="headerlink" title="1.3.1 从节点失效：Catch-up recovery"></a>1.3.1 从节点失效：Catch-up recovery</h4><p>和添加新的从节点类似，如果一个从节点失效并顺利重启的话，可以知道自己的更新日志的位置，然后向主节点请求之后的日志，根据这些日志更新数据来追上主节点即可。</p><h4 id="1-3-2-主节点失效：Failover"><a href="#1-3-2-主节点失效：Failover" class="headerlink" title="1.3.2 主节点失效：Failover"></a>1.3.2 主节点失效：Failover</h4><p>主节点失效了就复杂了。需要选一个从节点作为主节点，客户端新的写请求需要发送到新的主节点，然后其他的从节点从这个新的主节点接收变更日志。</p><p>可以手动也可以自动切换主节点。自动切换过程如下：</p><ol><li><strong>确认主节点失效</strong>。通常可以使用心跳检测来确认；</li><li><strong>选举新的主节点</strong>。这是一个共识问题（consensus problem）；</li><li><strong>使新主节点生效</strong>。写请求发送给新的主节点。</li></ol><p>不过切换过程中可能会有很多问题：</p><ul><li>如果使用心跳检测来确认主节点失效的话，那么多长时间合适呢？太长意味着系统恢复时间长，太短意味着可能频繁的切换；</li><li>如果使用异步复制，且失效前新的主节点没有接收到原主节点的数据，切换之后原主节点重新上线并加入集群，那么就有可能发生冲突。一个简单的办法就是丢弃原主节点未完成复制的数据，造成数据丢失；</li><li>如果简单的丢弃数据，就会有严重的问题。尤其在mysql+redis的系统中，数据不一致可能会导致严重的问题；</li><li>可能会发生，新旧主节点都认为自己是主节点（split brain），需要强制关闭一个主节点。</li></ul><p>这些问题都挺复杂，包括节点失效（node failures）、网络不可靠（unreliable networks）、副本一致性（replia consistency）、持久性（durability）、可用性（availability）和延迟（latency）等，以及之间的平衡。</p><h3 id="1-4-复制日志的实现"><a href="#1-4-复制日志的实现" class="headerlink" title="1.4 复制日志的实现"></a>1.4 复制日志的实现</h3><p>复制日志如何实现？</p><h4 id="1-4-1-基于语句的复制"><a href="#1-4-1-基于语句的复制" class="headerlink" title="1.4.1 基于语句的复制"></a>1.4.1 基于语句的复制</h4><p>最简单的，是直接将语句同步给从节点，然后从节点按照接收的顺序执行一遍。</p><p>不过这个问题有点大，比如一些语句有非确定性函数<code>NOW()</code>等，就会不一致。</p><p>基本上不使用这种方式。</p><h4 id="1-4-2-基于预写日志（WAL）传输"><a href="#1-4-2-基于预写日志（WAL）传输" class="headerlink" title="1.4.2 基于预写日志（WAL）传输"></a>1.4.2 基于预写日志（WAL）传输</h4><p>不管是日志结构存储引擎还是使用Btree结构的存储引擎，都会将数据库写入的字节序列写入日志。</p><p>因此可以将这个日志发送给从节点，来进行数据更新。</p><p>不过这个预写日志的缺点是数据非常底层，和存储引擎紧密耦合。</p><p>也不推荐使用。</p><h4 id="1-4-3-基于行的逻辑日志复制"><a href="#1-4-3-基于行的逻辑日志复制" class="headerlink" title="1.4.3 基于行的逻辑日志复制"></a>1.4.3 基于行的逻辑日志复制</h4><p>和预写日志类似，但是数据格式和存储逻辑剥离，这就是逻辑日志（logical log）。</p><p>每一行的数据变更都可以记入日志，从节点就可以根据这个日志进行数据更新。</p><p>在mysql中，配置为基于行的复制时，binlog就是使用的这种方式。</p><h4 id="1-4-4-基于触发器的复制"><a href="#1-4-4-基于触发器的复制" class="headerlink" title="1.4.4 基于触发器的复制"></a>1.4.4 基于触发器的复制</h4><p>还可以使用触发器和存储过程。</p><p>不过这个开销有点高，也不推荐。</p><h2 id="0x02-复制滞后问题"><a href="#0x02-复制滞后问题" class="headerlink" title="0x02 复制滞后问题"></a>0x02 复制滞后问题</h2><p>主从复制下，所有的写请求都在主节点上，从节点只处理读请求。</p><p>这个方式适用读密集的负载，比如web应用。创建多个从节点，就可以提高系统的吞吐量。</p><p>不过这样只能使用异步复制，不然一个节点失败就会导致整个系统无法写入。</p><p>如果使用异步复制，虽然可以达到最终一致性（eventual consistency），也会有各种复制滞后问题。</p><h3 id="2-1-读自己的写"><a href="#2-1-读自己的写" class="headerlink" title="2.1 读自己的写"></a>2.1 读自己的写</h3><p>写入不久即查看数据，复制没有完成，看起来没有写成功：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/reading%20your%20own%20writes.png"><p>这里需要<strong>写后读一致性（read-after-write consistency）</strong>或<strong>读写一致性（read-your-writes consistency）</strong>。</p><p>这个一致性保证，如果用户重新加载页面，总能看到自己最近提交的更新；但对其他用户没有任何保证，这些更新其他用户可能过会才能看到。</p><p>解决方式：</p><ul><li>如果访问可能会被更新的内容，从主节点读；否则在从节点读。这需要应用程序层面上有一些逻辑需要知道哪些可能被修改。比如个人主页的信息只能所有者更新，所以所有者在主节点上读，其他人在从节点上读就可以了；</li><li>如果几乎所有的内容都可能被所有人更新，那么上面的方式就不行了了。不然读请求也都到主节点上去了。这个时候可以追踪最近更新的时间，比如最近更新在一分钟内，那么在主节点上读，否则在从节点上读。同时还可以监控从节点的复制滞后程度，避免在过于滞后的从节点上读；</li><li>客户端还可以记录最近更新时间戳，并附带在请求上。服务器需要保证副本至少包含这个时间戳的更新。如果不够新，可以交给更新的副本来处理。这个相当于版本（version）。</li></ul><p>如果涉及到多个设备，那么可能需要<strong>跨设备的写后读一致性（cross-device read-after-write consistency）</strong>。</p><h3 id="2-2-单调读"><a href="#2-2-单调读" class="headerlink" title="2.2 单调读"></a>2.2 单调读</h3><p>如果两个同样的读操作被路由到了两个复制状态不一致的机器上，那么就会出现数据向后回滚的情况：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/monotonic%20reads.png"><p>用户2345先看到了用户1234的评论，然后又看不到了，还以为是删除了。</p><p>这需要<strong>单调读一致性（monotonic reads）</strong>，比强一致性弱，比最终一致性强的保证。它保证，如果用户进行多次读取，那么不会出现回滚现象。</p><p>解决方式：确保同一个用户总是从固定的副本上读取，不同的用户可以在不同的副本上读取。</p><h3 id="2-3-前缀一致读"><a href="#2-3-前缀一致读" class="headerlink" title="2.3 前缀一致读"></a>2.3 前缀一致读</h3><p>在分区数据库中有一种特殊的问题：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/consistent%20prefix%20reads.png"><p>一个诡异的现象，但不合逻辑。</p><p>这需要<strong>前缀一致性（consistent prefix reads）</strong>。就是说，对于一系列按照某个顺序发生的写请求，那么读取这些内容时也会按照写入的顺序。</p><p>一个方案是具有因果顺序的写入都交给一个分区，但实现效率低。</p><p>不过现在有算法来追踪事件因果关系。</p><h2 id="0x03-多主节点复制"><a href="#0x03-多主节点复制" class="headerlink" title="0x03 多主节点复制"></a>0x03 多主节点复制</h2><p>单主节点的一个缺点就是主节点只有一个，所有写请求都到主节点上。</p><p>自然的扩展就是多个主节点。复制的流程类似，不过，每个主节点还是其他主节点的从节点：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/multi-leader%20replication%20across%20multiple%20datacenters.png"><p>在一个数据中心内部使用多主节点没啥意义，过于复杂。</p><p>可以在多个数据中心使用多主节点复制，每个数据中心一个主节点。</p><p>还可以对需要离线操作的客户端使用多主节点复制，其中每个客户端都是一个主节点。</p><p>进而，多人协作编辑也可以使用多主节点复制，虽然不是数据库复制，但也很类似。</p><h3 id="3-1-处理写冲突"><a href="#3-1-处理写冲突" class="headerlink" title="3.1 处理写冲突"></a>3.1 处理写冲突</h3><p>在每个主节点都写入成功的情况下，可能会发生冲突：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/a%20write%20conflict%20by%20two%20leaders.png"><p>最理想的处理冲突的方式就是避免冲突。</p><p>比如，特定记录的修改路由到特定的主节点来处理。</p><p>不过也有问题，万一那个特定的主节点不可用了呢。</p><p>那么冲突就不可避免了，不过，需要达到一种最终状态是一致的。</p><p>一些方式：</p><ul><li>最后写入的覆盖之前的，这样会有数据丢失；</li><li>为每个副本分配一个ID，不同的ID有不同的优先级，高优先级的副本优先于低优先级的副本。这也会有数据丢失；</li><li>使用某种方式将冲突的数据合并在一起展示；</li><li>使用预先定义好的格式来将冲突数据保存起来，在应用层上处理。</li></ul><p>冲突最好在应用层处理。不过也有一些自动解决冲突的方案：</p><ul><li>无冲突的复制数据类型（Conflict-free Replicated Datatypes, CRDT）;</li><li>可合并的持久数据结构（Mergeable persistent data）；</li><li>操作转换（Operational transformation）。</li></ul><h3 id="3-2-拓扑结构"><a href="#3-2-拓扑结构" class="headerlink" title="3.2 拓扑结构"></a>3.2 拓扑结构</h3><p>多个主节点之间需要将各自的更新传送到其他的主节点。</p><p>那么传递的路径就有多种方式了：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/multi-leader%20replication%20topologies.png"><p>mysql只支持环形拓扑。</p><p>环形和星形拓扑的一个问题是，其中的一个节点出现问题会影响整个系统的复制日志转发。</p><p>全连接拓扑的问题是，会出现复制日志覆盖的情况：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/wrong%20order%20with%20multi-leader%20replication.png"><p>和前面的前缀一致性类似，这里有因果关系问题。可以使用版本向量（version vector）。</p><h2 id="0x04-无主节点复制"><a href="#0x04-无主节点复制" class="headerlink" title="0x04 无主节点复制"></a>0x04 无主节点复制</h2><p>前面的都是有主节点的。那么还可以没有主节点。</p><p>这样客户端直接将写请求发送到多个副本。</p><p>这对数据库的使用有很大的影响。</p><h3 id="4-1-节点失效时写入数据库"><a href="#4-1-节点失效时写入数据库" class="headerlink" title="4.1 节点失效时写入数据库"></a>4.1 节点失效时写入数据库</h3><p>如下图的情况：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/quorum%20write%20and%20read.png"><p>三个副本中只有两个写入成功，那么也可以认为写入成功。</p><p>之后失效的节点重新上线，就可能读到过期的数据。</p><p>不过可以向多个副本发送读请求，这样可以收到多个结果，然后根据每个结果的<strong>版本号</strong>来确定哪个结果是新的。</p><h4 id="4-1-1-读修复与反熵"><a href="#4-1-1-读修复与反熵" class="headerlink" title="4.1.1 读修复与反熵"></a>4.1.1 读修复与反熵</h4><p>这样就会有问题，集群中的数据不一致。</p><p>为了解决这个问题，可以有两种方案：</p><ul><li><strong>读修复（Read repair）</strong>：读取的时候如果发现旧数据，那么就用新数据来更新；</li><li><strong>反熵（Anti-entropy process）</strong>：启动一个后台进程不断查找数据差异，并进行更新。</li></ul><p>读修复适合频繁读取的场景，不过如果一些数据很少被访问的话就可能很久得不到更新，降低了写的持久性。</p><h4 id="4-1-2-读写Quorum"><a href="#4-1-2-读写Quorum" class="headerlink" title="4.1.2 读写Quorum"></a>4.1.2 读写Quorum</h4><p>这里给出一个一般性法则，对于有n个副本的集群，至少需要多个副本读写成功才算成功。</p><blockquote><p>如果有n个副本，写入需要w个节点确认，读取必须至少查询r个节点，需要满足 w + r &gt; n。</p></blockquote><p>一般来说n都是某个奇数，然后w=r=(n+1)/2（向上舍入）。</p><h3 id="4-2-Quorum一致性的局限"><a href="#4-2-Quorum一致性的局限" class="headerlink" title="4.2 Quorum一致性的局限"></a>4.2 Quorum一致性的局限</h3><p>w+r&gt;n保证了可以读到一个最新值：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/quorums%20for%20reading%20and%20writing.png"><p>还可以将w和r设置为较小的数字，这样可以降低延迟，不过有可能读不到最新的值。</p><p>即使在w+r&gt;n的情况下，也可能存在返回旧值的边界条件：</p><ul><li>使用了sloppy quorum，写操作的w节点和读取的r节点没有重合；</li><li>如果两个写操作同时发生，可以合并处理。如果简单保留最后写入成功的值的话，会有数据丢失；</li><li>读写同时发生，写操作可能仅在一部分副本上发生，还是可能读到旧值；</li><li>写成功数小于w，整体视为写失败，但是如果成功的副本不回滚的话，会读取到不应该存在的新值；</li><li>如果有新值的节点失效后以旧值恢复，那么就破坏了之前的判定条件。</li></ul><p>总之，情况很复杂。</p><h3 id="4-3-Sloppy-Quorums-and-Hinted-Handoff"><a href="#4-3-Sloppy-Quorums-and-Hinted-Handoff" class="headerlink" title="4.3 Sloppy Quorums and Hinted Handoff"></a>4.3 Sloppy Quorums and Hinted Handoff</h3><p>n副本的集群中读写只需要r和w个有响应即可。对于需要高可用和低延迟的场景来说，还可以降低r和w的值。</p><p>网络不总是那么靠谱。如果一个客户端能连接到的副本少于w，但是对其它客户端来说没问题，那么这个倒霉的客户端写入的话该怎么办呢？</p><ul><li>无法到达w，直接返回错误；</li><li>接收写请求，将数据写入到n个节点之外的可访问节点。</li></ul><p>后一个就是<strong>Sloppy Quorum</strong>。</p><p>等网络问题没了，就把数据从临时的节点发送到原始节点上，叫做<strong>数据回传（Hinted Handoff）</strong>。</p><p>这样可以提高可用性，即使达不到写入所需的w个节点，但只要有可访问的w个节点就可以（包括不是集群中的节点）。</p><p>这样，即使满足w+r&gt;n，也可能读取到旧数据。</p><p>注意，Sloppy Quorum不是传统意义上的Quorum。</p><h3 id="4-4-检测并发写"><a href="#4-4-检测并发写" class="headerlink" title="4.4 检测并发写"></a>4.4 检测并发写</h3><p>多个客户端同时写的话，就可能会发生冲突，即使使用严格的Quorum机制。此外，读修复和数据回传的时候也可能发生冲突。</p><p>比如：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/no%20well-defined%20order.png"><ul><li>节点1收到A的写请求，但是没有收到B的写请求；</li><li>节点2先收到A后收到B的写请求；</li><li>节点3和节点2相反。</li></ul><p>如果只是简单的覆盖的话，那么这些节点就达不成一致。</p><p>这里更详细地看冲突处理。</p><h4 id="4-4-1-最后写入者获胜"><a href="#4-4-1-最后写入者获胜" class="headerlink" title="4.4.1 最后写入者获胜"></a>4.4.1 最后写入者获胜</h4><p>Last Write Wins，后写入的覆盖之前的。</p><p>LWW通过牺牲数据持久性为代价来达到最终收敛的目标。</p><h4 id="4-4-2-Happens-before和并发"><a href="#4-4-2-Happens-before和并发" class="headerlink" title="4.4.2 Happens-before和并发"></a>4.4.2 Happens-before和并发</h4><p>happens-before和并发是不同的，对于happens-before来说，后面的写可以覆盖前面的，但是对于并发来说，就不能简单的覆盖。</p><p>由于时间问题，并不能仅仅依靠是否时间戳上差不多来定义并发。</p><p>如果两个操作并不需要意识到对方，就可以认为是并发操作，即使两者的操作有一定的时间间隔。</p><h4 id="4-4-3-确定前后关系"><a href="#4-4-3-确定前后关系" class="headerlink" title="4.4.3 确定前后关系"></a>4.4.3 确定前后关系</h4><p>通过下面这个例子来看如何确定前后关系以及并发：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/dependencies%20between%20two%20clients.png"><p>上面的流程可以通过下图来展示：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/graphy%20of%20dependencies.png"><p>服务器判断操作是否并发的依据是对比<strong>版本号</strong>。流程如下：</p><ul><li>服务器对每一个主键维护一个版本号，每次主键写入的时候将版本号加一，和新值一起保存；</li><li>客户端读取时，服务器返回所有未被覆盖的值以及最新的版本号。客户端在写之前必须先读；</li><li>客户端写时，必须附带前一次读时服务器返回的版本号，同时将读到的值和新值合并一起发给服务器；写请求的响应和读一样；</li><li>服务器收到带有特定版本号的写请求时，覆盖该版本号或更低版本号的所有值，但必须保留更高版本号的所有值。</li></ul><h4 id="4-4-4-合并同时写入的值"><a href="#4-4-4-合并同时写入的值" class="headerlink" title="4.4.4 合并同时写入的值"></a>4.4.4 合并同时写入的值</h4><p>在多个操作并发发生时，客户端需要将并发写入的值合并。</p><p>对于删除的数据不能简单地删除，应该使用一个删除标记。</p><p>还可以使用一些专门的数据结构来自动执行合并，比如CRDT。</p><h4 id="4-4-5-版本矢量"><a href="#4-4-5-版本矢量" class="headerlink" title="4.4.5 版本矢量"></a>4.4.5 版本矢量</h4><p>前面的例子只有一个副本，将情况扩展到多个副本算法类似。</p><p>不过需要对每个副本的每个主键都维护一个版本号，构成<strong>版本向量（version vector）</strong>。</p><p>还有一个概念叫做<strong>版本时钟（version clocks）</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> cs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ddia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ddia, Foundations of Data Systems (Part 3): Encoding and Evolution</title>
      <link href="/ddia-foundations-of-data-systems-part-3-encoding-and-evolution/"/>
      <url>/ddia-foundations-of-data-systems-part-3-encoding-and-evolution/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是ddia第四章的阅读笔记。</p></blockquote><blockquote><p><em>Everything changes and nothing stands still.</em></p></blockquote><h2 id="0-Pre"><a href="#0-Pre" class="headerlink" title="0. Pre"></a>0. Pre</h2><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/4.Encoding%20and%20Evolution.png"><p>需求总是在变。上层程序变了，那么下层的数据库就有可能变。</p><p>要么加字段、删字段，要么使用新的方式来展示字段。</p><p>现在的程序升级迭代，往往会造成复杂的情况。</p><p>系统的滚动升级，导致系统中一部分使用旧代码，一部分使用新代码。</p><p>新代码上线之后会使用新的方式来写数据，旧代码就可能读取到新的数据。</p><p>这就要求，两个方向的兼容。</p><p><strong>向后兼容（backward compatility）</strong>和<strong>向前兼容（foreward compatility）</strong>。</p><p>向后兼容是指新代码可以读取旧代码编写的数据；向前兼容是指旧代码可以读取新代码编写的数据。</p><p>向后兼容比较容易，编写新代码的时候只需要注意正确处理旧数据格式即可。</p><p>对于向前兼容就有些麻烦了，旧代码需要忽略新代码的添加。</p><p>数据编码的格式就像不同机器之间的协议一样。</p><p>确定了格式才能正确处理数据。</p><p>所以要先了解一下数据编码的格式有哪些，以及这些格式面对需求变更时是如何处理的。</p><p>有了数据，那么如何使用数据也很重要。</p><p>先看看数据编码的格式。</p><h2 id="1-数据编码格式"><a href="#1-数据编码格式" class="headerlink" title="1. 数据编码格式"></a>1. 数据编码格式</h2><p>数据格式至少有两种。</p><p>一种在内存中，就是各种编程语言中的数据结构。比如数组、结构体、对象等。</p><p>在内存中通过指针可以高效访问这些类型的数据。</p><p>还有一种是在多个主机之间共享的数据，比如通过文件或网络。</p><p>这时指针就不行了。需要一种编码方式将数据编码。</p><p>整体的流程就是，一台主机将内存中需要发送的数据编码，通过一定方式（文件或网络）将数据发送到另一台主机上。</p><p>接收到数据的主机将数据解码加载到内存，然后处理。</p><p>好的，怎么将内存中的数据进行编码呢？</p><h3 id="1-1-语言特定的格式"><a href="#1-1-语言特定的格式" class="headerlink" title="1.1 语言特定的格式"></a>1.1 语言特定的格式</h3><p>首先大多数语言内置了这个功能。</p><p>比如Java的<code>java.io.Serializable</code>等。</p><p>虽然方便但是不推荐使用：</p><ul><li>与语言绑定在一起，使用另一种语言访问就很麻烦；</li><li>有一些安全问题；</li><li>效率低。</li></ul><h3 id="1-2-JSON-amp-XML"><a href="#1-2-JSON-amp-XML" class="headerlink" title="1.2 JSON &amp; XML"></a>1.2 JSON &amp; XML</h3><p>json和XML是可以由不同语言编写与访问的标准化编码，使用得比较广泛。</p><p>json文档大多数语言都支持，这样在一个程序中可以将数据编码成json文档然后发送到另一个程序，解码之后处理，完美。</p><p>这些都是文本格式，对人友好，不过也有一些问题：</p><ul><li>数字编码有一些模糊，比如json不区分整数和浮点数；</li><li>不支持二进制字符串，不过可以通过base64编码解决，虽然数据大了。</li></ul><p>这些问题都不大，现在json和xml以及csv格式已经广泛使用了。</p><p>如果是在组织内部使用，那么json占空间比较大。</p><p>使用二进制编码的话会节省大量空间。</p><h3 id="1-3-Thrift-amp-Protocol-Buffers"><a href="#1-3-Thrift-amp-Protocol-Buffers" class="headerlink" title="1.3 Thrift &amp; Protocol Buffers"></a>1.3 Thrift &amp; Protocol Buffers</h3><p>Thrift和Protocol Buffer是两种二进制编码格式。都需要先使用接口定义语言来描述模式。</p><p>Thrift：</p><pre class="line-numbers language-thift"><code class="language-thift">struct Person {    1: required string            userName,    2: optional i64                favoriteNumber,    3: optional list<string>    interests}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Protocol Buffer：</p><pre class="line-numbers language-protobuf"><code class="language-protobuf"><span class="token keyword">message</span> Peson <span class="token punctuation">{</span>    <span class="token builtin">required</span> <span class="token primitive symbol">string</span> use_name        <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token builtin">optional</span> <span class="token primitive symbol">int64</span> favorite_number    <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token builtin">repeated</span> <span class="token primitive symbol">string</span> interests        <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两者很相似。</p><p>这里不详细介绍它们的编码方式，仅仅看看，它们是如何应对模式变化的。</p><h4 id="1-3-1-字段标签和模式演化"><a href="#1-3-1-字段标签和模式演化" class="headerlink" title="1.3.1 字段标签和模式演化"></a>1.3.1 字段标签和模式演化</h4><p>Thrift和Protocol Buffer都使用标签来标识字段，标签是唯一的，字段名字没有影响。</p><p>标签不可以更改，否则会使已有的编码数据无效。</p><p><strong>添加新字段</strong></p><p>添加新字段，只需要给一个新的标签。旧代码不认识新的字段，那么忽略即可。</p><p>通过数据类型的注释来通知解析器跳过指定的字节数，这样就可以实现向前兼容。</p><p>新代码可以读取旧数据，因为每个字段都有一个唯一的标签。但是当新增的字段是<code>required</code>的话，那么读取旧数据就会失败。</p><p>因为旧数据不会有新增字段。</p><p>所以新增字段需要是<code>optional</code>的，或者具有默认值才能实现向后兼容。</p><p><strong>删除字段</strong></p><p>和添加字段类似，不过兼容性问题刚好相反。</p><p>就是说，只能删除<code>optional</code>的字段，这样旧代码才能成功读取新代码写的数据。</p><p>所以<code>required</code>字段永远不能被删除。</p><p>同时，被删除字段的标签不能再使用。因为系统中可能还有使用旧格式的旧代码在写入数据。</p><h4 id="1-3-2-数据类型和模式演化"><a href="#1-3-2-数据类型和模式演化" class="headerlink" title="1.3.2 数据类型和模式演化"></a>1.3.2 数据类型和模式演化</h4><p>结论：<strong>更改数据类型可能会导致数据丢失精度或被截断的风险</strong>。</p><p>比如将一个32位整数变成一个64位整数。</p><p>新代码读取旧数据，可以自动填充缺失的位为0，没有影响。</p><p>旧代码读取新数据，将一个64位整数解释成32位，就可能丢失数据。</p><h3 id="1-4-Avro"><a href="#1-4-Avro" class="headerlink" title="1.4 Avro"></a>1.4 Avro</h3><p>Avro也使用模式来指定编码的数据结构。有两种模式，Avro IDL用于人工编辑，另一种基于json易于机器读取。</p><p>Avro IDL：</p><pre class="line-numbers language-idl"><code class="language-idl">record Person {    string                     userName;    union { null, long }    favoriteNumber = null;    array<string>            interests;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的json表示：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"record"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Person"</span><span class="token punctuation">,</span>    <span class="token property">"fields"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"userName"</span><span class="token punctuation">,</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"string"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"favoriteNumber"</span><span class="token punctuation">,</span>    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"null"</span><span class="token punctuation">,</span> <span class="token string">"long"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"default"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"interests"</span><span class="token punctuation">,</span>        <span class="token property">"type"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"array"</span><span class="token punctuation">,</span> <span class="token property">"items"</span><span class="token operator">:</span> <span class="token string">"string"</span><span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模式中没有使用标签，为了解析二进制数据，按照出现在模式中的顺序遍历这些字段，然后直接采用模式中每个字段的数据类型进行解析。</p><p>这就是说，只有读取数据的代码使用的模式与写入数据的代码使用的模式一致时，才能正确解析二进制数据。</p><p>那么Avro怎么支持模式演化呢？</p><h4 id="1-4-1-写模式与读模式"><a href="#1-4-1-写模式与读模式" class="headerlink" title="1.4.1 写模式与读模式"></a>1.4.1 写模式与读模式</h4><p>简单来说，编码使用的模式就是写模式，解码使用的模式就是读模式。</p><p>同一个模式不同的目的就可以在读模式与写模式间切换。</p><p>比如一个应用程序知道自己现在使用的模式。当程序用这个模式编码数据时，这就是写模式；使用这个模式来解码收到的数据时，就是读模式。</p><p>Avro允许读模式和写模式不一样，只需要保持兼容即可。</p><p>解码数据时，Avro通过对比查看写模式和读模式并将数据从写模式转换为读模式来解决差异：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/avro%20writer%27s%20schema%20and%20reader%27s%20schema.png"><p>使用字段名进行匹配，这样字段顺序就无关了。</p><p>如果数据中有写模式中有但读模式中没有的字段，直接忽略。</p><p>如果读取的数据需要某个字段，但是写模式中没有，则使用读模式中声明的默认值填充。</p><h4 id="1-4-2-模式演化规则"><a href="#1-4-2-模式演化规则" class="headerlink" title="1.4.2 模式演化规则"></a>1.4.2 模式演化规则</h4><p>在Avro中，向前兼容意味着旧代码使用的模式是读模式，新代码使用的模式是写模式；</p><p>向后兼容意味着新代码使用的模式是读模式，旧代码使用的模式是写模式。</p><p>为了保持兼容性，只能添加或删除具有默认值的字段。</p><p>所以不需要有可选或必须的标签（有联合类型和默认值）。</p><h4 id="1-4-3-什么是写模式"><a href="#1-4-3-什么是写模式" class="headerlink" title="1.4.3 什么是写模式"></a>1.4.3 什么是写模式</h4><p>一个问题：reader怎么知道一个数据的写模式是什么呢？</p><p>记录附带着写模式太不现实了，毕竟模式可能比数据还大。</p><p>答案是Avro使用的上下文。比如：</p><ul><li><strong>有很多记录的大文件</strong>：这个时候只需要在开头加一个模式就可以了；</li><li><strong>具有单独写入记录的数据库</strong>：将所有的模式存在单独的数据库中；</li><li><strong>通过网络发送数据</strong>：在建立协议的时候协商模式即可。</li></ul><h4 id="1-4-4-动态生成的模式"><a href="#1-4-4-动态生成的模式" class="headerlink" title="1.4.4 动态生成的模式"></a>1.4.4 动态生成的模式</h4><p>由于Avro不使用标签，这对动态生成的模式更友好。</p><p>一个例子就是导出关系型数据库中的数据。</p><p>导出的时候根据表动态生成一个模式。</p><p>之后数据库发生变化，还可以生成新的模式。</p><p>所以导出的过程中不需要关注模式的变化，但是使用Thrift或Protocol Buffer的话，就需要小心地选择标签号了。</p><h3 id="1-5-模式的优点"><a href="#1-5-模式的优点" class="headerlink" title="1.5 模式的优点"></a>1.5 模式的优点</h3><ul><li>比二进制的json更紧凑；</li><li>模式是一种最新的文档；</li><li>模式数据库允许在部署任何内容之前检查模式更改的兼容性。</li></ul><h2 id="2-数据流模式"><a href="#2-数据流模式" class="headerlink" title="2. 数据流模式"></a>2. 数据流模式</h2><p>为了支持数据在不同进程之间的流动，才有了上面的那些编码方法。</p><p>那么数据在不同的进程中都可以怎么流动呢？</p><ul><li>通过数据库；</li><li>通过服务调用；</li><li>通过异步消息传递。</li></ul><h3 id="2-1-通过数据库"><a href="#2-1-通过数据库" class="headerlink" title="2.1 通过数据库"></a>2.1 通过数据库</h3><p>写入数据库的进程对数据进行编码，读取数据库的进程对数据进行解码。</p><p>数据库的模式更新也需要注意前后兼容和向前兼容。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/schema%20change%20in%20db.png"><h3 id="2-2-通过服务：REST和RPC"><a href="#2-2-通过服务：REST和RPC" class="headerlink" title="2.2 通过服务：REST和RPC"></a>2.2 通过服务：REST和RPC</h3><p>通过服务调用，数据也可以在不同的进程中流动。</p><p>其中客户端对请求编码，服务端接收请求解码然后对响应编码，客户端再对响应解码。</p><p>由于使用服务调用不能强迫客户升级，所以需要长期保持兼容性。</p><p>这就涉及到API版本的管理了。</p><h3 id="2-3-通过消息传递"><a href="#2-3-通过消息传递" class="headerlink" title="2.3 通过消息传递"></a>2.3 通过消息传递</h3><p>消息代理作为消息的中转，在数据流动的两个角色间进行处理。</p><p>和RPC相比，使用消息代码有以下的好处：</p><ul><li>如果接收方不可用或过载，可以充当缓冲区；</li><li>可以自动将消息重新发送到崩溃的进程，防止消息丢失；</li><li>避免了发送方需要知道接收方的地址；</li><li>在逻辑上将发送方与接收方分离。</li></ul><p>这一章最重要的是，知道数据编码的不同方式，知道如何保持两个方向的兼容性。</p>]]></content>
      
      
      <categories>
          
          <category> cs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ddia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ddia, Foundations of Data Systems (Part 2): Storage and Retrieval</title>
      <link href="/ddia-foundations-of-data-systems-part-2-storage-and-retrieval/"/>
      <url>/ddia-foundations-of-data-systems-part-2-storage-and-retrieval/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是ddia第三章的阅读笔记。</p></blockquote><h2 id="0-Pre"><a href="#0-Pre" class="headerlink" title="0. Pre"></a>0. Pre</h2><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/3.Storage%20%26%20Retrieval.png" alt="3.Storage &amp; Retrieval"></p><p>数据库的功能简单来说就是两个：</p><ul><li>插入数据时，数据库保存数据；</li><li>检索时，数据库返回数据。</li></ul><p>很简单，但是为了达成这两个目的，数据库需要做好多事情。</p><p>这就是这篇文章所要讲述的东西。</p><p>即，数据库底层是如何存储数据的呢？当检索数据的时候，数据库又如何快速找到数据并返回呢？</p><p>这就涉及到了数据库的存储引擎（storage engine）。</p><h2 id="1-从hello-world开始"><a href="#1-从hello-world开始" class="headerlink" title="1. 从hello world开始"></a>1. 从hello world开始</h2><p>既然数据库的功能就是存数据（<code>set</code>）与返回数据（<code>get</code>），那么可以通过下面的Bash函数实现一个最简单的数据库：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>db_set<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$1</span>,<span class="token variable">$2</span>"</span> <span class="token operator">>></span> database<span class="token punctuation">}</span>db_get<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">grep</span> <span class="token string">"^<span class="token variable">$1</span>,"</span> database <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">"s/^<span class="token variable">$1</span>,//"</span> <span class="token operator">|</span> <span class="token function">tail</span> -n 1<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>插入数据：<code>db_set key value</code>；查询数据：<code>db_get key</code>。</p><p>这个最简单的数据库将数据存储在<code>database</code>文件中，新数据添加在文件的末尾，对于一个已有的key更新数据时不覆盖，而是直接添加到末尾。在查询这个key时，返回最后一条记录。</p><p>虽然想法很简单，但很多数据库内部都使用类似的日志（log）结构，这就是<strong>基于日志</strong>的数据库（log-structured database）。</p><p>另一种，是<strong>基于存储页</strong>（page-oriented）的。</p><h2 id="2-Using-Index"><a href="#2-Using-Index" class="headerlink" title="2. Using Index"></a>2. Using Index</h2><p>需要从读和写两方面来审视这个最简单的数据库。</p><p>由于直接在文件末尾添加数据，所以这个数据库的写操作是最简单的。</p><p>随着数据量的增加，对于给定的一个key，需要从头到尾扫描所有的数据来找到这个key的位置，时间复杂度是$O(n)$。</p><p>两个极端，需要平衡。这就是索引（index）的功能，提高读操作的性能。</p><p>索引其实就是基于数据提取元数据作为数据的路标，帮助数据库快速找到数据。</p><p>什么时候提取元数据？最好在插入数据的时候直接就提取了。</p><p>这样，加入索引的代价就是写操作性能降低了。</p><p><strong><em>trade-off</em></strong>是计算机中一个重要的思想。我们在计算机相关的设计中经常遇见它。</p><h3 id="2-1-Hash-Indexes"><a href="#2-1-Hash-Indexes" class="headerlink" title="2.1 Hash Indexes"></a>2.1 Hash Indexes</h3><p>索引就是地图（map），拿着地图就可以找到目标在哪。</p><p>而key-value类型的hash map是大多数编程语言内置的。所以最简单的索引就可以通过这个hash map来实现：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/key-values%20index.png" alt="key-values index"></p><p>hash map的key就是存储数据的key，value就是对应数据在文件中的位置（偏移值）。</p><p>如果把所有key和位置放进内存，这就构成了一个简单的索引系统。</p><p>这样即使所有的value内存存不下也没关系，只需要一次磁盘寻址就可以找到它了。</p><p>而且如果部分数据加载到内存中，这部分数据根本就不需要读磁盘。</p><p>简单但可行，甚至这是Riak默认存储引擎Bitcask的核心做法。</p><p>适用场景：<strong>每个键的值频繁更新的场景</strong>。</p><h3 id="2-2-File-Gets-Bigger-Than-Bigger"><a href="#2-2-File-Gets-Bigger-Than-Bigger" class="headerlink" title="2.2 File Gets Bigger Than Bigger"></a>2.2 File Gets Bigger Than Bigger</h3><p>我们是使用一个文件来存储数据的，而且不会删除，只会增加。</p><p>这样下去是不行的，首先查询效率低；其次，操作系统也不允许无限大的文件。</p><p>咋整？分治吧，一个大文件拆成多个小文件。</p><p>由于同一个key后面的比前面的新，前面的就可以删掉了，所以拆成多个的小文件，还可以压缩：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/compaction%20of%20key-value%20update%20log.png" alt="compaction of key-value update log"></p><p>每个小文件压缩之后还可以将多个小文件合并，进一步压缩：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/segments%20merging.png" alt="segments merging"></p><p>有了多个文件（也就是段，segment）之后，写入没问题，那么查询呢？</p><p>每个文件对应一个自己的hash map，放在内存中作为索引。来一个查询，检查最新的段的hash map，如果没有就检查第二个，以此类推。</p><p>由于压缩与合并的存在，其实不需要维护很多段。</p><h3 id="2-3-More-Things-to-Consider"><a href="#2-3-More-Things-to-Consider" class="headerlink" title="2.3 More Things to Consider"></a>2.3 More Things to Consider</h3><p>想法很不错也简单，但还要注意很多细节。</p><h4 id="2-3-1-实现细节"><a href="#2-3-1-实现细节" class="headerlink" title="2.3.1 实现细节"></a>2.3.1 实现细节</h4><p><strong>file format</strong></p><p>我们用的是csv格式。有什么问题吗？当然了，如果数据中包含csv的分隔符（字段分隔符与行分隔符）就炸了。</p><p>二进制格式文件是最常用的。</p><p><strong>deleting records</strong></p><p>那删除操作怎么办？</p><p>可以用一个字段来标记一下（也可以叫做墓碑，tombstone），mysql中的<code>DELETE</code>就是这么做的。</p><p>如果某条记录已经被删除，日志压缩合并的时候就可以忽略了。</p><p><strong>crash recovery</strong></p><p>如果数据库重启，那么内存中的hash map就会丢失。</p><p>可以重新扫描日志文件来重建索引，但是如果日志量大的话重建过程很慢。</p><p>可以将内存中的hash map的快照保存到磁盘中，下次重启就可以直接加载。</p><p>Bitcask就是这么做的。</p><p><strong>partially written records</strong></p><p>如果由于数据库奔溃导致日志出现损坏，可以通过添加校验值来发现。</p><p><strong>concurrency control</strong></p><p>写日志是严格按照先后顺序写的，通常的实现只有一个写线程。</p><p>日志文件是追加的且不可变，所以可以用多个读线程。</p><h4 id="2-3-2-优势"><a href="#2-3-2-优势" class="headerlink" title="2.3.2 优势"></a>2.3.2 优势</h4><p>想法很简单，但是设计非常不错。优势：</p><ul><li>追加和分段合并主要是顺序写，通常比随机写快得多；</li><li>日志文件是追加的或不可变的，那么并发和奔溃恢复就简单得多；</li><li>日志合并可以避免碎片化问题。</li></ul><h4 id="2-3-3-局限"><a href="#2-3-3-局限" class="headerlink" title="2.3.3 局限"></a>2.3.3 局限</h4><ul><li>hash map需要放进内存，如果放不下呢？</li><li>日志记录是根据时间排序的，区间查询就不太行了。</li></ul><p>怎么办？</p><h3 id="2-4-SSTables-amp-LSM-Tree"><a href="#2-4-SSTables-amp-LSM-Tree" class="headerlink" title="2.4 SSTables &amp; LSM-Tree"></a>2.4 SSTables &amp; LSM-Tree</h3><p>日志结构的存储段都是key-value对的序列，严格根据写入时间排序，同一个key后面的优于前面的，而key的排序不重要。</p><p>前面提到了这种结构的一些不足，比如key不够存进内存以及区间查询等情况。</p><p>这个时候就需要另一种索引，除了时间顺序外，对key也进行排序。</p><p>这就是Sorted String Table，SSTable。</p><p>SSTable要求每个键在每个合并段文件中只出现一次（可以在压缩过程中保证）。</p><h4 id="2-4-1-合并与索引"><a href="#2-4-1-合并与索引" class="headerlink" title="2.4.1 合并与索引"></a>2.4.1 合并与索引</h4><p>既然是日志型数据库，对数据就要进行压缩与合并。由于对key进行了排序，SSTable合并可以更加高效：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/SSTable%20merging.png" alt="SSTable merging"></p><p>同样由于对key进行了排序，我们就可以进行区间查找了。同时，我们也不需要把所有的key都保存在内存中，可以将一部分key作为区间的端点保存在内存中作为索引。结构如下：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/SSTable%20with%20in-memory%20index.png" alt="SSTable with in-memory index"></p><h4 id="2-4-2-SSTable的构建与维护"><a href="#2-4-2-SSTable的构建与维护" class="headerlink" title="2.4.2 SSTable的构建与维护"></a>2.4.2 SSTable的构建与维护</h4><p>首先面对的一个问题就是，插入是随机的，怎么维护key的顺序呢？</p><p>磁盘上排序可以使用B-tree，但是在内存中更容易，比如各种平衡树，插入的时候就可以维护key的顺序。</p><p>既然在内存中排序，那就意味着我们需要在内存中维护部分数据。整体的流程如下：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/sstable.png" alt="sstable"></p><p>这个方案基本上可以工作得很好。</p><p>不过如果数据写入内存的时候数据库奔溃，导致部分数据没有写入到磁盘中，就会出现问题。</p><p>这也好解决，只要在磁盘上维护一个单独的日志，每个写入都立即追加到这个日志即可。</p><p>如果发生崩溃，就可以根据这个日志来进行恢复。同时这个日志也不需要按key排序，因为它的目的在于崩溃恢复。</p><p>当内存表写入磁盘后，这个日志就可以丢弃了。</p><h4 id="2-4-3-Making-an-LSM-tree-out-of-SSTables"><a href="#2-4-3-Making-an-LSM-tree-out-of-SSTables" class="headerlink" title="2.4.3 Making an LSM-tree out of SSTables"></a>2.4.3 Making an LSM-tree out of SSTables</h4><p>很多数据库比如LevelDB和RocksDB使用了上面描述的这个算法。</p><p>这个索引结构最初由Patrick O’Neil等人以日志结构合并树（Log-Structured Merge-Tree，LSM-Tree）命名的。</p><p>所以，基于合并和压缩排序文件原理的存储引擎通常都被称为LSM存储引擎。</p><p>这也是Elasticsearch和Solr等全文搜索系统的索引引擎Lucene的基础。</p><p>此外，还有很多可以考虑的细节。</p><p>比如，如果一个key不存在，那么需要遍历所有key所在范围的段才能确定不存在。这时可以使用布隆过滤器。</p><p>SSTable压缩和合并也有不同的策略，有大小分级和分层压缩等。</p><h2 id="3-B-Tree"><a href="#3-B-Tree" class="headerlink" title="3. B-Tree"></a>3. B-Tree</h2><p>日志结构索引之外还有一种截然不同的索引结构：B-Tree。</p><p>B-Tree和SSTable唯一相同之处在于也对key进行排序。SSTable使用不同的段来存储数据，而B-Tree是基于页的。</p><p>每个页固定大小（通常4KB），是读写的最小单元，这样更接近于底层硬件。</p><p>像内存中的指针一样，不同的页之间也可以互相引用。这样就可以构成树形结构：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/b-tree%20index.png" alt="b-tree index"></p><p>其中的一页作为整棵树的根节点，每次查询都从它开始遍历。</p><p>B-Tree底层的基本写操作是使用新数据来覆盖磁盘上的旧页，这和SSTable只追加不同，覆盖后的页引用可以不变。</p><p>如果需要写的数据旧页装不下，那么就会发生页的分裂。分裂后需要更新父节点对这两个子页的引用。</p><p>如果部分写入的时候发生崩溃，会导致索引破坏。为了解决这个问题，可以使用<strong>预写日志（write-ahead log, WAL）</strong>，也叫重做日志（redo-log）。</p><p>在B-Tree之上的优化：</p><ul><li>使用写时复制来代替预写日志（LMDB）；</li><li>保存键的缩略信息，一个页可以保存更多键，降低树的深度；</li><li>相邻子页顺序保存在磁盘上；</li><li>添加兄弟页的引用；</li><li>分形树，减少磁盘寻道。</li></ul><p>下面简单比较一下两者的优劣。</p><p>简单来说就是，<strong>B-Tree读快，LSM-Tree写快</strong>。</p><p>LSM-Tree在磁盘上顺序写，支持更好地压缩，所以文件通常比B-Tree小，也没有磁盘碎片。由于顺序写，所以写更快。</p><p>B-Tree的优点就是，每个键在索引上都有一个唯一对应的位置，这和LSM-Tree是不同的（LSM-Tree一个键可以在多个段中，只要每个段内键唯一即可）。</p><p>这样B-Tree就可以提供更强的事务支持。</p><p>不过最适用的才是最好的。</p><h2 id="4-其他索引结构"><a href="#4-其他索引结构" class="headerlink" title="4. 其他索引结构"></a>4. 其他索引结构</h2><p>上面介绍的都是key-value索引，就像是关系型数据库中的主键，每个key唯一对应一条记录。</p><p>此外，二级索引（secondary index）也很常见，使用二级索引可以高效地执行行联结操作。</p><p>不过二级索引对应的值不是唯一的。不过值可以是匹配行的列表，也可以加追一些标识符来使键变成唯一的。</p><p>B-Tree和LSM-Tree都支持二级索引。</p><h3 id="4-1-value里存什么"><a href="#4-1-value里存什么" class="headerlink" title="4.1 value里存什么"></a>4.1 value里存什么</h3><p>key就是键，那value里面存什么呢？两种：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/values%20of%20indexes.png" alt="values of indexes"></p><p>第二种堆文件比较常见，可以避免复制数据。</p><p>不过索引到堆文件的跳转会有性能损耗，这样可以在value里直接存所有的数据，这就是聚集索引（clustered index）。</p><p>比如在MySQL InnoDB中，主键始终是聚集索引，二级索引引用主键（而不是堆文件）。</p><p>在聚集索引和非聚集索引之间，可以有一个折中设计，在value里存放部分值，叫做覆盖索引（covering index）或包含列的索引（index with included columns）。</p><p>读取方便那么就会给写入带来麻烦。数据冗余在写入时需要更多工作，不然就会出现不一致的结果。</p><h3 id="4-2-多列索引"><a href="#4-2-多列索引" class="headerlink" title="4.2 多列索引"></a>4.2 多列索引</h3><p>前面提到的索引都是只有一个值的键。多列索引可以同时查询多个列。</p><p>最常见的多列索引是级联索引（concatenated index），只是简单地将多个列组合成一个列（组合的顺序按照索引定义的顺序）。</p><p>级联索引的问题是，需要指定组成索引的第一个列之后才能查找第二个列。</p><p>多维索引（multi-dimensional index）可以提供多个维度的同时筛选，这对于地理位置等很有用。</p><p>不过B-Tree和LSM-Tree不支持多维索引。</p><h3 id="4-3-内存数据库"><a href="#4-3-内存数据库" class="headerlink" title="4.3 内存数据库"></a>4.3 内存数据库</h3><p>随着内存成本的降低，也可以将所有的数据存储在内存中。</p><p>内存数据库的优势并不是因为不需要从磁盘读取。如果内存足够，即使是基于磁盘的存储引擎，也可能不需要从磁盘中读取数据。内存数据库可以更快，是因为它们避免了将内存中的数据编码成磁盘存储格式的开销。</p><p>内存数据库可以支持大于内存的数据量。通过<strong>反缓存方法</strong>，将最近最少使用的数据存入磁盘即可空余出更多的内存空间。</p><h2 id="5-Transaction-Processing-or-Analytics？"><a href="#5-Transaction-Processing-or-Analytics？" class="headerlink" title="5. Transaction Processing or Analytics？"></a>5. Transaction Processing or Analytics？</h2><p>数据库的使用模式可以分为在线事务处理（online transaction processing, OLTP）和在线分析处理（online analytic processing, OLAP）。两者区别如下：</p><table><thead><tr><th>属性</th><th>OLTP</th><th>OLAP</th></tr></thead><tbody><tr><td>主要读特征</td><td>基于键，每次查询返回很少的记录</td><td>对大量记录进行汇总</td></tr><tr><td>主要写特征</td><td>随机访问，低延迟写入用户输入</td><td>批量导入（ETL）或事件流</td></tr><tr><td>典型使用场景</td><td>终端用户，web应用</td><td>内部分析师，为决策提供支持</td></tr><tr><td>数据表征</td><td>最新的数据状态（当前时间点）</td><td>随着时间而变化的所有事件历史</td></tr><tr><td>数据规模</td><td>GB到TB</td><td>TB到PB</td></tr></tbody></table><p>SQL既可以用来做OLTP，也可以用来做OLAP。不过随着数据量的增加，现在开始使用独立的数据库来做OLAP，叫做数据仓库（data warehouse）。</p><h3 id="5-1-Data-Warehouse"><a href="#5-1-Data-Warehouse" class="headerlink" title="5.1 Data Warehouse"></a>5.1 Data Warehouse</h3><p>业务可能会随着时间有越来越多的数据库，这些数据库对各自的业务都很重要，在这只上进行数据分析工作不太现实。</p><p>首先是数据隔离。一个统计分析可以涉及到多个数据库，这需要做表join。</p><p>其次，分析操作需要扫描大量记录，这对数据库的性能有很大的影响。</p><p>所以可以将各个数据库的数据复制一份到另外的地方，来做分析工作。这就是提取-转换-加载（Extract-Transform-Load, ETL）过程：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/etl.png" alt="etl"></p><p>前面介绍的数据库都不太适合做OLAP，所以需要面向分析优化的存储引擎。</p><h3 id="5-2-星型与雪花型分析模型"><a href="#5-2-星型与雪花型分析模型" class="headerlink" title="5.2 星型与雪花型分析模型"></a>5.2 星型与雪花型分析模型</h3><p>和事务处理领域广泛使用了多种不同数据模型不同，分析型业务的数据模型很少。</p><p>比如星型模型：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/star%20schema.png" alt="star schema"></p><p>模型的中心是一个事实表（fact table），其中的列是属性，还有对其他表的外键，这些被引用的表叫做维度表（dimension tables）。</p><p>星型模型的一个变体是雪花模型，其中维度进一步细分为子空间。</p><p>数据仓库中的表可能非常宽，上百个列，包含所有分析数据的元数据。</p><p>这么宽的表也为分析带来了难度，这时就出现了列式存储。</p><h2 id="6-列式存储"><a href="#6-列式存储" class="headerlink" title="6. 列式存储"></a>6. 列式存储</h2><p>用于数据分析的事实表基本上很宽，数据也很多（巨多行），但是查询的时候只会选择其中的几个列，大多数OLTP数据库中，存储是面向行的，即使选择几列，也要把改行所有的数据取出来。</p><p>这样一个直观的改变就是，面向列的存储：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/column%20storage.png" alt="column storage"></p><p>每个列存在一个文件中，查询的时候只要解析使用的列就可以了。</p><p>列文件中按照一定的顺序存储行对应字段的数据，如果要获取某一行的话，将所有列对应记录取出来就可以了。</p><h3 id="6-1-列压缩"><a href="#6-1-列压缩" class="headerlink" title="6.1 列压缩"></a>6.1 列压缩</h3><p>数据库中的列，对应一个属性。而这个属性一般是小于行数的。</p><p>所以可以对列进行压缩，来进一步降低对磁盘吞吐量的要求。</p><p>对列的压缩可以使用位图编码：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/column%20bitmap.png" alt="column bitmap"></p><p>也可以使用游程编码，进一步压缩。</p><p>怎么查询呢？</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">WHERE</span> product_sk <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">68</span><span class="token punctuation">,</span> <span class="token number">69</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以加载<code>product_sk = 30</code>, <code>product_sk = 68</code>和<code>product_sk = 69</code>三个位图，然后按位或操作即可。</p><p>就很神奇。</p><h3 id="6-2-列存储的写操作"><a href="#6-2-列存储的写操作" class="headerlink" title="6.2 列存储的写操作"></a>6.2 列存储的写操作</h3><p>列存储的特点是可以加速查询，但是写入就更加困难了。</p><p>如果在表中插入一列，那么需要更新所有的列文件。不过可以使用类似LSM-Tree的方式，在文件结尾追加。</p><p>也可以使用这种方式来进行排序。</p><h3 id="6-3-Aggregation-Data-Cubes-and-Materialized-Views"><a href="#6-3-Aggregation-Data-Cubes-and-Materialized-Views" class="headerlink" title="6.3 Aggregation: Data Cubes and Materialized Views"></a>6.3 Aggregation: Data Cubes and Materialized Views</h3><p>数据仓库在做分析的时候使用最多的操作就是聚合，比如SQL中的COUNT, SUM, AVG, MIN或MAX等。</p><p>如果聚合操作很多，那一个简单的想法就是，先对原始数据进行聚合，存起来，后面的分析不就可以直接使用了吗？</p><p>物化视图（materialized views）就是实现这种缓存的一种方法。</p><p>数据库中也有视图的概念，但那只是虚拟的，并没有真正存储数据。</p><p>物化视图是写入磁盘的实际结果副本，当底层数据变化时，物化视图也要更新。</p><p>物化视图的一个特殊情况是数据立方体（data cube），是由不同维度分组的聚合网格：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/data%20cube.png" alt="data cube"></p><p>这里是两个维度：日期和产品。data cube可以扩展到多个维度，每一条记录都是所有维度的一个组合条件。</p><p>优点就是查询快，作为在原始数据上只经过一步处理的数据，可以在此基础上做进一步分析，不需要去重新扫描原始数据。</p><p>缺点也很明显，原始数据发生变化，data cube也要变化，显得不太灵活。</p><p>面对不同场景的应用，需要使用不同的工具。不同的工具有自己的优劣，了解它们才能更好地使用。</p>]]></content>
      
      
      <categories>
          
          <category> cs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ddia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ddia, Foundations of Data Systems (Part 1): Terminology, Approach, Data Models and Query Languages</title>
      <link href="/ddia-foundations-of-data-systems-part-1-terminology-approach-data-models-and-query-languages/"/>
      <url>/ddia-foundations-of-data-systems-part-1-terminology-approach-data-models-and-query-languages/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是ddia第一部分数据系统基础中第一章和第二章的阅读笔记。</p></blockquote><h2 id="1-Reliable-Scalable-and-Maintainable-Applications"><a href="#1-Reliable-Scalable-and-Maintainable-Applications" class="headerlink" title="1. Reliable, Scalable, and Maintainable Applications"></a>1. Reliable, Scalable, and Maintainable Applications</h2><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/1.reliable%2C%20scalable%2C%20and%20maintainable%20applications.png" alt="1.可靠、可扩展与可维护的应用系统"></p><p>应用系统包含的模块：</p><ul><li><strong>数据库</strong>：用以存储数据，这样应用就可以再次访问；</li><li><strong>高速缓存</strong>：缓存那些复杂或操作代价昂贵的结果，以加快下一次访问；</li><li><strong>索引</strong>：用户可以按关键字搜索数据并支持各种过滤；</li><li><strong>流式处理</strong>：持续发送消息至另一个进行，处理采用异步处理；</li><li><strong>批处理</strong>：定期处理大量的累积数据。</li></ul><p>单个组件无法满足所有数据处理与存储需求，所以需要将<strong>任务分解</strong>，每个组件负责高效完成其中一部分，然后通过<strong>应用层代码</strong>驱动有机衔接起来。</p><p>容错总是指特定类型的故障，这样的系统才更有实际意义。</p><p>故障与失效：</p><ul><li><strong>故障</strong>：组件偏离其正常规格；</li><li><strong>失效</strong>：系统作为一个整体停止，无法向用户提供所需的服务。</li></ul><p><strong>扇出（fan-out）</strong>：在事务处理系统中，用来描述为了服务一个输入请求而需要做的请求总数，像扇子一样逐渐变多。</p><p>实践中的百分位数：</p><ul><li>近似算法来计算百分位数：<ul><li>正向衰减</li><li>t-digest</li><li>HdrHistogram</li></ul></li><li>采用直方图的方式来聚合响应时间。</li></ul><p>把无状态服务分布然后扩展至多台机器相对比较容易，而有状态服务从单个节点扩展到分布式多机环境的复杂性会大大增加。</p><p>消除意外复杂性最好手段之一是<strong>抽象</strong>。</p><h2 id="2-Data-Models-and-Query-Languages"><a href="#2-Data-Models-and-Query-Languages" class="headerlink" title="2. Data Models and Query Languages"></a>2. Data Models and Query Languages</h2><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/2.Data%20Models%20and%20Query%20Languages.png" alt="2.Data Models and Query Languages"></p><p>这里介绍三种数据模型：关系模型、文档模型和图模型。</p><p>关系模型就是SQL，对应关系型数据库。关系模型的一个问题就是阻抗失衡（impedance mismatch），数据表结构发生变化，代码中的关系映射也需要变化，且不一定完全匹配。</p><p>文档模型就是NoSQL，比如MongoDB，使用json文档来存储数据，更适合存储一对多的树形层级数据。</p><p>关系模型为了存储一对多的数据，需要使用多个表，这样读取信息的时候需要多次查询；而文档模型具有更好的局部性，只需要一次查询就可以了。</p><p>MySQL 5.7 添加了json。</p><p><strong>任何对人类有意义的东西都有可能在将来某个时刻发生变化，没有直接意义的就可以永远不需要变化</strong>。</p><p>数据库规范化的核心思想就是：<strong>消除重复</strong>。如果复制了多份重复数据，那么该模式通常就违背了规范化。</p><p>关系模型的一个核心要点是，<strong>只需要构建一次查询优化器，然后使用该数据库的所有应用程序都可以从中受益。</strong></p><p>模式：读时模式（数据的结构是隐式的，只有在读取的时候才解释），写时模式（关系数据库的传统方法，模式是显式的，写入时必须遵守）。</p><p>数据查询语言：</p><table><thead><tr><th>命令式</th><th>声明式</th></tr></thead><tbody><tr><td>告诉计算机以特定的顺序执行</td><td>只需指定所需的数据模式</td></tr><tr><td>数据有固定的顺序</td><td>数据无固定的顺序</td></tr><tr><td>很难并行化</td><td>适用于并行执行</td></tr></tbody></table><p>如果数据大多是一对多关系（树结构数据）或者记录之间没有关系，那么文档模型是最合适的。</p><p>图模型更为强大的用途在于，提供了单个数据存储区中保存完全不同类型对象的一致性方式。</p><p>图有利于演化：向应用程序添加功能时，图可以容易地扩展以适应数据结构的不断变化。</p><p>文档数据库和图数据库有一个共同点，就是它们通常不会对存储的数据强加某个模式，这可以使应用程序更容易适应不断变化的需求。</p>]]></content>
      
      
      <categories>
          
          <category> cs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ddia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp ch02 (part 5): Summary</title>
      <link href="/csapp-ch02-part-5-summary/"/>
      <url>/csapp-ch02-part-5-summary/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是基于csapp第二章的习题做的一个总结，习题以及答案在<a href="https://valineliu.gitbook.io/deuterium-wiki/reading/cs-jing-dian-shu-ji/csapp-3e-homework-solution/2.-representing-and-manipulating-information" target="_blank" rel="noopener">这里</a>。</p></blockquote><h2 id="1-信息的存储"><a href="#1-信息的存储" class="headerlink" title="1. 信息的存储"></a>1. 信息的存储</h2><p>计算机中信息的存储就是bit，每8个bit构成一个byte，所有的空间都是由一系列byte组成的。几个byte就可以表示一个信息，具体的信息就需要相应的context来解释。那么对于具有多个byte的对象来说，如何进行排列是很重要的。</p><h3 id="1-1-字节序"><a href="#1-1-字节序" class="headerlink" title="1.1 字节序"></a>1.1 字节序</h3><p>这就涉及到了字节序的概念。根据不同的排列方式分类little-endian和big-endian。可以通过下面的代码来查看，对应的机器是否是little-endian的：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> byte_pointer<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">is_little_endian</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">0xff</span><span class="token punctuation">;</span>    byte_pointer pval<span class="token operator">=</span> <span class="token punctuation">(</span>byte_pointer<span class="token punctuation">)</span><span class="token operator">&amp;</span>val<span class="token punctuation">;</span>    <span class="token keyword">return</span> pval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0xff</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路很简单，就是检查一下变量对应地址的第一个字节的内容。</p><p>一个字节（byte）是8 bit。C语言中，可以通过<code>sizeof</code>来查看指定类型所占字节数：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-位运算与逻辑运算"><a href="#1-2-位运算与逻辑运算" class="headerlink" title="1.2 位运算与逻辑运算"></a>1.2 位运算与逻辑运算</h3><p>在移位操作中，如果移动<code>i</code>个字节，那么可以通过下面的方式得到具体的移动位：</p><pre class="line-numbers language-c"><code class="language-c">i <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>C语言中的位操作，除了位移，还有与（<code>&amp;</code>）或亦（<code>^</code>）或（<code>|</code>）取反（<code>~</code>）等。</p><p>灵活使用一些位操作，可以很方便地达到一些目的。比如，不使用额外的变量来交换两个值：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">inplace_swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">*</span>y <span class="token operator">=</span> <span class="token operator">*</span>x <span class="token operator">^</span> <span class="token operator">*</span>y<span class="token punctuation">;</span>    <span class="token operator">*</span>x <span class="token operator">=</span> <span class="token operator">*</span>x <span class="token operator">^</span> <span class="token operator">*</span>y<span class="token punctuation">;</span>    <span class="token operator">*</span>y <span class="token operator">=</span> <span class="token operator">*</span>x <span class="token operator">^</span> <span class="token operator">*</span>y<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和位操作很像但是又有不同的是逻辑运算。有与（<code>&amp;&amp;</code>）或（<code>||</code>）非（<code>!</code>）。</p><p>一个小技巧就是，通过亦或和非来替代等于比较：</p><pre class="line-numbers language-c"><code class="language-c">x <span class="token operator">==</span> y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等同于：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token operator">!</span><span class="token punctuation">(</span>x <span class="token operator">^</span> y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>逻辑运算中，当第一个参数就能确定结果的时候，是不会计算第二个参数的值的。</strong>根据这个性质，我们可以通过一个小技巧，不使用<code>if</code>就可以达到<code>if</code>的效果。</p><p>比如下面的条件语句：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> flag<span class="token punctuation">;</span><span class="token keyword">int</span> sum<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    sum <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，根据<code>flag</code>的值来对<code>sum</code>赋值。如果<code>flag=1</code>的话，那么<code>sum</code>就赋值为<code>INT_MIN</code>；否则保持原样。我们可以通过逻辑运算不使用<code>if</code>来达到这个效果：</p><pre class="line-numbers language-c"><code class="language-c">flag <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>sum <span class="token operator">=</span> INT_MIN<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>是不是很神奇？</p><h3 id="1-3-移位运算"><a href="#1-3-移位运算" class="headerlink" title="1.3 移位运算"></a>1.3 移位运算</h3><p>前面稍微提到了移位运算，移位运算也很重要。有两个方向，左移和右移，左移很简单了，主要是右移涉及到一些整数编码的问题。</p><p>整数的表示在下面介绍，这里只说，右移分为逻辑右移和算术右移。</p><p>逻辑右移就直接补0，算术右移需要看最高位的值，用最高位的值来补移出的空位。</p><p>好的，现在有一台机器，使用C语言来看看，这台机器右移是否是算术右移：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">int_shifts_are_arithmetic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span>val <span class="token operator">^</span> <span class="token punctuation">(</span>val <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们通过位运算代替了<code>==</code>操作符。</p><p>关于右移还有一个有意思的问题就是，通过逻辑右移来实现算术右移以及，通过算术右移来实现逻辑右移：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token function">srl</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* Perform shift arithmetically */</span>    <span class="token keyword">unsigned</span> xsra <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>x <span class="token operator">>></span> k<span class="token punctuation">;</span>    <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>w <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> xsra <span class="token operator">&amp;</span> <span class="token operator">~</span>mask<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">unsigned</span> <span class="token function">sra</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* Perform shift logically */</span>    <span class="token keyword">int</span> xsrl <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span>x <span class="token operator">>></span> k<span class="token punctuation">;</span>    <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>w <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Get the most significant bit unchanged, 0 for other bits */</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>w <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Make mask unchanged if the most significant bit of x is 1, changed otherwise */</span>    mask <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> m<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> xsrl <span class="token operator">|</span> mask<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里就涉及到一些位运算和移位操作的综合了。</p><p>对于移位操作，需要注意在C语言中：</p><blockquote><p>If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined.</p></blockquote><h2 id="2-整数的表示"><a href="#2-整数的表示" class="headerlink" title="2. 整数的表示"></a>2. 整数的表示</h2><p>C语言中整数有<code>signed</code>和<code>unsigned</code>。对于<code>signed</code>，使用最高位作为符号，1为负0位正。所以可以通过查看这个最高位来检查正负：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> sign <span class="token operator">=</span> i <span class="token operator">&amp;</span> INT_MIN<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果<code>sign==0</code>就说明是正数，否则为负。</p><p>如果一个<code>signed</code>类型一共有<code>n</code>个bit，那么我们可以知道这个类型所能表示值的范围：[$-2^{n-1}$,$2^{n-1}-1$)。对于一个<code>int</code>类型的值<code>x</code>，能否使用<code>n</code>个bit来进行补码编码呢？</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fits_bits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> offset <span class="token operator">=</span> w <span class="token operator">-</span> n<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;&lt;</span> offset <span class="token operator">>></span> offset<span class="token punctuation">)</span> <span class="token operator">==</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>能的话就返回1，否则返回0。</p><h2 id="3-整数的运算"><a href="#3-整数的运算" class="headerlink" title="3. 整数的运算"></a>3. 整数的运算</h2><p>整数的运算，由于使用固定长度表示，就有溢出的可能。</p><p>判断加法是否溢出：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tadd_ok</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>    <span class="token keyword">int</span> neg_over <span class="token operator">=</span> x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> sum <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pos_over <span class="token operator">=</span> x <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> sum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">!</span>neg_over <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>pos_over<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>判断减法是否溢出：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tsub_ok</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> sub <span class="token operator">=</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span>    <span class="token keyword">int</span> pos_flag <span class="token operator">=</span> x <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> sub <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> neg_flag <span class="token operator">=</span> x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> sub <span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">!</span>pos_flag <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>neg_flag<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>判断乘法是否溢出：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tmult_ok</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">!</span>x <span class="token operator">||</span> p<span class="token operator">/</span>x <span class="token operator">==</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>无符号整数除以2的幂次数的时候，直接右移就可以了；但是对于有符号数，负数不可以直接右移，因为需要向0取舍。所以负数做2的幂次数的除法时，需要添加bias。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* * 3*x/4 should not overflow, then divide 4 first, and multiple 3 * Rounding to zero: *        x is equal to m30(the most significant 30 bits) plus l2(the least significant 2 bits) *        x = m30 + l2 *        m30 = x &amp; ~0x3; *        l2 = x &amp; 0x3; *        when x >= 0, m30d4m3 = (m30 >> 2) &lt;&lt; 1 + (m30 >> 2), l2m3d4 = ((l2 &lt;&lt; 1) + l2) >> 2; *        when x &lt; 0, need bias, bias = 3 */</span><span class="token keyword">int</span> <span class="token function">threefourths</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> neg_flag <span class="token operator">=</span> x <span class="token operator">&amp;</span> INT_MIN<span class="token punctuation">;</span>    <span class="token keyword">int</span> m30 <span class="token operator">=</span> x <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">0x3</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> l2 <span class="token operator">=</span> x <span class="token operator">&amp;</span> <span class="token number">0x3</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m30d4m3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>m30 <span class="token operator">>></span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>m30 <span class="token operator">>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> bias <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> l2m3 <span class="token operator">=</span> <span class="token punctuation">(</span>l2 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> l2<span class="token punctuation">;</span>    <span class="token punctuation">(</span>neg_flag<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>l2m3 <span class="token operator">=</span> l2m3 <span class="token operator">+</span> bias<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> l2m3d4 <span class="token operator">=</span> l2m3 <span class="token operator">>></span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> m30d4m3 <span class="token operator">+</span> l2m3d4<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子综合了乘法与除法，以及溢出的概念。</p><h2 id="4-浮点数"><a href="#4-浮点数" class="headerlink" title="4. 浮点数"></a>4. 浮点数</h2><p>浮点数的表示比整数复杂多了，需要对于IEEE浮点数表示法有所了解。</p><p>对于以0.yyy…（y是k bit的序列）这样表示的二进制浮点数来说，它的值n可以表示为：$n=\frac{Y}{2^k-1}$，其中$Y=B2U_k(y)$。</p><p>这样我们可以对一个不能使用二进制精确表示的分数得到一个近似的二进制表示了。</p><p>比如5/7，k=3，y=101，所以二进制表示就是0.101101101…</p><p>IEEE的浮点数表示法有三个主要的部分：<code>sign</code>, <code>exp</code>和<code>frac</code>，这三个部分对于浮点数的一些计算很重要。</p><p>比如将一个$2^x$形式的整数使用浮点数的形式表示：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">float</span> <span class="token function">u2f</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> u<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>u<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">float</span> <span class="token function">fpwr2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* Result exponent and fraction */</span>    <span class="token keyword">unsigned</span> exp<span class="token punctuation">,</span> frac<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> u<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* E=1-bias=1-127=-126 n=23 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">149</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Too small. Return 0.0 */</span>        exp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        frac <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">126</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Denormalized result */</span>        exp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        frac <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">149</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Normalized result */</span>        exp <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">127</span><span class="token punctuation">;</span>        frac <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Too big. Return +oo */</span>        exp <span class="token operator">=</span> <span class="token number">0xFF</span><span class="token punctuation">;</span>        frac <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* Pack exp and frac into 32 bits */</span>    u <span class="token operator">=</span> exp <span class="token operator">&lt;&lt;</span> <span class="token number">23</span> <span class="token operator">|</span> frac<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Return as float */</span>    <span class="token keyword">return</span> <span class="token function">u2f</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自己手动来拼接浮点数的表示对于理解浮点数的表示很有帮助。</p><p>拿到一个浮点数的编码来计算对应的值是很容易的。但是将一个整数转成浮点数编码，还是比较复杂的：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> float_bits<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* Get bit length for integer i. Return 32 when i is negative. */</span><span class="token keyword">int</span> <span class="token function">bits_length</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&amp;</span> INT_MIN<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">32</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> u <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span>i<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>u <span class="token operator">>=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        length<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> length<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* Generage mask for length len. e.g. 3->0x7 */</span><span class="token keyword">unsigned</span> <span class="token function">generate_mask</span><span class="token punctuation">(</span><span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">>></span> <span class="token punctuation">(</span><span class="token number">32</span><span class="token operator">-</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>float_bits <span class="token function">float_i2f</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> sign<span class="token punctuation">,</span> exp<span class="token punctuation">,</span> frac<span class="token punctuation">,</span> exp_frac<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> bias <span class="token operator">=</span> <span class="token number">0x7F</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* i = 0 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sign <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        exp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        frac <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sign <span class="token operator">&lt;&lt;</span> <span class="token number">31</span> <span class="token operator">|</span> exp <span class="token operator">&lt;&lt;</span> <span class="token number">23</span> <span class="token operator">|</span> frac<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* i = INT_MIN */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> INT_MIN<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sign <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        exp <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">+</span> bias<span class="token punctuation">;</span>        frac <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sign <span class="token operator">&lt;&lt;</span> <span class="token number">31</span> <span class="token operator">|</span> exp <span class="token operator">&lt;&lt;</span> <span class="token number">23</span> <span class="token operator">|</span> frac<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    sign <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* i is negative */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sign <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        i <span class="token operator">=</span> <span class="token operator">-</span>i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token function">bits_length</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> flength <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> mask <span class="token operator">=</span> <span class="token function">generate_mask</span><span class="token punctuation">(</span>flength<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> f <span class="token operator">=</span> i <span class="token operator">&amp;</span> mask<span class="token punctuation">;</span>    exp <span class="token operator">=</span> bias <span class="token operator">+</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flength <span class="token operator">&lt;=</span> <span class="token number">23</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* no overflow */</span>        frac <span class="token operator">=</span> f <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">23</span> <span class="token operator">-</span> flength<span class="token punctuation">)</span><span class="token punctuation">;</span>        exp_frac <span class="token operator">=</span> exp <span class="token operator">&lt;&lt;</span> <span class="token number">23</span> <span class="token operator">|</span> frac<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* overflow */</span>        <span class="token keyword">int</span> offset <span class="token operator">=</span> flength <span class="token operator">-</span> <span class="token number">23</span><span class="token punctuation">;</span>        frac <span class="token operator">=</span> f <span class="token operator">>></span> offset<span class="token punctuation">;</span>        exp_frac <span class="token operator">=</span> exp <span class="token operator">&lt;&lt;</span> <span class="token number">23</span> <span class="token operator">|</span> frac<span class="token punctuation">;</span>        <span class="token keyword">int</span> round_mid <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>offset <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> round_part <span class="token operator">=</span> f <span class="token operator">&amp;</span> <span class="token function">generate_mask</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* round to even */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>round_part <span class="token operator">&lt;</span> round_mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>round_part <span class="token operator">></span> round_mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>            exp_frac <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>frac <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                exp_frac <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sign <span class="token operator">&lt;&lt;</span> <span class="token number">31</span> <span class="token operator">|</span> exp_frac<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要考虑各种情况。其中round to even部分的代码解释了，怎么才能round to even。</p>]]></content>
      
      
      <categories>
          
          <category> cs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp ch02 (part 4): Floating Point</title>
      <link href="/csapp-ch02-part-4-floating-point/"/>
      <url>/csapp-ch02-part-4-floating-point/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是csapp第二章第四节的阅读笔记。</p></blockquote><p>接下来看看浮点数的表示。</p><h2 id="1-二进制小数"><a href="#1-二进制小数" class="headerlink" title="1. 二进制小数"></a>1. 二进制小数</h2><p>首先看看有小数部分的二进制数：<br>$$<br>b_mb_{m-1}\cdots b_1b_0.b{-1}b{-2}\cdots b_{-n}<br>$$<br>和无符号整数类似，这个二进制小数的值可以这样计算：<br>$$<br>b=\sum_{i=-n}^m2^i\times b_i<br>$$<br>比如：$101.11_2=1\times 2^2+0\times 2^1+1\times 2^0+1\times 2^{-1}+1\times 2^{-2}=5\frac{3}{4}$。</p><h2 id="2-IEEE浮点数表示"><a href="#2-IEEE浮点数表示" class="headerlink" title="2. IEEE浮点数表示"></a>2. IEEE浮点数表示</h2><p>使用上面的方法无法表达很大的数，因此使用类似$x\times 2^y$的形式来表示。</p><p>IEEE浮点数就是使用这种形式：$V=(-1)^s\times M\times 2^E$。</p><ul><li>$s$：表示符号（<em>sign</em>），如果$s=0$代表这个数是正数；$s=1$表示负数；</li><li>$M$：尾数（<em>significant</em>），是一个二进制小数，范围是1到$2-\epsilon$或0到$1-\epsilon$；</li><li>$E$：阶码（<em>exponent</em>），将整个数的值乘以$2^E$。</li></ul><p>这样一个浮点数的二进制表示就有三个部分。下图表示的是C语言中单精度浮点数<code>float</code>和双精度浮点数<code>double</code>的二进制形式：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/Standard%20floating-point%20formats.png" alt="Standard floating-point formats"></p><p>即使用一个bit表示$s$，k个bit表示$E$和n个bit表示$M$。其中单精度下$k=8,n=23$，双精度下$k=11,n=52$。</p><p>使用上面的格式编码的浮点数，对应的值有三种情况。</p><h3 id="2-1-规格化的值"><a href="#2-1-规格化的值" class="headerlink" title="2.1 规格化的值"></a>2.1 规格化的值</h3><p>这是最普通的情况，这时<code>exp</code>既不都是0也不都是1，这时，阶码$E=e-Bias$，其中$e$就是<code>exp</code>对应的十进制数，而$Bias$是$2^{k-1}-1$，单精度下是127，双精度下是1023。</p><p>同时，尾数$M=1+f$，其中$f$就是<code>frac</code>部分编码的 。这样$M$的二进制形式就是$1.f{n-1}f{n-2}\cdots f_0$。</p><h3 id="2-2-非规格化的值"><a href="#2-2-非规格化的值" class="headerlink" title="2.2 非规格化的值"></a>2.2 非规格化的值</h3><p>当<code>exp</code>全是0时，这个浮点数就是非规格化的值。这时。阶码$E=1-Bias$，而尾数$M=f$。</p><p>非规格化的值可以表示0。规格化的值不能表示0因为尾数$M=1+f&gt;0$。当<code>exp</code>和<code>frac</code>都是0时就表示0。同时$s$的存在，还可以表示-0.0和+0.0。</p><p>非规格化的值还可以表示非常接近0的值。</p><h3 id="2-3-特殊值"><a href="#2-3-特殊值" class="headerlink" title="2.3 特殊值"></a>2.3 特殊值</h3><p>当<code>exp</code>都是1,的时候，可以表示一些特殊值。比如<code>frac</code>都是0的时候，可以表示无穷。同时根据$s$的值可以表示正无穷和负无穷。</p><p>当<code>frac</code>不全是0的时候，表示<code>NaN</code>，not a number。这个值可以表示$\sqrt{-1}$和$\infty-\infty$的值。</p><h2 id="3-示例数字"><a href="#3-示例数字" class="headerlink" title="3. 示例数字"></a>3. 示例数字</h2><p>下面的表格就演示了IEEE浮点数的表示方法（其中k=4，n=3，Bias=7）：</p><table><thead><tr><th>Description</th><th>Bits</th><th>$e$</th><th>$E$</th><th>$2^E$</th><th>$f$</th><th>$M$</th><th>$2^E\times M$</th><th>Decimal</th></tr></thead><tbody><tr><td>Zero</td><td>0 0000 000</td><td>0</td><td>-6</td><td>$\frac{1}{64}$</td><td>$\frac{0}{8}$</td><td>$\frac{0}{8}$</td><td>$\frac{0}{512}$</td><td>0.0</td></tr><tr><td>Smallest positive</td><td>0 0000 001</td><td>0</td><td>-6</td><td>$\frac{1}{64}$</td><td>$\frac{1}{8}$</td><td>$\frac{1}{8}$</td><td>$\frac{1}{512}$</td><td>0.001953</td></tr><tr><td></td><td>0 0000 010</td><td>0</td><td>-6</td><td>$\frac{1}{64}$</td><td>$\frac{2}{8}$</td><td>$\frac{2}{8}$</td><td>$\frac{2}{512}$</td><td>0.003906</td></tr><tr><td></td><td>0 0000 011</td><td></td><td></td><td>$\frac{1}{64}$</td><td>$\frac{3}{8}$</td><td>$\frac{3}{8}$</td><td>$\frac{3}{512}$</td><td>0.005859</td></tr><tr><td></td><td>$\vdots$</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Largest denormalized</td><td>0 0000 111</td><td>0</td><td>-6</td><td>$\frac{1}{64}$</td><td>$\frac{7}{8}$</td><td>$\frac{7}{8}$</td><td>$\frac{7}{512}$</td><td>0.013672</td></tr><tr><td>Smallest normalized</td><td>0 0001 000</td><td>1</td><td>-6</td><td>$\frac{1}{64}$</td><td>$\frac{0}{8}$</td><td>$\frac{8}{8}$</td><td>$\frac{8}{512}$</td><td>0.015625</td></tr><tr><td></td><td>0 0001 001</td><td>1</td><td>-6</td><td>$\frac{1}{64}$</td><td>$\frac{1}{8}$</td><td>$\frac{9}{8}$</td><td>$\frac{9}{512}$</td><td>0.017578</td></tr><tr><td></td><td>$\vdots$</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0 0110 110</td><td>6</td><td>-1</td><td>$\frac{1}{2}$</td><td>$\frac{6}{8}$</td><td>$\frac{14}{8}$</td><td>$\frac{14}{16}$</td><td>0.875</td></tr><tr><td></td><td>0 0110 111</td><td>6</td><td>-1</td><td>$\frac{1}{2}$</td><td>$\frac{7}{8}$</td><td>$\frac{15}{8}$</td><td>$\frac{15}{16}$</td><td>0.9375</td></tr><tr><td>One</td><td>0 0111 000</td><td>7</td><td>0</td><td>1</td><td>$\frac{0}{8}$</td><td>$\frac{8}{8}$</td><td>$\frac{8}{8}$</td><td>1.0</td></tr><tr><td></td><td>0 0111 001</td><td>7</td><td>0</td><td>1</td><td>$\frac{1}{8}$</td><td>$\frac{9}{8}$</td><td>$\frac{9}{8}$</td><td>1.125</td></tr><tr><td></td><td>0 0111 010</td><td>7</td><td>0</td><td>1</td><td>$\frac{2}{8}$</td><td>$\frac{10}{8}$</td><td>$\frac{10}{8}$</td><td>1.25</td></tr><tr><td></td><td>$\vdots$</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0 1110 110</td><td>14</td><td>7</td><td>128</td><td>$\frac{6}{8}$</td><td>$\frac{14}{8}$</td><td>$\frac{1792}{8}$</td><td>224.0</td></tr><tr><td>Largest normalized</td><td>0 1110 111</td><td>14</td><td>7</td><td>128</td><td>$\frac{7}{8}$</td><td>$\frac{15}{8}$</td><td>$\frac{1920}{8}$</td><td>240.0</td></tr><tr><td>Infinity</td><td>0 1111 000</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr></tbody></table><p>使用这种方式，可以保证随着二进制编码的递增，对应的浮点数的值也是递增的（负数反过来）。</p><p>这样对于浮点数的排序就可以直接对二进制编码进行排序了。</p><p>同时，对于非规格化我们使用$1-Bias$作为$E$，过渡到规格化时使用$e-Bias$，可以看到一个渐进递增的关系。</p><p>作为一个例子，下面演示把一个整数编码转换成对应的浮点数编码。</p><ol><li><p>整数3510593的十六进制编码是<code>0x00359141</code>，把它转换成对应的单精度编码。</p></li><li><p>首先二进制编码是：<code>0000,0000,0011,0101,1001,0001,0100,0001</code>；</p></li><li><p>可以表示成$1.1010,1100,1000,1010,0000,1_2\times 2^{21}$；</p></li><li><p>那么位数M就是<code>1.1010,1100,1000,1010,0000,1</code>，需要右移21位，所以$E=21$；</p></li><li><p>这是一个规格化的数，所以f就是<code>0.1010,1100,1000,1010,0000,1</code>；</p></li><li><p>单精度下<code>frac</code>一共23位，所以f需要补0：<code>0.1010,1100,1000,1010,0000,100</code>，这样就得到了<code>frac</code>的编码；</p></li><li><p>规格化下$E=e-Bias$，其中$Bias=127$，所以$e=21+127=148=1001,0100_2$，所以<code>exp</code>的编码就是<code>1001,0100</code>；</p></li><li><p>最后这是一个正数，所以$s=0$，得到对应浮点数的编码：<code>0100,1010,0101,0110,0100,0101,0000,0100</code>，十六进制就是<code>0x4A564504</code>。</p></li></ol><h2 id="4-舍入（Rounding）"><a href="#4-舍入（Rounding）" class="headerlink" title="4. 舍入（Rounding）"></a>4. 舍入（Rounding）</h2><p>因为精度和位数的限制，浮点数只能近似地表示实数运算，所以浮点数运算涉及到一个舍入的问题。下表展示了四种舍入的方式：</p><table><thead><tr><th>Mode</th><th>1.40</th><th>1.60</th><th>1.50</th><th>2.50</th><th>-1.50</th></tr></thead><tbody><tr><td>Round-to-even</td><td>1</td><td>2</td><td>2</td><td>2</td><td>-2</td></tr><tr><td>Round-toward-zero</td><td>1</td><td>1</td><td>1</td><td>2</td><td>-1</td></tr><tr><td>Round-down</td><td>1</td><td>1</td><td>1</td><td>2</td><td>-2</td></tr><tr><td>Round-up</td><td>2</td><td>2</td><td>2</td><td>3</td><td>-1</td></tr></tbody></table><p>其中后三种都好理解，不好理解的是第一种：Round-to-even。</p><p>为什么要向偶数舍入呢？考虑这个场景。我们需要计算一组数的平均数，如果采用下面的三种舍入方法，那么对于同样符号（正负）的数来说，舍入的方向是一样的，这样在计算平均值的时候带来的偏差会比较大。相反，如果使用第一种，即向偶数舍入，那么一组数大概率50%的数向上舍入50%的数向下舍入，平衡了舍入带来的偏差。不过这种舍入方式计算的平均值也比真实值略高一些。</p><h2 id="5-浮点数运算"><a href="#5-浮点数运算" class="headerlink" title="5. 浮点数运算"></a>5. 浮点数运算</h2><p>IEEE浮点数的运算是这样的，将两个浮点数当做看作两个实数$x,y$，对于加法就计算$Round(x+y)$。也就是先计算然后舍入。</p><p>不过由于有限的精度，可以不需要完全计算出结果，只要精度够了即可。</p><p>像有符号和无符号整数的加法一样，浮点数的加法也构成一个阿贝尔群，只不过由于舍入的存在，令$x+^fy$定义为$Round(x+y)$，需要考虑如下的特点：</p><ul><li><p>由于溢出，$x+^fy$可能得到无穷；</p></li><li><p>可交换：$x+^fy=y+^fx$；</p></li><li><p>不可结合：$(x+^fy)+^fz$和$x+^f(y+^fz)$不一定相等。比如<code>(3.14+1e10)-1e10</code>的结果是<code>0.0</code>，而<code>3.14+(1e10-1e10)</code>的结果是<code>3.14</code>；</p></li><li><p>由于不可结合，因此编译器对于浮点数就不能做一些优化。比如：</p><pre class="line-numbers language-c"><code class="language-c">x <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>y <span class="token operator">=</span> b <span class="token operator">+</span> c <span class="token operator">+</span> d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>就不能优化成：</p><pre class="line-numbers language-c"><code class="language-c">t <span class="token operator">=</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>x <span class="token operator">=</span> a <span class="token operator">+</span> t<span class="token punctuation">;</span>y <span class="token operator">=</span> t <span class="token operator">+</span> d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>浮点数加法满足单调性：如果$a\geq b$，那么对于不是<code>NaN</code>的<code>x</code>来说，有$x+^fa\geq x+^fb$；</p></li></ul><p>浮点数的乘法也具有和浮点数的加法一致的上述特征。同时，对于浮点数乘法来说，$a\ast ^fa\geq0$，这对于无符号和有符号整数的乘法来说不满足。</p><h2 id="6-C语言中的浮点数"><a href="#6-C语言中的浮点数" class="headerlink" title="6. C语言中的浮点数"></a>6. C语言中的浮点数</h2><p>C语言中有两种浮点数：<code>float</code>和<code>double</code>，两者在和<code>int</code>做类型转换时，原则如下：</p><ul><li><code>int</code>转<code>float</code>：不会溢出，但是会舍入；</li><li><code>int</code>或<code>float</code>转<code>double</code>：没有精度损失；</li><li><code>double</code>转<code>float</code>：值可能会变成正无穷或负无穷，因为可表示范围小了，同时也会有舍入，因为精度也小了；</li><li><code>float</code>或<code>double</code>转<code>int</code>：值会向0舍入。比如<code>1.999</code>变成<code>1</code>，<code>-1.999</code>变成<code>-1</code>。也有可能溢出，不过C语言没有规定溢出后的<code>int</code>值，与Intel兼容的处理器会将结果指定为$TMin_w$。转换浮点数到整数的时候，如果找不到一个合理的值，就使用这个值。因此<code>(int) +1e10</code>的结果是<code>-2147483648</code>。</li></ul><p>通过下面的几个例子做一下练习（其中<code>x</code>，<code>f</code>和<code>d</code>分别是<code>int</code>，<code>float</code>和<code>double</code>类型的值）：</p><table><thead><tr><th>Expression</th><th>True or False</th><th>Explanation</th></tr></thead><tbody><tr><td><code>x==(int)(double)x</code></td><td>✔</td><td><code>double</code>的精度大于<code>int</code></td></tr><tr><td><code>x==(int)(float)x</code></td><td>✘</td><td>当<code>x=TMax</code>时错误</td></tr><tr><td><code>d==(double)(float)d</code></td><td>✘</td><td>当<code>d=1e40</code>时，结果是正无穷</td></tr><tr><td><code>f==(float)(double)f</code></td><td>✔</td><td><code>double</code>的精度大于<code>float</code></td></tr><tr><td><code>f==-(-f)</code></td><td>✔</td><td>浮点数使用<code>s</code>表示正负</td></tr><tr><td><code>1.0/2==1/2.0</code></td><td>✔</td><td>计算的时候两个数都会转换成浮点数</td></tr><tr><td><code>d*d&gt;=0.0</code></td><td>✔</td><td>正确，即使会溢出</td></tr><tr><td><code>(f+d)-f==d</code></td><td>✘</td><td>这个就是不符合结合律的例子了</td></tr></tbody></table><p>注意：<strong>将大的浮点数转换成整数是一个常见的错误</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> cs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp ch02 (part 3): Integer Arithmetic</title>
      <link href="/csapp-ch02-part-3-integer-arithmetic/"/>
      <url>/csapp-ch02-part-3-integer-arithmetic/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是csapp第二章第三节的阅读笔记。</p></blockquote><p>整数的运算包括加减乘除，对于每一种运算都涉及到有符号整数和无符号整数。</p><p>这里涉及到的符号：</p><table><thead><tr><th>Symbol</th><th>Type</th><th>Meaning</th></tr></thead><tbody><tr><td>$+_w^t$</td><td>Operation</td><td>补码加法</td></tr><tr><td>$+_w^u$</td><td>Operation</td><td>无符号数加法</td></tr><tr><td>$\ast _w^t$</td><td>Operation</td><td>补码乘法</td></tr><tr><td>$\ast _w^u$</td><td>Operation</td><td>无符号数乘法</td></tr><tr><td>$-_w^t$</td><td>Operation</td><td>补码减法</td></tr><tr><td>$-_w^u$</td><td>Operation</td><td>无符号数减法</td></tr></tbody></table><h2 id="1-无符号整数加法"><a href="#1-无符号整数加法" class="headerlink" title="1. 无符号整数加法"></a>1. 无符号整数加法</h2><p>有两个w位的无符号整数x和y：$0 \leq x,y \leq 2^w$，那么两个数和的范围就是$0 \leq x+y \leq 2^{w+1}-2$。这个数是不能用w位二进制数表示的，需要w+1位才能表示。</p><p>因此，如果仍然使用w位来存储$x+y$的结果的话，就有可能对真正的值进行截断。我们使用符号$+_w^u$来表示截断后的结果，那么有：<br>$$<br>x+_w^uy=\begin{cases}<br>x+y,&amp; \text{$x+y&lt;2^w$ 正常}\<br>x+y-2^w,&amp; \text{$2^w \leq x+y \leq 2^{w+1}$ 溢出}<br>\end{cases}<br>$$<br>其实，也就是对$2^w$取模：<br>$$<br>x+_w^uy=(x+y)\ mod\ 2^w<br>$$<br>既然有可能溢出，那么我们有办法检测溢出吗？</p><p>令$s=x+_w^uy$，如果$s&lt;x$，那么就溢出了。</p><p>用代码表示：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">uadd_ok</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> x<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> sum <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>    <span class="token keyword">return</span> sum <span class="token operator">>=</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>没有溢出就返回1，有溢出就返回0。</p><p>上面的无符号加法就是一个模数加法，在模数加法中，有一个阿贝尔群（abelian group）的概念。这里有一个0元素，然后对于群中的元素$x$来说，都有一个对应的加法逆元$-_w^ux$，使得：$-_w^ux+_w^ux=0$。这样就有了一个无符号数取反的操作。</p><p>对于一个$x$：$0 \leq x &lt;2^w$，取反操作如下：<br>$$<br>-_w^ux=\begin{cases}<br>x,&amp;\text{$x=0$}\<br>2^w-x,&amp;\text{$x&gt;0$}<br>\end{cases}<br>$$<br>可以知道，无符号数中，只有0的加法逆元是它本身。</p><h2 id="2-补码加法"><a href="#2-补码加法" class="headerlink" title="2. 补码加法"></a>2. 补码加法</h2><p>接下来看看补码加法。对于两个补码表示的有符号整数$x$和$y$：$-2^{w-1}\leq x,y\leq 2^{w-1}-1$，两个数的和$x+y$的取值范围就是$-2^w\leq x+y \leq 2^w-2$，同样不能使用w位来表示，需要w+1位。这样，当我们使用w位来表示的时候，就需要对其进行截断。令符号$x+_w^ty$表示截断后的结果，那么：<br>$$<br>x+_w^ty=\begin{cases}<br>x+y-2^w,&amp;\text{$2^{w-1}\leq x+y$ 正溢出}\<br>x+y,&amp;\text{$-2^{w-1}\leq x+y &lt;2^{w-1}$ 正常}\<br>x+y+2^w,&amp;\text{$x+y&lt;-2^{w-1}$ 负溢出}<br>\end{cases}<br>$$<br>其实有符号整数加法和无符号整数加法的二进制形式是一样的，而计算机在做计算的时候也是不进行区分的。</p><p>所以有：<br>$$<br>x+<em>w^ty=U2T_w[T2U_w(x)+_w^uT2U_w(y)]=U2T_w[(x</em>{w-1}2^w+x+y_{w-1}2^w+y)\ mod\ 2^w]=U2T_w[(x+y)\ mod\ 2^w]<br>$$<br>像无符号加法一样，补码加法也有溢出，而且还有两种溢出：正溢出和负溢出。那么如何检测溢出呢？</p><p>令$s=x+_w^ty$：</p><p>如果$x&gt;0$且$y&gt;0$，但是$s\leq 0$，那么就是正溢出；</p><p>如果$x&lt;0$且$y&lt;0$，但是$s\geq 0$，那么就是负溢出。</p><p>使用代码来表示：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tadd_ok</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>    <span class="token keyword">int</span> neg_over <span class="token operator">=</span> x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> sum <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pos_over <span class="token operator">=</span> x <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> sum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">!</span>neg_over <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>pos_over<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果没有溢出就返回1，发生溢出就返回0。</p><h2 id="3-补码取反"><a href="#3-补码取反" class="headerlink" title="3. 补码取反"></a>3. 补码取反</h2><p>和无符号加法一样，补码加法也有一个加法逆元的概念。对于一个$x$：$-2^{w-1}\leq x&lt;2^{w-1}$，它的加法逆元就是：<br>$$<br>-_w^tx=\begin{cases}<br>-2^{w-1},&amp;x=-2^{w-1}\<br>-x,&amp;x&gt;-2^{w-1}<br>\end{cases}<br>$$<br>所以$TMin_w$的加法逆元就是它本身。因此在补码加法中，加法逆元是其本身的有两个元素：0和$TMin_w$。</p><p>对于一个有符号数取反，在二进制表示的层面上有一个简便的方法（以4位为例）：</p><table><thead><tr><th>$\vec{x}$</th><th>$\sim\vec{x}$</th><th>$incr(\sim\vec{x})$</th></tr></thead><tbody><tr><td>[0101]    5</td><td>[1010]    -6</td><td>[1011]    -5</td></tr><tr><td>[0111]    7</td><td>[1000]    -8</td><td>[1001]    -7</td></tr><tr><td>[1100]    -4</td><td>[0011]    3</td><td>[0100]    4</td></tr><tr><td>[0000]    0</td><td>[1111]    -1</td><td>[0000]    0</td></tr><tr><td>[1000]    -8</td><td>[0111]    7</td><td>[1000]    8</td></tr></tbody></table><p>简单来说就是，“取反加一”。</p><h2 id="4-无符号整数乘法"><a href="#4-无符号整数乘法" class="headerlink" title="4. 无符号整数乘法"></a>4. 无符号整数乘法</h2><p>两个无符号整数$x$和$y$：$0\leq x,y\leq 2^w-1$，它们的乘积$x\ast y$的取值范围是$0\leq x\ast y\leq (2^w-1)^2=2^{2w}-2^{w+1}+1$，需要使用2w位才能保存，如果使用w位保存的话就会截断。令$x\ast _w^uy$是截断后的结果，那么：<br>$$<br>x\ast _w^uy=(x\ast y)\ mod\ 2^w<br>$$</p><h2 id="5-补码乘法"><a href="#5-补码乘法" class="headerlink" title="5. 补码乘法"></a>5. 补码乘法</h2><p>两个有符号整数$x$和$y$：$-2^{w-1}\leq x,y\leq 2^{w-1}-1$，它们的乘积$x\ast y$的取值范围是$-2^{w-1}\cdot(2^{w-1}-1)=-2^{2w-2}+2^{w-1}\leq x\ast y\leq (-2^{w-1})^2=2^{2w-2}$。</p><p>同样如果使用w位表示的也需要截断。令$x\ast _w^ty$表示截断后的结果，那么：<br>$$<br>x\ast _w^ty=U2T_w((x\cdot y)\ mod\ 2^w)<br>$$<br>和加法一样，补码乘法与无符号乘法的二进制表示是一样的。</p><p>可以使用下面的代码来检测是否有溢出：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tmult_ok</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> x\ast y<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">!</span>x <span class="token operator">||</span> p<span class="token operator">/</span>x <span class="token operator">==</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>没有溢出的话返回1，否则返回0。</p><p>如果不用除法的话可以这样：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tmulk_ok</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    int64_t pll <span class="token operator">=</span> <span class="token punctuation">(</span>int64_t<span class="token punctuation">)</span> x\ast y<span class="token punctuation">;</span>    <span class="token keyword">return</span> pll <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> pll<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>首先使用64位的数保存两个32位数的乘积，这是能够完整保留结果的，然后将其截断到32位，看是否一致。如果一致说明没有溢出，否则就有溢出。</p><h2 id="6-乘以常数"><a href="#6-乘以常数" class="headerlink" title="6. 乘以常数"></a>6. 乘以常数</h2><p>计算机的乘法操作比较耗时，因此编译器会将乘法优化成移位操作和加减法。</p><p>不管是有符号还是无符号，左移一位，就相当于乘以2，那么左移k位，相当于乘以$2^k$。</p><p>所以无符号：$x&lt;&lt;k=x\ast _w^u2^k$；</p><p>有符号：$x&lt;&lt;k=x\ast _w^t2^k$。</p><p>同时，任何一个整数都可以写成多个2的幂次数的和的形式。比如$14=2^3+2^2+2^1$，所以乘以一个常数都可以转换成多个左移和加法操作：<br>$$<br>x\ast 14=(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)<br>$$<br>一般来说，对于常量$K$，乘法$x\ast K$都可以表示成左移操作和加减法操作。对于$K$，可以表示成下面的二进制形式：<br>$$<br>[(0…0)(1…1)(0…0)\cdots(1…1)]<br>$$<br>比如14可以表示成$[(0…0)(111)(0)]$，令连续1的下标是$n$和$m$，且$n\leq m$，对于14来说$n=3,m=1$。</p><p>都可以表示成下面两种形式：</p><p>A：$(x&lt;&lt;n)+(x&lt;&lt;(n-1))+\cdots+(x&lt;&lt;m)$</p><p>B：$(x&lt;&lt;(n+1)-(x&lt;&lt;m))$</p><p>比如：<br>$$<br>x\ast 6=(x&lt;&lt;2)+(x&lt;&lt;1)\<br>x\ast 31=(x&lt;&lt;5)-x\<br>x\ast (-6)=(x&lt;&lt;1)-(x&lt;&lt;3)\<br>x\ast 55=(x&lt;&lt;6)-(x&lt;&lt;3)-x<br>$$</p><h2 id="7-除以2的幂"><a href="#7-除以2的幂" class="headerlink" title="7. 除以2的幂"></a>7. 除以2的幂</h2><p>首先需要确定，整数除法是向0取整的。比如$5/2=2.5$，然后向0取整$\lfloor 2.5\rfloor=2$；比如$-12340/256=-48.203125$，然后向0取整$\lceil -48.203125\rceil=-48$。</p><p>左移1位是乘以2，右移应该就是除吧？但是右移操作有两种：逻辑右移和算术右移。</p><p>那么对于无符号数除以一个2的幂次数，就可以直接逻辑右移了。令$x’=x&gt;&gt;k$，那么就有：<br>$$<br>x’=\lfloor x/2^k\rfloor<br>$$<br>对于大于0的有符号数来说，也可以使用上面的方法进行计算；但是对于有符号数如果也使用向下取整的话，就会有问题了。从上面$-12340/256$的结果就可以看出来，如果向下取整的话结果是-49而不是-48。所以我们需要使用另外的方法来计算有符号数除以2的幂次数。</p><p>为了能够对于小于0的数的计算结果向上取整，需要加一个偏差值。根据$\lceil x/y\rceil=\lfloor (x+y-1)/y\rfloor$，可以这样：<br>$$<br>（x&lt;0 ? x+(1&lt;&lt;k)-1:x)&gt;&gt;k<br>$$<br>来计算有符号整数除以2的幂次数的结果。</p><p>一个有意思的题目：写出<code>div16()</code>函数来计算<code>x/16</code>的值，其中<code>x</code>的类型是<code>int</code>，但是不使用比较运算符、除法运算符、取模运算符、条件判断、比较或循环：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">div16</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> bias <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xF</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> bias<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-关于整数运算的思考"><a href="#8-关于整数运算的思考" class="headerlink" title="8. 关于整数运算的思考"></a>8. 关于整数运算的思考</h2><ul><li>计算机执行整数运算其实是一种模运算形式；</li><li>有限字长限制了取值范围，导致计算结果可能溢出；</li><li>无论是补码还是无符号运算，底层的二进制行为是一致或非常类似的；</li><li><code>unsigned</code>类型会导致很多察觉不到的问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> cs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Use pt-osc to ALTER MySQL table</title>
      <link href="/use-pt-osc-to-alter-mysql-table/"/>
      <url>/use-pt-osc-to-alter-mysql-table/</url>
      
        <content type="html"><![CDATA[<h2 id="1-怎么了（问题）"><a href="#1-怎么了（问题）" class="headerlink" title="1. 怎么了（问题）"></a>1. 怎么了（问题）</h2><p>之前有一个张MySQL表用一个使用了<code>utf8</code>编码的<code>text</code>类型的<code>content</code>字段来保存文章。最近发现当文章中有emoji表情时，保存会失败：</p><pre class="line-numbers language-shell"><code class="language-shell">Incorrect string value: '\\xF0\\x9F\\x91\\x87\\xF0\\x9F...' for column 'content' at row 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>原来是<code>utf8</code>编码不支持emoji，需要使用<code>utf8mb4</code>编码。</p><h2 id="2-怎么办（方法）"><a href="#2-怎么办（方法）" class="headerlink" title="2. 怎么办（方法）"></a>2. 怎么办（方法）</h2><p>找到问题之后，那么解决办法就有了：</p><ol><li>修改<code>content</code>字段的编码为<code>utf8mb4</code>；</li><li>程序连接数据库的字符集也改成<code>utf8mb4</code>。</li></ol><p>当然可以直接使用下面的语句进行修改：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> tbl_xxx <span class="token keyword">modify</span> content <span class="token keyword">text</span> <span class="token keyword">character set</span> utf8mb4<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是对于大表，这个语句会锁表很长时间。对于线上服务来说，不能接受长时间的锁表。</p><h2 id="3-Then-What？"><a href="#3-Then-What？" class="headerlink" title="3. Then What？"></a>3. Then What？</h2><p>然后发现有一个工具pt-osc可以直接进行修改而减少锁表时间。pt-osc是percona的一个工具。</p><p>下载：</p><pre class="line-numbers language-shell"><code class="language-shell">wget percona.com/get/percona-toolkit.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接使用<code>wget</code>下载就可以了。然后解压进入<code>bin</code>目录，就会发现一系列工具：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/percona.jpg"><p>我们需要使用的，就是pt-online-schema-change。</p><p>行吧直接上：</p><pre class="line-numbers language-sql"><code class="language-sql">pt<span class="token operator">-</span>online<span class="token operator">-</span><span class="token keyword">schema</span><span class="token operator">-</span>change \\<span class="token operator">-</span>hxxx \\<span class="token operator">-</span>Pxxx \\<span class="token operator">-</span>uxxx \\<span class="token operator">-</span>pxxx \\<span class="token comment" spellcheck="true">--alter "modify title char(128) character set utf8mb4,modify content text character set utf8mb4" \\</span>D<span class="token operator">=</span>xxx<span class="token punctuation">,</span>t<span class="token operator">=</span>xxx \\<span class="token comment" spellcheck="true">--execute \\</span><span class="token comment" spellcheck="true">--print \\</span><span class="token comment" spellcheck="true">--statistics \\</span><span class="token comment" spellcheck="true">--no-check-alter</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>-h -P -u -p</code>就是连接数据库的IP、端口、账号和密码。</p><p>接下来在<code>--alter</code>中就是修改表结构的语句了，主体还是和MySQL的<code>ALTER</code>语句类似的，只不过这里不需要添加<code>ALTER TABLE xxx</code>了。</p><p>对于多个<code>ALTER</code>语句，中间可以使用<code>,</code>分割。</p><p><code>D=xxx,t=xxx</code>表示对应的数据库和表名。</p><p><code>--execute</code>指定程序进行修改，为了安全，默认是不进行修改的，需要添加<code>--execute</code>才能真正执行修改操作。</p><p>尝试了一下，果然很方便。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp ch02 (part 2): Integer Representations</title>
      <link href="/csapp-ch02-part-2-integer-representations/"/>
      <url>/csapp-ch02-part-2-integer-representations/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是csapp第二章第二节的阅读笔记。</p></blockquote><p>既然知道了信息是如何存储的，那么接下来看看，整数是如何存储的。整数包括两种：有符号整数和无符号整数，分别对应可为负和不可为负。</p><p>这里会涉及到如下的一些符号（其中下标的w表示数据的位数）：</p><table><thead><tr><th>Symbol</th><th>Type</th><th>Meaning</th></tr></thead><tbody><tr><td>$B2T_w$</td><td>函数</td><td>二进制到补码</td></tr><tr><td>$B2U_w$</td><td>函数</td><td>二进制到无符号</td></tr><tr><td>$U2B_w$</td><td>函数</td><td>无符号到二进制</td></tr><tr><td>$U2T_w$</td><td>函数</td><td>无符号到补码</td></tr><tr><td>$T2B_w$</td><td>函数</td><td>补码到二进制</td></tr><tr><td>$T2U_w$</td><td>函数</td><td>补码到无符号</td></tr><tr><td>$TMin_w$</td><td>常量</td><td>补码最小值</td></tr><tr><td>$TMax_w$</td><td>常量</td><td>补码最大值</td></tr><tr><td>$UMax_w$</td><td>常量</td><td>无符号最大值</td></tr></tbody></table><h2 id="1-整型数据类型"><a href="#1-整型数据类型" class="headerlink" title="1. 整型数据类型"></a>1. 整型数据类型</h2><p>首先来看看C语言中几种整型在不同位数的机器下所能表示的范围。</p><table><thead><tr><th>C data type</th><th>Min in 32</th><th>Max in 32</th><th>Min in 64</th><th>Max in 64</th></tr></thead><tbody><tr><td><code>[signed] char</code></td><td>$-2^7$</td><td>$2^7-1$</td><td>$-2^7$</td><td>$2^7-1$</td></tr><tr><td><code>unsigned char</code></td><td>0</td><td>$2^8-1$</td><td>0</td><td>$2^8-1$</td></tr><tr><td><code>short</code></td><td>$-2^{15}$</td><td>$2^{15}-1$</td><td>$-2^{15}$</td><td>$2^{15}-1$</td></tr><tr><td><code>unsigned short</code></td><td>0</td><td>$2^{16}-1$</td><td>0</td><td>$2^{16}-1$</td></tr><tr><td><code>int</code></td><td>$-2^{31}$</td><td>$2^{31}-1$</td><td>$2^{31}-1$</td><td>$2^{31}-1$</td></tr><tr><td><code>unsigned</code></td><td>0</td><td>$2^{32}-1$</td><td>0</td><td>$2^{32}-1$</td></tr><tr><td><code>long</code></td><td>$-2^{31}$</td><td>$2^{31}-1$</td><td>$-2^{64}$</td><td>$2^{64}-1$</td></tr><tr><td><code>unsigned long</code></td><td>0</td><td>$2^{32}-1$</td><td>0</td><td>$2^{64}-1$</td></tr><tr><td><code>int32_t</code></td><td>$-2^{31}$</td><td>$2^{31}-1$</td><td>$-2^{31}$</td><td>$2^{31}-1$</td></tr><tr><td><code>uint32_t</code></td><td>0</td><td>$2^{32}-1$</td><td>0</td><td>$2^{32}-1$</td></tr><tr><td><code>int64_t</code></td><td>$-2^{63}$</td><td>$2^{63}-1$</td><td>$-2^{63}$</td><td>$2^{63}-1$</td></tr><tr><td><code>uint64_t</code></td><td>0</td><td>$2^{64}-1$</td><td>0</td><td>$2^{64}-1$</td></tr></tbody></table><h2 id="2-无符号数的编码"><a href="#2-无符号数的编码" class="headerlink" title="2. 无符号数的编码"></a>2. 无符号数的编码</h2><p>既然有无符号和有符号两种，那么每种的编码应该是不一样的。首先看看无符号的编码，毕竟这个比较简单。</p><p>我们知道，信息的存储就是一个比特序列。如果数据有w位，那么这个数据就可以表示成一个w位的向量$\vec{x}=[x_{w-1},w_{w-2},…,x_0]$，其中每一个$x_i$的取值是0或1。</p><p>那么将这个二进制形式的数据转换成无符号类型的十进制数可以：<br>$$<br>B2U_w(\vec{x})=\sum_{i=0}^{w-1}x_i2^i<br>$$<br>接下来看看w位无符号整数的范围。最小值当然就是0，最大值$UMax_w$对应的二进制数据都是1，那么：<br>$$<br>UMax_w=\sum_{i=0}^{w-1}1·2^i=2^w-1<br>$$<br>当w=4的时候，$UMax_4=2^4-1=15$。</p><p>需要注意的是，<strong>函数$B2U_w$是一个双射（bijection）函数。</strong></p><h2 id="3-补码编码"><a href="#3-补码编码" class="headerlink" title="3. 补码编码"></a>3. 补码编码</h2><p>无符号编码不可以表示负数，因为最小值就是0。为了可以表示负数，需要使用补码编码（Two’s-Complement Encodings）。</p><p>我们使用符号$B2T_w$来表示将一个二进制编码转换成对应的十进制补码数值。对于一个二进制向量$\vec{x}=[x_{w-1},x_{w-2},…,x_0]$来说，可以通过下面的方式进行转换：<br>$$<br>B2T_w(\vec{x})=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i<br>$$<br>补码编码将最高位当做标志位，当最高位$x_{w-1}=1$时表示负数；当$x_{w-1}=0$时表示正数。为了统一，这个最高位也加上一个权值$-2^{w-1}$，就可以计算整个向量对应的十进制值了。</p><p>接下来看看补码可以表示的范围。当$\vec{x}=[1,0,…,0]$时，表示最小值，即$TMin_w=-2^{w-1}$；当$\vec{x}=[0,1,…,1]$时表示最大值，即$TMax_w=2^{w-1}-1$。</p><p>同样，<strong>函数$B2T_w$也是一个双射函数</strong>。</p><p>可知：</p><ul><li>$|TMin_w|=|TMax_w|+1$</li><li>$UMax_w=2TMax_w+1$</li></ul><h2 id="4-有符号与无符号数之间的转换"><a href="#4-有符号与无符号数之间的转换" class="headerlink" title="4. 有符号与无符号数之间的转换"></a>4. 有符号与无符号数之间的转换</h2><p>既然信息的底层存储是一样的，那么不同的解释方法会得到不同的结果。接下来就看看，对于同一个二进制编码来说，使用不同的解释方法（无符号编码和补码编码）得到的结果之间的关系。</p><p>无符号编码的取值范围是$[0,UMax_w]$，补码编码的取值范围是$[TMin_w,TMax_w]$。</p><p>先看看将补码编码转换成无符号编码。令$T2U_w(x)=B2U_w(T2B_w(x))$，其中$TMin_w\leq x \leq TMax_w$，有：<br>$$<br>T2U_w(x)=<br>\begin{cases}<br>x+2^w, &amp; \text{x&lt;0}\<br>x, &amp; \text{x $\geq$ 0}<br>\end{cases}<br>$$<br>比如，$T2U_{16}(-12345)=-12345+2^{16}=53191$，同时可得：$T2U_w(-1)=-1+2^w=UMax_w$。</p><p>对于一个$\vec{x}$，我们知道$B2U_w(\vec{x})$和$B2T_w(\vec{x})$，那么：<br>$$<br>B2U_w(\vec{x})-B2T_w(\vec{x})=(\sum_{i=0}^{w-1}x_i2^i)-(-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i)=x_{w-1}2^w<br>$$<br>也就是说$B2U_w(\vec{x})=B2T_w(\vec{x})+x_{w-1}2^w$，所以：<br>$$<br>B2U_w(T2B_w(x))=T2U_w(x)=x+x_{w-1}2^w<br>$$<br>这样就可以通过这个公式将一个有符号数转换成无符号数了。</p><p>接下来看看从无符号数到有符号数的转换，这个函数记作$U2T_w(u)$。</p><p>那么对于$0 \leq u \leq UMax_w$，有：<br>$$<br>U2T_w(u)=\left{<br>\begin{aligned}<br>u&amp;,&amp;u \leq TMax_w\<br>u-2^w&amp;,&amp;u &gt; TMax_w<br>\end{aligned}<br>\right.<br>$$<br>令$\vec{u}=U2B_w(u)$，那么这个编码也就是$U2T_w(u)$的编码，同时有：<br>$$<br>B2T_w(u)=B2U_w(u)-u_{w-1}2^w<br>$$<br>所以：<br>$$<br>U2T_w(u)=B2T(U2B_w(u))=B2U_w(U2B_w(u))-U_{w-1}2^w=u-u_{w-1}2^w<br>$$<br>比如，$T2U_{16}(-12345)=65536-12345=53191$。</p><h2 id="5-C语言中的有符号数和无符号数"><a href="#5-C语言中的有符号数和无符号数" class="headerlink" title="5. C语言中的有符号数和无符号数"></a>5. C语言中的有符号数和无符号数</h2><p>C语言中的数字默认是有符号的，可以通过在数字的末尾加上<code>u</code>或<code>U</code>来指明是无符号的，比如<code>12345U</code>。</p><p>C语言中会发生无符号和有符号数之间的转换。要么是显式的：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> tx<span class="token punctuation">,</span> ty<span class="token punctuation">;</span><span class="token keyword">unsigned</span> ux<span class="token punctuation">,</span> uy<span class="token punctuation">;</span>tx <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> ux<span class="token punctuation">;</span>uy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span> ty<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要么是隐式的：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> tx<span class="token punctuation">,</span> ty<span class="token punctuation">;</span><span class="token keyword">unsigned</span> ux<span class="token punctuation">,</span> uy<span class="token punctuation">;</span>tx <span class="token operator">=</span> ux<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Cast to signed</span>uy <span class="token operator">=</span> ty<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Cast to unsigned</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，<strong>当有符号和无符号数放在一起运算的时候，C会隐式地将有符号数转换成无符号数。</strong></p><p>比如判断<code>-1&lt;0U</code>，<code>-1</code>是有符号数而<code>0U</code>是无符号数，那么<code>-1</code>就会转换成无符号数，$T2U_w(-1)=UMax_w$，导致判断为假。</p><h2 id="6-扩展一个数字的位表示"><a href="#6-扩展一个数字的位表示" class="headerlink" title="6. 扩展一个数字的位表示"></a>6. 扩展一个数字的位表示</h2><p>将一个数扩展成更大的位数表示，同时保留原来的值。对于有符号和无符号，扩展方法不同。</p><p>对于无符号数，扩展的最高位直接用0补齐即可。</p><p>对于有符号数，需要看原来表示的最高位，用那个最高位来补齐。</p><p>需要注意的一点是：当涉及到扩展位数和有符号与无符号之间的转换时，<strong>先扩展位数，然后转换类型</strong>：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">short</span> sx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">12345</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> uy <span class="token operator">=</span> sx<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"uy = %u:\t"</span><span class="token punctuation">,</span> uy<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">show_bytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span>byte_pointer<span class="token punctuation">)</span> <span class="token operator">&amp;</span>uy<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会得到不一样的结果，<code>uy</code>的值变成了4294954951。</p><h2 id="7-减少一个数字的位表示"><a href="#7-减少一个数字的位表示" class="headerlink" title="7. 减少一个数字的位表示"></a>7. 减少一个数字的位表示</h2><p>反过来，减少一个数字的位表示，就会改变所表示的数值了。</p><p>对于无符号数，截断后的值$x’=x,mod,2^k$，其中$k$就是截断后的位数。因为：<br>$$<br>B2U_w([x_{w-1},x_{w-2},…,x_0]),mod,2^k=[\sum_{i=0}^{w-1}x_i2^i],mod,2^k=[\sum_{i=0}^{k-1}x_i2^i],mod,2^k=\sum_{i=0}^{k-1}x_i2^i=B2U_k([x_{k-1},x_{k-2},…,x_0])<br>$$<br>对于有符号数，截断后的值$x’=U2T_k(x,mod,2^k)$。截断后的编码不管是有符号还是无符号都是一样的，所以对于有符号数，截断后的编码还是$[x_{k-1},x_{k-2},…,x_0]$，那么只需要把这个编码转换成对应的有符号数就可以了：<br>$$<br>x’=U2T_k(B2U_k([x_{k-1},x_{k-2},…,x_0]))=U2T_k(x,mod,2^k)<br>$$</p><h2 id="8-关于有符号和无符号数的建议"><a href="#8-关于有符号和无符号数的建议" class="headerlink" title="8. 关于有符号和无符号数的建议"></a>8. 关于有符号和无符号数的建议</h2><p>由于C语言中会有有符号与无符号之间的隐式转换，所以一些情况下会有奇怪的bug出现。比如：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">float</span> <span class="token function">sum_elements</span><span class="token punctuation">(</span><span class="token keyword">float</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">float</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> length<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        result <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当<code>length=0</code>的时候会出错。这是因为<code>length</code>是无符号的，计算<code>length-1</code>的时候会产生一个巨大的无符号整数，导致判断为真，然后访问非法的地址。</p><p>只需要将循环里的判断条件改成<code>i &lt; length</code>即可。</p><p>使用无符号数就可能会导致上面类似的问题，那么一个建议就是不使用无符号数。</p><p>不过无符号数在一些情况下也是有用的，比如仅仅看作位的集合而不考虑数字的含义的时候：</p><ul><li>存储的每一位都是标记（flag）；</li><li>内存地址也是无符号的——系统程序员；</li><li>数学中的多精度计算，数字是由字的数组表示，也可以使用无符号数。</li></ul><h2 id="9-重要的事儿"><a href="#9-重要的事儿" class="headerlink" title="9. 重要的事儿"></a>9. 重要的事儿</h2><ul><li>二进制转无符号数：$B2U_w(\vec{x})=\sum_{i=0}^{w-1}x_i2^i$</li><li>无符号数的最大值：$UMax_w=2^w-1$</li><li>二进制转有符号数：$B2T_w(\vec{x})=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$</li><li>有符号最大值和最小值的关系：$|TMin_w|=|TMax_w|+1$</li><li>无符号数最大值和有符号数最大值的关系：$UMax_w=2TMax_w+1$</li><li>有符号数转无符号数：$T2U_w(x)=x+x_{w-1}2^w$</li><li>无符号数转有符号数：$U2T_w(u)=u-u_{w-1}2^w$</li><li>同一二进制编码下有符号数和无符号数的关系：$B2U_w(u)-B2T_w(u)=u_{w-1}2^w$</li><li>截断无符号数：$x’=x,mod,2^k$</li><li>截断有符号数：$x’=U2T_k(x,mod,2^k)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> cs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp ch02 (part 1): Information Storage</title>
      <link href="/csapp-ch02-part-1-information-storage/"/>
      <url>/csapp-ch02-part-1-information-storage/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是csapp第二章第一节的阅读笔记。</p></blockquote><p>机器级的程序把内存当做一个大数组，数组里的元素就是字节。</p><p>接下来就应该看看，编译器和运行时系统是如何把由一块块字节组成的信息翻译成它本来的养子。</p><h2 id="1-十六进制表示法"><a href="#1-十六进制表示法" class="headerlink" title="1 十六进制表示法"></a>1 十六进制表示法</h2><p>在C语言中，我们可以通过<code>0x</code>或<code>0X</code>前缀来表明一个常数是通过十六进制表示的。</p><p>二进制和十六进制的转换：很简单但是很重要。</p><p>如果一个数$x$是2的幂次数，即$x=2^n$，这里$n$是一个非负数。把这样的十进制数转换成十六进制数有一个简单的方法。先分解$n$，令$n=i+4j$，其中$0≤i≤3$，通过$x$就可以确定对应十六进制数的最高位了：1($x=0$)，2($x=1$)，4($x=2$)，8($x=8$)。然后确定最高位后面有几个0 ：这个和$j$有关，$j$是几，后面就有几个0。</p><p>比如$x=2048=2^{11}$，那么$n=11=3+4·2$，所以$i=3, j=2$，所以<code>2048=0x800</code>。</p><p>同样，对于十进制和十六进制的转换也很简单很重要。</p><h2 id="2-字数据大小"><a href="#2-字数据大小" class="headerlink" title="2 字数据大小"></a>2 字数据大小</h2><p>计算机系统内部通过总线进行数据传输，总线的大小通过字word来指示，不同的计算机系统字的大小不同。这个字的大小也指明了指针数据的大小。最重要的，字的大小也决定了虚拟内存的空间大小。</p><p>比如，在一个计算机系统中，字的大小是$w$，那么对应的虚拟内存空间大小就是从0到$2^w-1$，一共$2^w$字节。</p><p>对于32位计算机，虚拟内存大小是$2^{32}$，大概是$4×10^9$字节，也就是4GB；对于64位的计算机，可以表示$1.84×10^{19}$字节。</p><p>64位机器上编译的程序可以在32位机器上运行，但是反过来不可以。可以通过下面的参数来指定编译：</p><pre class="line-numbers language-shell"><code class="language-shell">gcc -m32 prog.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样编译的程序可以运行在32位和64位的机器上。</p><pre class="line-numbers language-shell"><code class="language-shell">gcc -m64 prog.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而这样编译的程序只能运行在64位的机器上。</p><p>C语言支持多种数据类型，下表列出了不同数据类型在不同的位的机器上所需的大小：</p><table><thead><tr><th>Signed</th><th>Unsigned</th><th>Bytes(32-bit)</th><th>Bytes(64-bit)</th></tr></thead><tbody><tr><td><code>[signed] char</code></td><td><code>unsigned char</code></td><td>1</td><td>1</td></tr><tr><td><code>short</code></td><td><code>unsigned short</code></td><td>2</td><td>2</td></tr><tr><td><code>int</code></td><td><code>unsigned</code></td><td>4</td><td>4</td></tr><tr><td><code>long</code></td><td><code>unsigned long</code></td><td>4</td><td>8</td></tr><tr><td><code>int32_t</code></td><td><code>uint32_t</code></td><td>4</td><td>4</td></tr><tr><td><code>int64_t</code></td><td><code>uint64_t</code></td><td>8</td><td>8</td></tr><tr><td><code>char *</code></td><td></td><td>4</td><td>8</td></tr><tr><td><code>float</code></td><td></td><td></td><td></td></tr></tbody></table><p><strong>所以，最好使用固定位数的类型，比如<code>int32_t</code>等。</strong></p><h2 id="3-寻址和字节序"><a href="#3-寻址和字节序" class="headerlink" title="3 寻址和字节序"></a>3 寻址和字节序</h2><p>如果一个程序对象需要多个字节来表示，那么就需要解决两个问题：</p><ol><li>如何表示这个对象的地址；</li><li>多个字节如何在内存中进行排序。</li></ol><p>在内存中，一个程序对象的所有字节都是连续存储的，通常我们使用那个连续内存中最小的那个作为整个对象的地址。比如一个<code>int</code>类型的变量<code>x</code>，如果它的地址是<code>0x100</code>，那么存储这个变量的所有空间就是<code>0x100</code>，<code>0x101</code>，<code>0x102</code>和<code>0x103</code>。</p><p>对象的地址解决了，那么如何排列所有的字节呢？这就涉及到字节序的问题了。</p><p>不同的计算机系统使用不同的字节序，主要有大端字节序（big endian）和小端字节序（little endian），如图：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/endian.png"><p>两者的区别就是：一个数的最低位是在所占空间的最小地址（小端）还是在所占空间的最大地址（大端）。</p><p>比如一个数<code>0x1234567</code>，我们的书写习惯、打印还有代码中，从左到右都是最高位（01）到最低位（67）排列，但是在内存中不一样。如果这个变量的地址是<code>0x100</code>，对于大端字节序，最低位67占据了所占空间的最大地址<code>0x103</code>；而对于小端字节序，最低位67占据了最低地址<code>0x100</code>。</p><p>如果内存空间是从左到右变大，那么大端字节序的排列适合我们的书写习惯一样的。</p><p>一般来说，程序员是不用关注这个字节序的，计算机会自动处理好这个问题。但在一些涉及到底层的编程中，需要注意字节序：</p><ol><li>网络编程。网络编程中涉及到不同计算机系统中的数据传输，这样就涉及到了字节序的问题，需要对不同字节序进行转换才能正确处理数据；</li><li>涉及到汇编代码的时候。这里对于数字常量需要注意字节序；</li><li>当程序使用类型转换来规避正常的类型系统的时候。</li></ol><p>下面的代码可以演示所处系统的字节序：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>byte_pointer<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">show_bytes</span><span class="token punctuation">(</span>byte_pointer start<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span> <span class="token punctuation">{</span>    size_t i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %.2x"</span><span class="token punctuation">,</span> start<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">show_int</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">show_bytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span>byte_pointer<span class="token punctuation">)</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">show_float</span><span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">show_bytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span>byte_pointer<span class="token punctuation">)</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">show_pointer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">show_bytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span>byte_pointer<span class="token punctuation">)</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">test_show_bytes</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ival <span class="token operator">=</span> val<span class="token punctuation">;</span>    <span class="token keyword">float</span> fval <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>ival<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>pval <span class="token operator">=</span> <span class="token operator">&amp;</span>ival<span class="token punctuation">;</span>    <span class="token function">show_int</span><span class="token punctuation">(</span>ival<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">show_float</span><span class="token punctuation">(</span>fval<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">show_pointer</span><span class="token punctuation">(</span>pval<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">test_show_bytes</span><span class="token punctuation">(</span><span class="token number">123456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell"> 39 30 00 00 00 e4 40 46 6c cd 01 9e fe 7f 00 00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>123456</code>用十六进制表示就是<code>0x3093</code>，所以我这个机器是小端字节序。</p><h2 id="4-字符串的表示"><a href="#4-字符串的表示" class="headerlink" title="4 字符串的表示"></a>4 字符串的表示</h2><p>C语言中的字符串就是一个字节数组然后使用<code>null</code>结尾。所以对于一个字符串<code>&quot;12345&quot;</code>，如果调用函数<code>show_bytes(&quot;12345&quot;, 6)</code>的话，那么结果将是<code>31 32 33 34 35 00</code>。</p><p>但是对于<code>strlen()</code>函数来说，是不算最后的<code>null</code>的。所以<code>strlen(&quot;12345&quot;)</code>的结果是5。</p><p>由此可以得出一个结论：<strong>文本文件比二进制文件更加平台独立。</strong></p><h2 id="5-代码的表示"><a href="#5-代码的表示" class="headerlink" title="5 代码的表示"></a>5 代码的表示</h2><p>当我们写完一段代码，并将其编译成可执行程序后，不同的计算机系统所编译出来的内容是不同的，即使我们的程序是一样的。</p><p>但所编译出来的内容，都是一个字节序列。</p><p><strong>所以从计算机的角度来说，所有的程序，都只不过是一段字节序列，或长或短而已。</strong></p><h2 id="6-布尔代数简介"><a href="#6-布尔代数简介" class="headerlink" title="6 布尔代数简介"></a>6 布尔代数简介</h2><p>计算机逻辑计算的即使就是布尔代数。这部分比较简单，但也很重要。</p><p>基本的布尔运算有：与（<code>&amp;</code>）、或（<code>|</code>）、非（<code>~</code>）和异或（<code>^</code>）。</p><p>其实异或也可以使用其余的运算来表示：<code>x^y = ~x&amp;y | x&amp;~y</code>。</p><p>比如：<code>2^3 = 10B ^ 11B = ~10B&amp;11B | 10B&amp;~11B = 01B&amp;11B | 10B&amp;00B = 01B | 00B = 01B = 1</code>。</p><h2 id="7-C语言中的位运算"><a href="#7-C语言中的位运算" class="headerlink" title="7 C语言中的位运算"></a>7 C语言中的位运算</h2><p>C语言中的位运算也是很有意思，比如不使用额外的变量来交换两个数：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">inplace_swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">*</span>y <span class="token operator">=</span> <span class="token operator">*</span>x <span class="token operator">^</span> <span class="token operator">*</span>y<span class="token punctuation">;</span>    <span class="token operator">*</span>x <span class="token operator">=</span> <span class="token operator">*</span>x <span class="token operator">^</span> <span class="token operator">*</span>y<span class="token punctuation">;</span>    <span class="token operator">*</span>y <span class="token operator">=</span> <span class="token operator">*</span>x <span class="token operator">^</span> <span class="token operator">*</span>y<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基于上面的函数，翻转一个数组：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">reserve_array</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> cnt<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> first<span class="token punctuation">,</span> last<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>first <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> last <span class="token operator">=</span> cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> first <span class="token operator">&lt;</span> last<span class="token punctuation">;</span> first<span class="token operator">++</span><span class="token punctuation">,</span> last<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">inplace_swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>位运算的一个重要用途就是掩码（masking）。比如对一个32位系统来说：</p><ol><li>只保留<code>x</code>的最后一个字节，其余的置零：<code>x&amp;0xff</code>；</li><li><code>x</code>的最后一个字节保留，其余的置为对应的补数：<code>x^~0xff</code>；</li><li><code>x</code>的最后一个字节置零，其余的不变：<code>x|0xff</code>。</li></ol><h2 id="8-C语言中的逻辑运算"><a href="#8-C语言中的逻辑运算" class="headerlink" title="8 C语言中的逻辑运算"></a>8 C语言中的逻辑运算</h2><p>C语言中的逻辑运算有：与（<code>&amp;&amp;</code>）、或（<code>||</code>）和非（<code>!</code>）。</p><p>这个逻辑运算和位运算有些不同，因为逻辑运算的结果只有0和1，对于传入的参数，也只认为是0（参数值就是0）或1（参数值非0）。</p><p>所以，<code>!0x41=0x00</code>，<code>!0x00=0x01</code>，<code>!!0x41=0x01</code>，<code>0x69&amp;&amp;0x55=0x01</code>，<code>0x69||0x55=0x01</code>。</p><p><strong>逻辑运算和对应的位运算的第二个不同，在于当第一个参数就能够确定运算结果的时候，就不会计算第二个参数的值。</strong></p><p>所以，表达式<code>a&amp;&amp;5/a</code>不会出零除错误；同样表达式<code>p&amp;&amp;*p++</code>也不会有空指针错误。</p><p>那么，如何用位运算表示<code>x==y</code>的结果呢？<code>!(x^y)</code>。</p><h2 id="9-C语言中的移位运算"><a href="#9-C语言中的移位运算" class="headerlink" title="9 C语言中的移位运算"></a>9 C语言中的移位运算</h2><p>移位运算有左移和右移。</p><p>对于左移，很好理解，比如左移4位，就是去掉最高的4位，然后最低的4位用0补。</p><p>对于右移，有些不同。同样是将最低的4位去掉然后最高的4位补齐，那是用0补呢还是用1补？</p><p>两种右移：逻辑右移（logical）和算术右移（arithmetic）。</p><p>如果逻辑右移，那就用0补；如果是算术右移，取决于原来数的最高位，如果最高位是1就用1，是0就用0。</p><p>比如<code>x=01100011</code>，那么逻辑右移4位就是<code>00000110B</code>，算术右移4位就是<code>00000110B</code>；</p><p>当<code>x=10010101B</code>，那么逻辑右移4位就是<code>00000110</code>，算术右移4位就是<code>11111001B</code>。</p><p>在C语言中，对于有符号数字，使用的是算术右移；对于无符号数字，使用的是逻辑右移。</p><p>对于Java，可以通过不同的运算符来指定：<code>&gt;&gt;</code>就是算术右移而<code>&gt;&gt;&gt;</code>就是逻辑右移。</p><p>如果一个数本身是32位，但是移动的位数大于32位，那么实际移动的位数就是取模的数。</p><p>最后需要注意的是，移位运算符的优先级低于加减，所以混合运算的时候，最好加上括号。</p>]]></content>
      
      
      <categories>
          
          <category> cs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp ch1: A Tour of Computer Systems</title>
      <link href="/csapp-ch1-a-tour-of-computer-systems/"/>
      <url>/csapp-ch1-a-tour-of-computer-systems/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是csapp第一章阅读笔记。</p></blockquote><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/A%20Tour%20of%20%20Computer%20System.png"><h2 id="1-信息就是：位-上下文"><a href="#1-信息就是：位-上下文" class="headerlink" title="1. 信息就是：位+上下文"></a>1. 信息就是：位+上下文</h2><p>下面是一个简单的hello程序：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello, world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个程序中所有的字符都是ASCII字符，那么类似这样只有ASCII字符的文件，就是文本文件（text file）。</p><p>其它的文件，就是二进制文件（binary file）。</p><p>上面的<code>hello.c</code>文件展示了一个计算机中的基本想法：</p><blockquote><p>All information in a system, is represented as a bunch of bits. The only thing that distinguishes different data objects is the context in which we view them.</p></blockquote><p>也就是说计算机中，不管是磁盘文件、内存中的程序或者网络中传输的数据，都是由一个个比特位（bits）组成的。用来区别它们的唯一方式是所处的上下文（context）。</p><p>所处的上下文不同，那么相同的一串比特信息可以构成不同的信息。</p><h2 id="2-程序被其他程序翻译成不同的格式"><a href="#2-程序被其他程序翻译成不同的格式" class="headerlink" title="2. 程序被其他程序翻译成不同的格式"></a>2. 程序被其他程序翻译成不同的格式</h2><p>为了执行上面的hello程序，我们需要将它编译成一个可执行程序：</p><pre class="line-numbers language-shell"><code class="language-shell">gcc -o hello hello.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个编译过程经过了如下的几个阶段：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/The%20Compilation%20System.png"><h3 id="2-1-Preprocessing-Phase"><a href="#2-1-Preprocessing-Phase" class="headerlink" title="2.1 Preprocessing Phase"></a>2.1 Preprocessing Phase</h3><p>预处理阶段：预处理器（cpp）修改原始的C程序<code>hello.c</code>，根据#所包含的头文件，预处理器将所包含的头文件中的内容直接插入到C程序中，得到<code>hello.i</code>文件，这也是一个文本文件。</p><h3 id="2-2-Compilation-Phase"><a href="#2-2-Compilation-Phase" class="headerlink" title="2.2 Compilation Phase"></a>2.2 Compilation Phase</h3><p>编译阶段：编译器（cc1）将上一阶段的结果<code>hello.i</code>文件转换成另一个文本文件<code>hello.s</code>，这里的<code>hello.s</code>文件包含的是汇编程序。比如：</p><pre class="line-numbers language-assembly"><code class="language-assembly">main:    subq    $8, %rsp    movl    $.LC0, %edi    call    puts    movl    $0, %eax    addq    $8, %rsp    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>汇编语言很有用，因为它为不同的高级语言提供了一个通用的编译结果。比如C语言编译器和Fortran编译器都可以生成同样的汇编语言文件。</p><p><code>hello.s</code>还是一个文本文件。</p><h3 id="2-3-Assembly-Phase"><a href="#2-3-Assembly-Phase" class="headerlink" title="2.3 Assembly Phase"></a>2.3 Assembly Phase</h3><p>汇编阶段：汇编器（assembler）将上一阶段的结果<code>hello.s</code>文件转换成机器语言指令，然后包装成可重定位目标程序（relocatable object program），将结果保存在<code>hello.o</code>文件中，这里，<code>hello.o</code>就是一个二进制文件了。</p><h3 id="2-4-Linking-Phase"><a href="#2-4-Linking-Phase" class="headerlink" title="2.4 Linking Phase"></a>2.4 Linking Phase</h3><p>链接阶段：在上面的hello程序中，我们使用了<code>printf</code>函数，这个函数是C语言标准库提供的，这个函数保存在另一个二进制文件<code>printf.o</code>中，为了使用这个函数，我们需要把上一阶段的结果<code>hello.o</code>和这个<code>printf.o</code>合并到一起。</p><p>这就是链接器（ld）的工作。输出的结果<code>hello</code>文件，就是一个可执行的二进制文件了，可以加载到内存中然后执行了。</p><h2 id="3-了解下编译系统是如何工作的很重要"><a href="#3-了解下编译系统是如何工作的很重要" class="headerlink" title="3. 了解下编译系统是如何工作的很重要"></a>3. 了解下编译系统是如何工作的很重要</h2><p>通过上面的过程，我们知道了一个<code>hello.c</code>文本文件是如果通过编译变成一个可执行二进制文件<code>hello</code>的了。</p><p>理解这个过程对于程序员是很重要的。原因有一下几点：</p><ul><li>理解编译的过程可以优化程序性能</li><li>可以理解链接时错误</li><li>避免一些安全问题的坑</li></ul><p>总之，理解底层的原理，终归是有好处的。</p><h2 id="4-处理器读并解释存在内存中的指令"><a href="#4-处理器读并解释存在内存中的指令" class="headerlink" title="4. 处理器读并解释存在内存中的指令"></a>4. 处理器读并解释存在内存中的指令</h2><p>为了执行上面的<code>hello</code>程序，只需要;</p><pre class="line-numbers language-shell"><code class="language-shell">./hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即可，就是这么简单。</p><p>那么计算机是如何执行存储在<code>hello</code>文件中的指令的呢？首先看一下计算机的整体结构：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/Hardware%20%20organization%20of%20a%20typical%20system.png"><h3 id="4-1-系统的硬件组成"><a href="#4-1-系统的硬件组成" class="headerlink" title="4.1 系统的硬件组成"></a>4.1 系统的硬件组成</h3><p>上图展示了系统的硬件组织，主要有下面几个部分：</p><h4 id="4-1-1-Buses"><a href="#4-1-1-Buses" class="headerlink" title="4.1.1 Buses"></a>4.1.1 Buses</h4><p>总线。总线用来在不同的部分之间传输数据。就像城市里的公路有四车道八车道一样，总线也有一个衡量的大小。总线有一个固定大小的指标：字（word），一个字就是总线能传输数据的最小单位，可以用bytes来表示。</p><p>不同的系统字的大小不同，也就是字包含的字节数不一样。32位系统一个字有4个字节；64位系统一个字有8个字节。</p><h4 id="4-1-2-I-O-Devices"><a href="#4-1-2-I-O-Devices" class="headerlink" title="4.1.2 I/O Devices"></a>4.1.2 I/O Devices</h4><p>输入输出设备。这就是计算机系统和外界的连接点了，比如键盘、鼠标、显示器和磁盘等。</p><p>每一个输入输出设备可以通过controller或adapter连接到系统中。</p><h4 id="4-1-3-Main-Memory"><a href="#4-1-3-Main-Memory" class="headerlink" title="4.1.3 Main Memory"></a>4.1.3 Main Memory</h4><p>内存。内存就是dynamic random access memory(DRAM)的集合。</p><h4 id="4-1-4-Processor"><a href="#4-1-4-Processor" class="headerlink" title="4.1.4 Processor"></a>4.1.4 Processor</h4><p>中央处理器，CPU。这个是用来执行指令的，有逻辑处理单元（arithmetic/logic unit, ALU）、程序计数器（program counter， PC）和寄存器文件（register file）。</p><p>CPU通过执行一些简单的指令就可以完成大量的工作：</p><ul><li>Load</li><li>Store</li><li>Operate</li><li>Jump</li></ul><h3 id="4-2-执行hello"><a href="#4-2-执行hello" class="headerlink" title="4.2 执行hello"></a>4.2 执行hello</h3><p>介绍完计算器的硬件组成，来看看计算机是如何执行<code>hello</code>这个程序的。</p><p>当我们将<code>./hello</code>通过键盘输入之后，这个信息就被存储到寄存器文件中了。这个过程就是读指令。如图：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/Reading%20the%20%20hello%20command%20from%20the%20keyboard.png"><p>当我们敲下回车键之后，计算机就知道指令输入完了，接下来就是执行了。shell将可执行的<code>hello</code>文件从磁盘加载进内存中。从上图可以看出，<code>hello</code>程序的数据先被送到了CPU中的寄存器文件中，然后送到内存中。</p><p>通过DMA（direct memory access）技术，磁盘中的数据可以直接送到内存中。如图：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/Loading%20the%20excutable%20from%20the%20disk%20into%20main%20memory.png"><p>当<code>hello</code>文件中的指令和数据加载到内存之后，计算机就可以执行程序中的指令了，并将数据输出到屏幕上：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/Writing%20the%20output%20string%20from%20main%20memory%20to%20display.png"><h2 id="5-缓存至关重要"><a href="#5-缓存至关重要" class="headerlink" title="5. 缓存至关重要"></a>5. 缓存至关重要</h2><p>从上面可以看到数据在磁盘、内存和CPU中不断穿梭，穿梭的过程中就浪费了一些时间。</p><p>所以为了降低时间，一个重要的组成部分就是缓存（cache）。</p><p>比如CPU中可以加上L1和L2缓存（static random access memory, SRAM）。</p><p>当然，在别的地方也可以加缓存。在计算机系统中，我们会经常看到缓存的身影。</p><h2 id="6-层级结构的存储设备"><a href="#6-层级结构的存储设备" class="headerlink" title="6. 层级结构的存储设备"></a>6. 层级结构的存储设备</h2><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/An%20example%20of%20memory%20hierarchy.png"><h2 id="7-操作系统管理硬件"><a href="#7-操作系统管理硬件" class="headerlink" title="7. 操作系统管理硬件"></a>7. 操作系统管理硬件</h2><p>当我们执行<code>hello</code>程序的时候，并不是这个程序完成了所有的工作，它依赖于另一个程序来完成大部分的工作，这个程序就是操作系统。操作系统用来管理硬件。结构如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/layered%20view%20of%20computer%20system.png"><h3 id="7-1-Processes"><a href="#7-1-Processes" class="headerlink" title="7.1 Processes"></a>7.1 Processes</h3><p>进程，是操作系统提供的一个抽象。它让运行在这个进程中的程序感觉，只有它自己在使用整个计算机系统。</p><p>进程的抽象如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/Abstractions%20provided%20by%20an%20operation%20system.png"><p>为了支持多个进程，需要使用上下文切换（context switching）的机制。说白了就是计算机的使用权在不同的进程中“反复横跳”：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/Process%20context%20switching.png"><p>除了用户进程，有一个内核进程。这个内核进程可以管理所有的进程。</p><h3 id="7-2-Threads"><a href="#7-2-Threads" class="headerlink" title="7.2 Threads"></a>7.2 Threads</h3><p>线程的粒度更低一些，一个进程可以有多个线程，所有的线程共享这一个进程的代码和数据。</p><p>多线程编程的代价比多进程编程的代价低一些。</p><h3 id="7-3-Virtual-Memory"><a href="#7-3-Virtual-Memory" class="headerlink" title="7.3 Virtual Memory"></a>7.3 Virtual Memory</h3><p>虚拟内存。就像进程是一个抽象一样，虚拟内存也是一个抽象。它给每个进程一个幻觉，好像自己独占了所有的内存一样。</p><p>虚拟内存的结构如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/Process%20virtual%20address%20space.png"><p>主要包括：代码段、数据段、堆、共享库、栈和内核虚拟内存。</p><h3 id="7-4-Files"><a href="#7-4-Files" class="headerlink" title="7.4 Files"></a>7.4 Files</h3><p>文件就是比特串。在linux中，所有的IO设备也被认为是文件。</p><h2 id="8-系统间使用网络通信"><a href="#8-系统间使用网络通信" class="headerlink" title="8. 系统间使用网络通信"></a>8. 系统间使用网络通信</h2><p>上面介绍的都是在一个计算机系统中。那么不同的计算机系统之间怎么通信呢？</p><p>答案是使用网络：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/A%20network%20is%20another%20IO%20device.png"><p>网络也可以认为是一个I/O设备，当然也可以当做是一个文件。</p><h2 id="9-重要的主题"><a href="#9-重要的主题" class="headerlink" title="9. 重要的主题"></a>9. 重要的主题</h2><h3 id="9-1-Amdahl’s-Law"><a href="#9-1-Amdahl’s-Law" class="headerlink" title="9.1 Amdahl’s Law"></a>9.1 Amdahl’s Law</h3><p>主旨就是：当我们提升系统中一部分的效率时，那么整体的效果取决于，那部分在整个系统中的重要性以及那部分提升效率的具体值。</p><p>令$T_{old}$作为系统升级前所需时间，$α$作为升级部分在系统中的比例，性能提升系数是$k$，那么系统提升后所需的时间：<br>$$<br>T_{new}=(1-α)T_{old}+(αT_{old})/k<br>=T_{old}[(1-α)+α/k]<br>$$<br>所以系统整体性能提升的系数$S$是：<br>$$<br>S=\frac{1}{(1-α)+α/k}<br>$$<br>比如要升级一个系统中占60%的子系统（α=0.6），性能提升系数是3（k=3）。那么整体提升的性能系数是1/[0.4+0.6/3]=1.67。</p><p>有意思的是，当k无穷大时，系统整体的性能提升系数是：<br>$$<br>S_{∞}=\frac{1}{1-α}<br>$$<br>拿上面的例子来说就是2.5。</p><p>所以我们在做系统优化的时候，对于一个子系统不一定非要提升得多么多么好，从而白白浪费精力也没有给整个系统带来可观的性能提升。</p><h3 id="9-2-Concurrency-and-Parallelism"><a href="#9-2-Concurrency-and-Parallelism" class="headerlink" title="9.2 Concurrency and Parallelism"></a>9.2 Concurrency and Parallelism</h3><p>并发与并行。在整个计算机的发展过程中，我们主要有两个目的：让计算机做得更多以及，做得更快。</p><p>使用并发（concurrency）这个术语来指系统同时做多个任务；使用并行（parallelism）来指系统通过并发执行得更快。</p><h4 id="9-2-1-线程级并发"><a href="#9-2-1-线程级并发" class="headerlink" title="9.2.1 线程级并发"></a>9.2.1 线程级并发</h4><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/Intel%20Core%20i7%20organization.png"><h4 id="9-2-2-指令级并行"><a href="#9-2-2-指令级并行" class="headerlink" title="9.2.2 指令级并行"></a>9.2.2 指令级并行</h4><p>就是处理器同时执行多条指令。</p><p>在一个时钟周期内执行多条指令的处理器叫做超标量处理器（superscalar processors）。</p><h4 id="9-2-3-单条指令，多个数据并行"><a href="#9-2-3-单条指令，多个数据并行" class="headerlink" title="9.2.3 单条指令，多个数据并行"></a>9.2.3 单条指令，多个数据并行</h4><p>最低一层，就是在一个指令中，处理多个数据。这叫做single-instruction, multiple-data(SIMD)。</p><h3 id="9-3-计算机系统中抽象的重要性"><a href="#9-3-计算机系统中抽象的重要性" class="headerlink" title="9.3 计算机系统中抽象的重要性"></a>9.3 计算机系统中抽象的重要性</h3><p>计算机系统中的一个重要概念就是抽象了，比如API就是一个抽象。</p><p>下面就是一些这章内容介绍的抽象：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/CS/Some%20abstractions%20provided%20by%20a%20computer%20system.png">]]></content>
      
      
      <categories>
          
          <category> cs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《中国历代政治得失》笔记</title>
      <link href="/zhong-guo-li-dai-zheng-zhi-de-shi-bi-ji/"/>
      <url>/zhong-guo-li-dai-zheng-zhi-de-shi-bi-ji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>利用周末一个下午的时间，重新刷了一遍钱穆的《中国历代政治得失》。能说“西方在政治经验上一般都比较短浅”这话的，只有中国人。这不是自夸，这是事实。从整本书中都能看出钱穆对中国古代政治经验的一种称赞。他推崇汉代的地方政府组织，推崇唐代的中央政府组织，贬低清代，认为“部族政权没有制度，只有权术”。政治只是文化的一个部分，要充分理解政治，需要对文化有一个了解。读钱穆的书，就是会涨知识。</p></blockquote><h2 id="1-汉代"><a href="#1-汉代" class="headerlink" title="1. 汉代"></a>1. 汉代</h2><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E6%B1%89%E4%BB%A3.png" alt="汉代政治组织"></p><h2 id="2-唐代"><a href="#2-唐代" class="headerlink" title="2. 唐代"></a>2. 唐代</h2><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%94%90%E4%BB%A3.png" alt="唐代政治组织"></p><h2 id="3-宋代"><a href="#3-宋代" class="headerlink" title="3. 宋代"></a>3. 宋代</h2><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%AE%8B%E4%BB%A3.png" alt="宋代政治组织"></p><h2 id="4-明代"><a href="#4-明代" class="headerlink" title="4. 明代"></a>4. 明代</h2><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E6%98%8E%E4%BB%A3.png" alt="明代政治组织"></p><h2 id="5-清代"><a href="#5-清代" class="headerlink" title="5. 清代"></a>5. 清代</h2><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E6%B8%85%E4%BB%A3.png" alt="清代政治组织"></p>]]></content>
      
      
      <categories>
          
          <category> reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> history </tag>
            
            <tag> china </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>All You Need to Know About MySQL Partitions (Part 2)</title>
      <link href="/all-you-need-to-know-about-mysql-partitions-part-2/"/>
      <url>/all-you-need-to-know-about-mysql-partitions-part-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在<a href="https://deuterium.fun/all-you-need-to-know-about-mysql-partitions-part-1/">Part 1</a>中，已经详细介绍了MySQL中的几种分区方式。在这里，详细介绍一下分区的各种操作。同样，这篇文章是对<a href="https://dev.mysql.com/doc/refman/8.0/en/partitioning.html" target="_blank" rel="noopener">官方文档</a>的梳理。</p></blockquote><h2 id="3-分区管理"><a href="#3-分区管理" class="headerlink" title="3. 分区管理"></a>3. 分区管理</h2><p>对于一个一分区的表来说，分区管理包括添加分区、删除分区、合并分区、拆分分区以及，改变分区方式等。对于这些操作，都需要使用<code>ALTER TABLE</code>语句来进行操作。需要注意的是，每一个<code>ALTER TABLE</code>语句只能有一个分区相关的操作，而不能在一个<code>ALTER TABLE</code>语句中有多个分区操作。</p><h3 id="3-1-RANGE分区和LIST分区管理"><a href="#3-1-RANGE分区和LIST分区管理" class="headerlink" title="3.1 RANGE分区和LIST分区管理"></a>3.1 RANGE分区和LIST分区管理</h3><p>对Range分区和List分区操作是一样的。</p><h4 id="3-1-1-删除分区"><a href="#3-1-1-删除分区" class="headerlink" title="3.1.1 删除分区"></a>3.1.1 删除分区</h4><p>比如下面的例子：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> tr <span class="token punctuation">(</span>id <span class="token keyword">INT</span><span class="token punctuation">,</span> name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span> purchased <span class="token keyword">DATE</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE<span class="token punctuation">(</span> YEAR<span class="token punctuation">(</span>purchased<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1990</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1995</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">2005</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p4 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">2010</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p5 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以这样来删除分区：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> tr <span class="token keyword">DROP</span> <span class="token keyword">PARTITION</span> p2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>牢记，删除一个分区，那么这个分区里的所有数据也会被删除。所以，这需要有<code>DROP</code>权限。</p><p>如果只想删除某个分区的数据而保留这个分区，可以使用<code>truncate</code>：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> tr <span class="token keyword">TRUNCATE</span> <span class="token keyword">PARTITION</span> p2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，分区<code>p2</code>仍然保留，只是分区内的数据删除了。</p><p>为了查看一张表的分区情况，可以使用<code>SHOW CREATE TABLE</code>：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> tr<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除List分区也和Range分区操作一样。</p><h4 id="3-1-2-添加分区"><a href="#3-1-2-添加分区" class="headerlink" title="3.1.2 添加分区"></a>3.1.2 添加分区</h4><p>加入已有下面的分区表：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> members <span class="token punctuation">(</span>    id <span class="token keyword">INT</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    dob <span class="token keyword">DATE</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE<span class="token punctuation">(</span> YEAR<span class="token punctuation">(</span>dob<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1980</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1990</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用下面的语句来添加分区：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> members <span class="token keyword">ADD</span> <span class="token keyword">PARTITION</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">2010</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不过需要注意的是，添加分区只能在高范围添加，在低范围添加分区不会成功。</p><p>如果添加下面的分区：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> members <span class="token keyword">ADD</span> <span class="token keyword">PARTITION</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1970</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这会导致失败。</p><p>在一条<code>ALTER TABLE</code>语句中，可以添加多个分区：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> employees <span class="token keyword">ADD</span> <span class="token keyword">PARTITION</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p5 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">2010</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p6 <span class="token keyword">VALUES</span> LESS THAN MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-1-3-调整分区"><a href="#3-1-3-调整分区" class="headerlink" title="3.1.3 调整分区"></a>3.1.3 调整分区</h4><p>不过，如果觉得之前的分区范围不合理的话，可以调整分区：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> members    REORGANIZE <span class="token keyword">PARTITION</span> p0 <span class="token keyword">INTO</span> <span class="token punctuation">(</span>        <span class="token keyword">PARTITION</span> n0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1970</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">PARTITION</span> n1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1980</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于List分区来说也是一样的。</p><p>同样也可以用来合并分区：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> members REORGANIZE <span class="token keyword">PARTITION</span> s0<span class="token punctuation">,</span>s1 <span class="token keyword">INTO</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1970</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在重新划分与合并分区过程中，不会有数据丢失。</p><p>使用<code>REORGANIZE PARTITION</code>语句对分区进行调整时，需要注意以下几点：</p><ul><li>对于Range分区和List分区，调整前的范围不能丢弃；</li><li>这个语句不能用来修改分区的方式，以及分区定义中的列以及表达式。</li></ul><h3 id="3-2-HASH分区和KEY分区管理"><a href="#3-2-HASH分区和KEY分区管理" class="headerlink" title="3.2 HASH分区和KEY分区管理"></a>3.2 HASH分区和KEY分区管理</h3><p>Hash分区与Key分区的管理类似，但是和Range分区与List分区有些不同。这里仅仅介绍Hash分区与Key分区的修改。</p><p>Hash分区和Key分区不能直接删除分区。假如一张表划分成12个分区：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> clients <span class="token punctuation">(</span>    id <span class="token keyword">INT</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    signed <span class="token keyword">DATE</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> <span class="token keyword">HASH</span><span class="token punctuation">(</span> MONTH<span class="token punctuation">(</span>signed<span class="token punctuation">)</span> <span class="token punctuation">)</span>PARTITIONS <span class="token number">12</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想改成8个分区，那么可以这样：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> clients <span class="token keyword">COALESCE</span> <span class="token keyword">PARTITION</span> <span class="token number">4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于Hash分区、Key分区、Liner Hash分区和Liner Key分区来说，都可以使用<code>COALESCE</code>来合并分区。</p><p><code>COALESCE</code>是用来减少分区的，后面的数字就是要减少的分区数量，这个数字不能比调整前的分区数量大，不然会失败。</p><p>如果想增加分区的数量，可以使用<code>ALTER TABLE ... ADD PARTITION</code>：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> clients <span class="token keyword">ADD</span> <span class="token keyword">PARTITION</span> PARTITIONS <span class="token number">6</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样，后面的数字是需要增加的分区数量。</p><h3 id="3-3-交换分区"><a href="#3-3-交换分区" class="headerlink" title="3.3 交换分区"></a>3.3 交换分区</h3><p>在MySQL中，可以把一个分区表中的某个分区与另一个没有分区的表进行数据交换。不过，对于分区表<code>pt</code>、表<code>pt</code>中要交换的分区<code>p</code>和普通表<code>nt</code>需要满足下面的条件：</p><ul><li>表<code>nt</code>没有分区；</li><li>表<code>nt</code>不是临时表；</li><li>除了一个分区一个没分区外，表<code>pt</code>和<code>nt</code>的结构一样；</li><li>表<code>nt</code>没有外键，同时也没有别的表的外键引用表<code>nt</code>；</li><li>表<code>nt</code>中的数据需要满足分区<code>p</code>的定义，如果使用<code>WITHOUT VALIDATION</code>的话就不需要了；</li><li>对于InnoDB表，<code>pt</code>和<code>nt</code>的行格式需要一致；</li></ul><p>为了成功交换分区，需要有<code>ALTER</code>，<code>INSERT</code>，<code>CREATE</code>和<code>DROP</code>的权限。</p><p>同时需要注意：</p><ul><li><code>ALTER TABLE ... EXCHANGE PARTITION</code>语句的执行不会触发两个表的触发器；</li><li>表中的<code>AUTO_INCREMENT</code>字段的值会被重置。</li></ul><p>语法如下：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> pt    EXCHANGE <span class="token keyword">PARTITION</span> p    <span class="token keyword">WITH</span> <span class="token keyword">TABLE</span> nt<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="3-3-1-与一个未分区的表交换分区"><a href="#3-3-1-与一个未分区的表交换分区" class="headerlink" title="3.3.1 与一个未分区的表交换分区"></a>3.3.1 与一个未分区的表交换分区</h4><p>定义一张分区表如下并插入几条数据：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token number">e</span> <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">(</span>        <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">150</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token number">e</span> <span class="token keyword">VALUES</span>    <span class="token punctuation">(</span><span class="token number">1669</span><span class="token punctuation">,</span> <span class="token string">"Jim"</span><span class="token punctuation">,</span> <span class="token string">"Smith"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token number">337</span><span class="token punctuation">,</span> <span class="token string">"Mary"</span><span class="token punctuation">,</span> <span class="token string">"Jones"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">"Frank"</span><span class="token punctuation">,</span> <span class="token string">"White"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token number">2005</span><span class="token punctuation">,</span> <span class="token string">"Linda"</span><span class="token punctuation">,</span> <span class="token string">"Black"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后创建一张和<code>e</code>结构一样但是不分区的表<code>e2</code>。</p><p>可以通过下面的语句将表<code>e</code>中的分区<code>p0</code>中的数据交换到表<code>e2</code>中：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token number">e</span> EXCHANGE <span class="token keyword">PARTITION</span> p0 <span class="token keyword">WITH</span> <span class="token keyword">TABLE</span> <span class="token number">e2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，分区<code>p0</code>中的数据就被交换到表<code>e2</code>中了，可以通过查看数据来验证。</p><p>既然是交换，那么表<code>e2</code>中不一定非要是空的，也可以有数据。经过上面的交换之后，<code>p0</code>分区中没有数据了，而<code>e2</code>中有一条数据：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token number">e2</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+-------+-------+</span><span class="token operator">|</span> id <span class="token operator">|</span> fname <span class="token operator">|</span> lname <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+-------+-------+</span><span class="token operator">|</span> <span class="token number">16</span> <span class="token operator">|</span> Frank <span class="token operator">|</span> White <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+-------+-------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在在<code>p0</code>中插入一条数据：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token number">e</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">,</span> <span class="token string">"Michael"</span><span class="token punctuation">,</span> <span class="token string">"Green"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后再交换分区：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token number">e</span> EXCHANGE <span class="token keyword">PARTITION</span> p0 <span class="token keyword">WITH</span> <span class="token keyword">TABLE</span> <span class="token number">e2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，分区<code>p0</code>中的数据就和<code>e2</code>中的数据交换了，可以通过查看数据来验证。</p><h4 id="3-3-2-不符合分区定义的数据"><a href="#3-3-2-不符合分区定义的数据" class="headerlink" title="3.3.2 不符合分区定义的数据"></a>3.3.2 不符合分区定义的数据</h4><p>在进行分区交换的时候，未分区表<code>nt</code>中的数据要满足待交换分区<code>p</code>的定义，如果不满足的话，执行交换分区会失败。</p><p>如果表<code>nt</code>中确实有不满足分区定义的数据但还是需要进行交换，那么可以使用<code>WITHOUT VALIDATION</code>：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token number">e</span> EXCHANGE <span class="token keyword">PARTITION</span> p0 <span class="token keyword">WITH</span> <span class="token keyword">TABLE</span> <span class="token number">e2</span> WITHOUT VALIDATION<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要注意的是，在MySQL 5.6 中不支持<code>WITHOUT VALIDATION</code>，表<code>nt</code>中的数据一定要满足分区定义，否则执行不成功。</p><h4 id="3-3-3-交换分区不校验数据"><a href="#3-3-3-交换分区不校验数据" class="headerlink" title="3.3.3 交换分区不校验数据"></a>3.3.3 交换分区不校验数据</h4><p>如果在交换过程中使用<code>WITHOUT VALIDATION</code>的话，可以加快交换的速度，但是并没有比校验快多少。</p><h4 id="3-3-4-交换子分区"><a href="#3-3-4-交换子分区" class="headerlink" title="3.3.4 交换子分区"></a>3.3.4 交换子分区</h4><p>同样，也可以交换一个子分区。比如下面一个有子分区的表：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> es <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span>id<span class="token punctuation">)</span>    SUBPARTITION <span class="token keyword">BY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>lname<span class="token punctuation">)</span>    SUBPARTITIONS <span class="token number">2</span> <span class="token punctuation">(</span>        <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">150</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然我们没有显示定义子分区的名字，不过MySQL还是会自动给子分区一个名字的。可以通过下面的方式查看子分区的名字：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> PARTITION_NAME<span class="token punctuation">,</span> SUBPARTITION_NAME<span class="token punctuation">,</span> TABLE_ROWS <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>PARTITIONS <span class="token keyword">WHERE</span> TABLE_NAME <span class="token operator">=</span> <span class="token string">'es'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后就可以交换子分区了：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> es EXCHANGE <span class="token keyword">PARTITION</span> p3sp0 <span class="token keyword">WITH</span> <span class="token keyword">TABLE</span> es2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>和交换分区一样。</p><p>只不过，如果一个表有子分区，那么就只能对子分区进行交换，而不能对分区进行交换：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> es EXCHANGE <span class="token keyword">PARTITION</span> p3 <span class="token keyword">WITH</span> <span class="token keyword">TABLE</span> es2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-4-分区的维护"><a href="#3-4-分区的维护" class="headerlink" title="3.4 分区的维护"></a>3.4 分区的维护</h3><p>对于分区的维护，可以从以下几个方面进行。</p><h4 id="3-4-1-重建分区"><a href="#3-4-1-重建分区" class="headerlink" title="3.4.1 重建分区"></a>3.4.1 重建分区</h4><p>这里的重建不是说重新定义分区，而是为了避免磁盘碎片化而重新整理分区的内容：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> t1 REBUILD <span class="token keyword">PARTITION</span> p0<span class="token punctuation">,</span> p1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个过程的效果就和删除分区的数据然后重新插入是一样的。</p><h4 id="3-4-2-优化分区"><a href="#3-4-2-优化分区" class="headerlink" title="3.4.2 优化分区"></a>3.4.2 优化分区</h4><p>如果对一个分区进行了大量的删除操作，或者对使用变长字段（<code>VARCHAR</code>，<code>BLOB</code>或<code>TEXT</code>）进行了更新操作，那么可以使用如下的语句来进行分区优化：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> t1 <span class="token keyword">OPTIMIZE</span> <span class="token keyword">PARTITION</span> p0<span class="token punctuation">,</span> p1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>语句<code>OPTIMIZE PARTITION</code>的效果就和一起执行<code>CHECK PARTITION</code>、<code>ANALYZE PARTITION</code>和<code>REPAIR PARTITION</code>一样。</p><p>不过对于InnoDB来说，不支持对于指定的分区进行上述操作，不过可以使用<code>ALTER TABLE ... OPTIMIZE PARTITION</code>来替代。</p><h3 id="3-5-获取分区的详细信息"><a href="#3-5-获取分区的详细信息" class="headerlink" title="3.5 获取分区的详细信息"></a>3.5 获取分区的详细信息</h3><p>对于一个分区表，可以使用如下几种方式来获取关于分区的详细信息。</p><h4 id="3-5-1-SHOW-CREATE-TABLE"><a href="#3-5-1-SHOW-CREATE-TABLE" class="headerlink" title="3.5.1 SHOW CREATE TABLE"></a>3.5.1 <code>SHOW CREATE TABLE</code></h4><p><code>SHOW CREATE TABLE</code>显示创建表时候的语句，如果一个表使用了分区，那么这里也会有分区的详细定义信息：</p><pre class="line-numbers language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> trb3\G<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>       <span class="token keyword">Table</span>: trb3<span class="token keyword">Create</span> <span class="token keyword">Table</span>: <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>trb3<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>purchased<span class="token punctuation">`</span> <span class="token keyword">date</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token comment" spellcheck="true">/*!50100 PARTITION BY RANGE (YEAR(purchased))(PARTITION p0 VALUES LESS THAN (1990) ENGINE = InnoDB, PARTITION p1 VALUES LESS THAN (1995) ENGINE = InnoDB, PARTITION p2 VALUES LESS THAN (2000) ENGINE = InnoDB, PARTITION p3 VALUES LESS THAN (2005) ENGINE = InnoDB) */</span><span class="token number">0</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是一个简单的例子。可以看出这个表使用的是Range分区，每个分区的详细范围定义也给出来了。</p><h4 id="3-5-2-SHOW-TABLE-STATUS"><a href="#3-5-2-SHOW-TABLE-STATUS" class="headerlink" title="3.5.2 SHOW TABLE STATUS"></a>3.5.2 <code>SHOW TABLE STATUS</code></h4><p>使用<code>SHOW TABLE STATUS</code>给出的关于分区的信息很少，只只有一个字段来标识这个表是否是分区的：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">TABLE</span> <span class="token keyword">STATUS</span> test<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的<code>test</code>是库名，给出库里所有表的信息。这是一个分区表的例子：</p><pre class="line-numbers language-shell"><code class="language-shell">           Name: e         Engine: InnoDB        Version: 10     Row_format: Compact           Rows: 6 Avg_row_length: 10922    Data_length: 65536Max_data_length: 0   Index_length: 0      Data_free: 0 Auto_increment: NULL    Create_time: 2020-03-18 21:43:16    Update_time: NULL     Check_time: NULL      Collation: utf8_general_ci       Checksum: NULL Create_options: partitioned        Comment:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字段<code>Create_options</code>的值是<code>partitoned</code>，标识这个表是分区的。</p><h4 id="3-5-3-INFORMATION-SCHEMA-PARTITIONS表"><a href="#3-5-3-INFORMATION-SCHEMA-PARTITIONS表" class="headerlink" title="3.5.3 INFORMATION_SCHEMA.PARTITIONS表"></a>3.5.3 INFORMATION_SCHEMA.PARTITIONS表</h4><p>为了获得详细的信息，可以查询<code>INFORMATION_SCHEMA.PARTITIONS</code>表。</p><p>这个表里的每一行数据都是一个分区或子分区的信息。</p><p>这个表的有下面这些字段：</p><table><thead><tr><th>Field</th><th>Type</th><th>Null</th><th>含义</th></tr></thead><tbody><tr><td><code>TABLE_CATALOG</code></td><td>varchar(512)</td><td>NO</td><td>总是<code>def</code></td></tr><tr><td><code>TABLE_SCHEMA</code></td><td>varchar(64)</td><td>NO</td><td>分区所属库</td></tr><tr><td><code>TABLE_NAME</code></td><td>varchar(64)</td><td>NO</td><td>分区所属表</td></tr><tr><td><code>PARTITION_NAME</code></td><td>varchar(64)</td><td>YES</td><td>分区名</td></tr><tr><td><code>SUBPARTITION_NAME</code></td><td>varchar(64)</td><td>YES</td><td>有子分区的话就是子分区名，否则是NULL</td></tr><tr><td><code>PARTITION_ORDINAL_POSITION</code></td><td>bigint(21) unsigned</td><td>YES</td><td>分区的下标，按照定义从1开始，如果分区发生更改这个下标也会有变化</td></tr><tr><td><code>SUBPARTITION_ORDINAL_POSITION</code></td><td>bigint(21) unsigned</td><td>YES</td><td>子分区的下标，和分区的下标类似</td></tr><tr><td><code>PARTITION_METHOD</code></td><td>varchar(18)</td><td>YES</td><td>分区类型，可取值：<code>RANGE</code>, <code>LIST</code>, <code>HASH</code>, <code>LINEAR HASH</code>, <code>KEY</code>, or <code>LINEAR KEY</code></td></tr><tr><td><code>SUBPARTITION_METHOD</code></td><td>varchar(12)</td><td>YES</td><td>子分区类型，可取值：<code>HASH</code>, <code>LINEAR HASH</code>, <code>KEY</code>, or <code>LINEAR KEY</code></td></tr><tr><td><code>PARTITION_EXPRESSION</code></td><td>longtext</td><td>YES</td><td>分区表达式，如果分区定义是<code>PARTITION BY HASH(c1 + c2)</code>，那么这个值就是<code>c1 + c2</code></td></tr><tr><td><code>SUBPARTITION_EXPRESSION</code></td><td>longtext</td><td>YES</td><td>子分区表达式，和分区表达式类似</td></tr><tr><td><code>PARTITION_DESCRIPTION</code></td><td>longtext</td><td>YES</td><td>对于Range分区和List分区的范围取值，其它类型的分区这个值为NULL</td></tr><tr><td><code>TABLE_ROWS</code></td><td>bigint(21) unsigned</td><td>NO</td><td>这个分区数据的行数</td></tr><tr><td><code>AVG_ROW_LENGTH</code></td><td>bigint(21) unsigned</td><td>NO</td><td>平均每行的大小（单位是Byte）</td></tr><tr><td><code>DATA_LENGTH</code></td><td>bigint(21) unsigned</td><td>NO</td><td>这个分区所有数据的总大小（单位是Byte）</td></tr><tr><td><code>MAX_DATA_LENGTH</code></td><td>bigint(21) unsigned</td><td>YES</td><td>这个分区中最大行的大小（单位是Byte）</td></tr><tr><td><code>INDEX_LENGTH</code></td><td>bigint(21) unsigned</td><td>NO</td><td>这个分区的索引大小（单位是Byte）</td></tr><tr><td><code>DATA_FREE</code></td><td>bigint(21) unsigned</td><td>NO</td><td>分配给这个分区的未用空间大小（单位是Byte）</td></tr><tr><td><code>CREATE_TIME</code></td><td>datetime</td><td>YES</td><td>分区创建时间</td></tr><tr><td><code>UPDATE_TIME</code></td><td>datetime</td><td>YES</td><td>分区最近更新时间</td></tr><tr><td><code>CHECK_TIME</code></td><td>datetime</td><td>YES</td><td>分区Check时间</td></tr><tr><td><code>CHECKSUM</code></td><td>bigint(21) unsigned</td><td>YES</td><td>checksum</td></tr><tr><td><code>PARTITION_COMMENT</code></td><td>varchar(80)</td><td>NO</td><td>分区注释</td></tr><tr><td><code>NODEGROUP</code></td><td>varchar(12)</td><td>NO</td><td>该分区所属的节点组，和NDB有关，其它的都是0</td></tr><tr><td><code>TABLESPACE_NAME</code></td><td>varchar(64)</td><td>YES</td><td>分区所属的表空间除了NDB外都是<code>DEFAULT</code></td></tr></tbody></table><p>从上表可以看出关于分区的信息还是很丰富的，平时我们也用不到这么多，基本上下面的例子就满足所有的需求了：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> PARTITION_NAME<span class="token punctuation">,</span> SUBPARTITION_NAME<span class="token punctuation">,</span> TABLE_ROWS <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>PARTITIONS <span class="token keyword">WHERE</span> TABLE_NAME <span class="token operator">=</span> <span class="token string">'e'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里列出了分区名、子分区名以及对应的分区的行数。</p><h4 id="3-5-4-SELECT-EXPLAIN"><a href="#3-5-4-SELECT-EXPLAIN" class="headerlink" title="3.5.4 SELECT EXPLAIN"></a>3.5.4 <code>SELECT EXPLAIN</code></h4><p>当我们对分区表进行查询的时候，可以使用<code>EXPLAIN</code>来看一下查询使用到的分区。</p><p>创建下面的分区表：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> trb1 <span class="token punctuation">(</span>id <span class="token keyword">INT</span><span class="token punctuation">,</span> name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span> purchased <span class="token keyword">DATE</span><span class="token punctuation">)</span>    <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE<span class="token punctuation">(</span>id<span class="token punctuation">)</span>    <span class="token punctuation">(</span>        <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> trb1 <span class="token keyword">VALUES</span>    <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'desk organiser'</span><span class="token punctuation">,</span> <span class="token string">'2003-10-15'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'CD player'</span><span class="token punctuation">,</span> <span class="token string">'1993-11-05'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'TV set'</span><span class="token punctuation">,</span> <span class="token string">'1996-03-10'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'bookcase'</span><span class="token punctuation">,</span> <span class="token string">'1982-01-10'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'exercise bike'</span><span class="token punctuation">,</span> <span class="token string">'2004-05-09'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'sofa'</span><span class="token punctuation">,</span> <span class="token string">'1987-06-05'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'popcorn maker'</span><span class="token punctuation">,</span> <span class="token string">'2001-11-22'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">'aquarium'</span><span class="token punctuation">,</span> <span class="token string">'1992-08-04'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token string">'study desk'</span><span class="token punctuation">,</span> <span class="token string">'1984-09-16'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'lava lamp'</span><span class="token punctuation">,</span> <span class="token string">'1998-12-25'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>EXPLAIN</code>：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> trb1\G<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: trb1   partitions: p0,p1,p2,p3         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 10        Extra: Using filesort<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，这个查询将会用到所有的分区。而这个查询<code>EXPLAIN SELECT * FROM trb1 WHERE id &lt; 5\G</code>:</p><pre class="line-numbers language-shell"><code class="language-shell">*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: trb1   partitions: p0,p1         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 10        Extra: Using where<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用到了前两个分区。</p><h2 id="4-分区修剪"><a href="#4-分区修剪" class="headerlink" title="4. 分区修剪"></a>4. 分区修剪</h2><p>分区修剪（Partition Pruning）是一个策略，简单来说就是，忽略掉那些不可能匹配的分区，以此来减小搜索的数据。</p><p>以下面的分区表为例：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t1 <span class="token punctuation">(</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    region_code <span class="token keyword">TINYINT</span> UNSIGNED <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    dob <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE<span class="token punctuation">(</span> region_code <span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">192</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>考虑下面的查询语句：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> fname<span class="token punctuation">,</span> lname<span class="token punctuation">,</span> region_code<span class="token punctuation">,</span> dob    <span class="token keyword">FROM</span> t1    <span class="token keyword">WHERE</span> region_code <span class="token operator">></span> <span class="token number">125</span> <span class="token operator">AND</span> region_code <span class="token operator">&lt;</span> <span class="token number">130</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查询的条件就是<code>region_code</code>，而这个字段刚好是分区的字段，这样就可以使用分区修剪了。条件是<code>125 &lt; region_code &lt; 130</code>，通过查看分区定义可知，所选数据只可能在<code>p1</code>和<code>p2</code>分区中。</p><p>当一个查询条件可以总结成下面的形式时，就可以是用分区修剪：</p><ul><li><code>partition_column = constant</code></li><li><code>partition_column IN (constant1, constant2, ..., constantN)</code></li></ul><p>如果查询条件是等于，那么可以划为第一种情况；如果是不等式，那么可以划为第二种情况。</p><p>除了<code>SELECT</code>外，<code>DELETE</code>和<code>UPDATE</code>也支持分区修剪。</p><p>和Range分区一样，List分区也可以像Range分区一样使用分区修剪。</p><p>对于Hash分区和Key分区来说，分区修剪只能用于整数类型的分区字段。</p><p>下面是一个Hash分区的例子：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t4 <span class="token punctuation">(</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    region_code <span class="token keyword">TINYINT</span> UNSIGNED <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    dob <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>region_code<span class="token punctuation">)</span>PARTITIONS <span class="token number">8</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>语句：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> t4 <span class="token keyword">WHERE</span> region_code <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用分区修剪。但是对于：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> t4 <span class="token keyword">WHERE</span> region_code <span class="token operator">BETWEEN</span> <span class="token number">4</span> <span class="token operator">AND</span> <span class="token number">12</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>则不能使用分区修剪，因为这个查询的范围是9个值，但是表<code>t4</code>只有8个分区。</p><h2 id="5-指定分区"><a href="#5-指定分区" class="headerlink" title="5. 指定分区"></a>5. 指定分区</h2><p>在分区修剪中，我们知道MySQL会对一些语句进行优化，只对符合条件的分区进行操作。分区修剪是自动完成的，我们还可以指定分区。</p><p>除了<code>SELECT</code>外，还有好多支持指定分区的操作：<code>DELETE</code>，<code>UPDATE</code>，<code>INSERT</code>，<code>REPLACE</code>，<code>LOAD DATA</code>和<code>LOAD XML</code>等。</p><p>在语句中指定分区的格式很简单：</p><pre class="line-numbers language-sql"><code class="language-sql">      <span class="token keyword">PARTITION</span> <span class="token punctuation">(</span>partition_names<span class="token punctuation">)</span>      partition_names:          partition_name<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>比如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">PARTITION</span> <span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指定分区之后，就只会返回指定分区的数据。</p><p>指定分区需要知道分区的名字，着对于Range分区和List分区来说很简单，因为表创建分区的时候就会指定名字。但是对于Hash分区和Key分区来说，没有指定名字。MySQL默认的分区名字是这样的<code>p0</code>，<code>p1</code>，<code>p2</code>等等。对于子分区，默认的名字是<code>p0sp0</code>，<code>p0sp1</code>，<code>p0sp2</code>等。</p><p>当然也可以直接查询<code>SHOW CREATE TABLE ...</code> 来查看分区定义，或者查询<code>SELECT PARTITION_NAME, SUBPARTITION_NAME FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = &#39;e&#39;</code>来查看分区的名字。</p><p>指定分区也可以指定多个分区：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">PARTITION</span> <span class="token punctuation">(</span>p0<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更新删除插入操作也可以指定分区。</p><p>不过需要注意的是，对于插入多条语句来说，如果使用InnoDB，如果多条数据中有一条不符合指定分区的定义，那么即使有符合的也不会插入成功。</p><h2 id="6-分区的限制与局限"><a href="#6-分区的限制与局限" class="headerlink" title="6. 分区的限制与局限"></a>6. 分区的限制与局限</h2><p>在MySQL中，对分区的支持是在存储引擎上的，且只有InnoDB和NDB支持分区，其它的存储引擎是不支持的。</p><p>使用分区需要注意下面几个方面的限制于局限。</p><h3 id="6-1-分区与键"><a href="#6-1-分区与键" class="headerlink" title="6.1 分区与键"></a>6.1 分区与键</h3><p>分区表达式中使用的所有字段，必须在所有的唯一键中（包括主键，主键也是唯一键）。</p><p>反过来，对于一个已分区的表添加唯一键，也只能添加分区表达式中使用的字段。</p><p>比如下面两张表：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t1 <span class="token punctuation">(</span>    col1 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    col2 <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    col3 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    col4 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>col1<span class="token punctuation">,</span> col2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> <span class="token keyword">HASH</span><span class="token punctuation">(</span>col3<span class="token punctuation">)</span>PARTITIONS <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t2 <span class="token punctuation">(</span>    col1 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    col2 <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    col3 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    col4 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>col1<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>col3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> <span class="token keyword">HASH</span><span class="token punctuation">(</span>col1 <span class="token operator">+</span> col3<span class="token punctuation">)</span>PARTITIONS <span class="token number">4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>都不能成功。第一个：分区使用的字段<code>col3</code>不在唯一键中；第二个：虽然<code>col1</code>和<code>col3</code>都是唯一键，但是不同时在所有的唯一键中。</p><p>这样就可以了：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t1 <span class="token punctuation">(</span>    col1 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    col2 <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    col3 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    col4 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>col1<span class="token punctuation">,</span> col2<span class="token punctuation">,</span> col3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> <span class="token keyword">HASH</span><span class="token punctuation">(</span>col3<span class="token punctuation">)</span>PARTITIONS <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t2 <span class="token punctuation">(</span>    col1 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    col2 <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    col3 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    col4 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>col1<span class="token punctuation">,</span> col3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> <span class="token keyword">HASH</span><span class="token punctuation">(</span>col1 <span class="token operator">+</span> col3<span class="token punctuation">)</span>PARTITIONS <span class="token number">4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>着对于<code>PRIMARY KEY</code>来说是一样的。</p><p>如果表没有自定义的唯一键的话，那么就没有这个唯一键的限制了，任何满足分区要求的字段都可以使用。</p><p>反过来，如果一张表已经分区了，添加唯一键的时候也要满足这个限制。比如下面的分区表：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t_no_pk <span class="token punctuation">(</span><span class="token number">c1</span> <span class="token keyword">INT</span><span class="token punctuation">,</span> <span class="token number">c2</span> <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE<span class="token punctuation">(</span><span class="token number">c1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要添加下面的主键：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> t_no_pk <span class="token keyword">ADD</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token number">c1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>没问题。因为这个主键<code>c1</code>就是分区表达式使用的字段。</p><p>但下面这个就不成功了：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> t_no_pk <span class="token keyword">ADD</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token number">c2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会给出这个错误：</p><pre class="line-numbers language-shell"><code class="language-shell">ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the table's partitioning function<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-2-分区表达式支持的函数"><a href="#6-2-分区表达式支持的函数" class="headerlink" title="6.2 分区表达式支持的函数"></a>6.2 分区表达式支持的函数</h3><p>MySQL中，只有下面列出的函数支持在分区表达式中使用：</p><table><thead><tr><th>函数</th><th>含义</th><th>函数</th><th>含义</th></tr></thead><tbody><tr><td><code>ABS(x)</code></td><td>返回<code>x</code>的绝对值</td><td><code>MOD(N, M)</code></td><td>返回<code>N%M</code></td></tr><tr><td><code>CEILING(x)</code></td><td>返回不小于<code>x</code>的最小整数</td><td><code>MONTH(x)</code></td><td>返回<code>x</code>的月份（1到12）</td></tr><tr><td><code>DATEDIFF(x, y)</code></td><td>返回<code>x</code>和<code>y</code>之间的日期差</td><td><code>QUARTER(x)</code></td><td>返回<code>x</code>的季度（1到4）</td></tr><tr><td><code>DAY(x)</code></td><td>和<code>DAYOFMONTH(X)</code>一样</td><td><code>SECOND(x)</code></td><td>返回<code>x</code>的秒数（0到59）</td></tr><tr><td><code>DAYOFMONTH(x)</code></td><td>返回日期<code>x</code>当前月的第几天（1到31）</td><td><code>TIME_TO_SEC(seconds)</code></td><td>将给定的秒数转成<code>HH:MM:SS</code>的格式</td></tr><tr><td><code>DAYOFWEEK(x)</code></td><td>返回星期，周日是1，周一是2，周六是7</td><td><code>TO_DAYS(x)</code></td><td>给定一个日期，返回总天数（从公元算起）</td></tr><tr><td><code>DAYOFYEAR(x)</code></td><td>返回日期x当前年的第几天（1到366）</td><td><code>TO_SECONDS(x)</code></td><td>给定一个日期，返回总秒数（从公元算起）</td></tr><tr><td><code>EXTRACT(x)</code></td><td>从给定的日期中返回指定的格式</td><td><code>UNIX_TIMESTAMP(x)</code></td><td>返回给定日期的时间戳</td></tr><tr><td><code>FLOOR(x)</code></td><td>返回不大于<code>x</code>的最大整数</td><td><code>WEEKDAY(x)</code></td><td>返回星期（和<code>DAYOFWEEK()</code>不一样，这里周一是0，周日是6）</td></tr><tr><td><code>HOUR(x)</code></td><td>返回时间<code>x</code>的小时数（0到23）</td><td><code>YEAR(x)</code></td><td>返回给定日期的年份</td></tr><tr><td><code>MICROSECOND(x)</code></td><td>返回<code>x</code>的毫秒数（0到999）</td><td><code>YEARWEEK(x)</code></td><td>返回给定日期的周数（1到53）</td></tr><tr><td><code>MINUTE(x)</code></td><td>返回<code>x</code>的分钟数（0到59）</td><td></td><td></td></tr></tbody></table><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>最后，以我个人的经验来看，分区是数据库优化的最后一个步骤。对于需要处理大量的流水型数据来说，使用Range分区是很有用的。在使用分区之前，也需要考虑一下分区的限制，比如唯一索引的限制、不允许外键等。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> partition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>All You Need to Know About MySQL Partitions (Part 1)</title>
      <link href="/all-you-need-to-know-about-mysql-partitions-part-1/"/>
      <url>/all-you-need-to-know-about-mysql-partitions-part-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>什么是分区？为什么要分区？该怎么分区？分区有什么好处？使用分区应该注意什么？<a href="https://dev.mysql.com/doc/refman/8.0/en/partitioning.html" target="_blank" rel="noopener">通过对MySQL文档</a>的梳理，在这篇文章以及<a href="https://deuterium.fun/all-you-need-to-know-about-mysql-partitions-part-2/">Part 2</a>中详细介绍一下关于MySQL分区的方方面面。</p></blockquote><h2 id="1-Overview-of-Paritioning-in-MySQL"><a href="#1-Overview-of-Paritioning-in-MySQL" class="headerlink" title="1. Overview of Paritioning in MySQL"></a>1. Overview of Paritioning in MySQL</h2><p>数据库作为系统的重要部分，承担着数据的存储任务。随着业务的不断扩展，数据也可能疯狂增长。这个时候对于数据库的访问可能会有一些瓶颈。为了减小表的规模，可以将一张大表分成几个小的部分。一种方式就是分表，将一张表分成一系列表；另一种就是分区。</p><p>分区也是将一张大表分成几个小的部分，但和分表不同的是，分区仍然是一张表，只不过在一张表下面有一些小的分区：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/partition.png" alt="partition就是水平分区"></p><p>那么分区有什么好处呢？</p><ul><li>分区使得一张表可以存储的数据容量增大；</li><li>无用的数据通过删除分区的方式可以很方便地删除；</li><li>同样，对于新增数据，也可以很方便地添加分区来存储新数据；</li><li>使用分区之后，查询可以通过排除不可能的分区来减少待筛选数据的规模，减少查询时间。</li></ul><p>总之，对于一些应用场景来说，使用分区可以给系统带来很大的好处。</p><h2 id="2-Partitioning-Types"><a href="#2-Partitioning-Types" class="headerlink" title="2. Partitioning Types"></a>2. Partitioning Types</h2><h3 id="2-1-Overview"><a href="#2-1-Overview" class="headerlink" title="2.1 Overview"></a>2.1 Overview</h3><p>MySQL中的分区就是水平分区。为了将一张大表分成几个分区，首先就应该确定一个分区的方式，即对于一条记录来说，如何确定这条记录放在哪个分区。在MySQL中，有下面几种分区方式。</p><h3 id="2-2-RANGE-Partitioning"><a href="#2-2-RANGE-Partitioning" class="headerlink" title="2.2 RANGE Partitioning"></a>2.2 RANGE Partitioning</h3><p>Range分区，是根据指定字段的取值范围划定分区的，同一个分区包含同一个范围内的数据。分区范围应该是连续的并且不能有重合，这是显而易见的限制。如果不连续，那么就有可能有的记录找不到对应的分区；而有重叠的话，可能一条记录对应多个分区。</p><h4 id="2-2-1-一个简单的例子"><a href="#2-2-1-一个简单的例子" class="headerlink" title="2.2.1 一个简单的例子"></a>2.2.1 一个简单的例子</h4><p>比如下面的例子，一家有20个分店的连锁店需要一张员工表：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>    job_code <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    store_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>store_id</code>来区分分店，取值范围是[1, 20]。</p><p>那么就可以使用这个字段来对表划成四个分区：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>    job_code <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    store_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span>store_id<span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，分店ID是1到5的在<code>p0</code>分区，分店ID是6到10的在<code>p1</code>分区，依次类推。</p><p>对于一个给定的记录，是可以很容易确定对应的分区的。比如<code>(72, &#39;Mitchell&#39;, &#39;Wilson&#39;, &#39;1998-06-25&#39;, NULL, 13)</code>，分店ID是13，根据规则这条记录就在<code>p2</code>分区里。</p><p>但是现在有个问题，如果又开了一家分店，分店ID是21，那么新分店的员工记录应该在哪个分区呢？</p><p>按照上面的定义，这样会出错。因为MySQL找不到对应的分区。</p><p>为了解决这个问题，可以使用<code>MAXVALUE</code>：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>    job_code <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    store_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span>store_id<span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，所有分店ID大于15的记录都会被放在<code>p3</code>分区里。</p><p>不过，随着大于15的记录数越来越多，这样的分区方式可能会导致记录不均匀。可以通过<code>ALTER TABLE</code>来对表重新划分分区。</p><h4 id="2-2-2-更多的例子"><a href="#2-2-2-更多的例子" class="headerlink" title="2.2.2 更多的例子"></a>2.2.2 更多的例子</h4><p>除此之外，还有其他的分区方式。比如，根据员工离职的年份来进行分区：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>    job_code <span class="token keyword">INT</span><span class="token punctuation">,</span>    store_id <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span> YEAR<span class="token punctuation">(</span>separated<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1991</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1996</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">2001</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用<code>YEAR()</code>函数将一个<code>DATE</code>类型的数据转换成数字，然后根据范围进行分区。</p><p>还可以对一个<code>TIMESTAMP</code>类型的字段进行分区，使用<code>UNIX_TIMESTAMP()</code>函数：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> quarterly_report_status <span class="token punctuation">(</span>    report_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    report_status <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    report_updated <span class="token keyword">TIMESTAMP</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span>report_updated<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-01-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-04-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-07-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-10-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p4 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-01-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p5 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-04-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p6 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-07-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p7 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-10-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p8 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2010-01-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p9 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-3-Range分区的适用场景"><a href="#2-2-3-Range分区的适用场景" class="headerlink" title="2.2.3 Range分区的适用场景"></a>2.2.3 Range分区的适用场景</h4><p>Range分区适用于下面的场景：</p><ul><li>需要时不时地删除旧数据。比如如果使用上面根据离职年份分区，想要删除所有1991年前离职的员工，可以直接<code>ALTER TABLE employees DROP PARTITION p0;</code>。这比使用<code>DELETE</code>有效多了。</li><li>想使用日期或时间类型的字段，以及以其他方式递增的类型的字段。比如各种统计数据，每天一次。</li><li>经常对分区字段进行查询。比如经常就<code>store_id</code>字段进行查询，如果使用分区的话，MySQL会快速地知道需要对哪些分区的数据进行查询。这在有很多数据的表中很有用。</li></ul><p>需要注意的是，Range分区对范围的划分是基于数字类型的，其它类型的范围不支持（比如字符串，也可以有一个范围）。</p><h3 id="2-3-LIST-Partitioning"><a href="#2-3-LIST-Partitioning" class="headerlink" title="2.3 LIST Partitioning"></a>2.3 LIST Partitioning</h3><p>List分区和Range分区有很多相似的地方。和Range分区一样，每一个List分区必须显式定义出来。两者的主要不同在于，Range分区是根据一个连续且不重叠的范围进行划分的，而List分区是根据一个可选集合划分的，不需要连续，但需要不重叠。</p><p>还以上面员工的例子为例：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>    job_code <span class="token keyword">INT</span><span class="token punctuation">,</span>    store_id <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假如一共有20家连锁店，按区位分布如下：</p><table><thead><tr><th>Region</th><th>Store ID Numbers</th></tr></thead><tbody><tr><td>North</td><td>3, 5, 6, 9, 17</td></tr><tr><td>East</td><td>1, 2, 10, 11, 19, 20</td></tr><tr><td>West</td><td>4, 12, 13, 14, 18</td></tr><tr><td>Central</td><td>7, 8, 15, 16</td></tr></tbody></table><p>这样如果想把在同一个区位的所有分店的员工记录放在一个分区里的话，使用Range分区是实现不了的，因为分区的定义是不连续的。不过可以使用List分区：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>    job_code <span class="token keyword">INT</span><span class="token punctuation">,</span>    store_id <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> LIST<span class="token punctuation">(</span>store_id<span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> pNorth <span class="token keyword">VALUES</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> pEast <span class="token keyword">VALUES</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> pWest <span class="token keyword">VALUES</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> pCentral <span class="token keyword">VALUES</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就可以将所有在一个区位的所有记录放在一个分区里了，如果想要删除一个区位下的所有记录的话，就可以直接使用<code>ALTER TABLE employees TRUNCATE PARTITION pWest</code>来删除。</p><p>如果插入一条<code>store_id</code>不在定义中的记录的话，那么插入就会失败。同时，如果在一条<code>INSERT</code>语句中插入多条记录，其中有一条记录的<code>store_id</code>不在定义中的话，那么所有的插入都失败，即使其他的合法。</p><p>为了让合法的能成功，可以使用<code>IGNORE</code>：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">IGNORE</span> <span class="token keyword">INTO</span> h2 <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>List分区使用的分区字段需要是数字类型或者能通过函数转换成数字类型，分区定义中的可选值不能是别的类型（比如字符串）。</p><h3 id="2-4-COLUMNS-Partitioning"><a href="#2-4-COLUMNS-Partitioning" class="headerlink" title="2.4 COLUMNS Partitioning"></a>2.4 COLUMNS Partitioning</h3><p>Columns分区是Range分区和List分区的变型。Range分区和List分区使用一个字段的取值来决定将数据存在哪个分区，同时字段的类型需要是数字类型的（或能转换成数字类型的比如日期和时间）。但是Columns分区使用多个字段，来决定记录放在哪个分区中。</p><p>同时，字段的类型也不局限于数字类型，还可以使用字符串类型：</p><ul><li>所有的数字类型：<code>TINYINT</code>, <code>SMALLINT</code>, <code>MEDIUMINT</code>, <code>INT(INTEGER)</code>和<code>BIGINT</code>（和Range分区与List分区一样），不过对<code>DECIMAL</code>和<code>FLOAT</code>类型不支持；</li><li>日期和时间类型：<code>DATE</code>和<code>DATETIME</code>；</li><li>字符串类型：<code>CHAR</code>, <code>VARCHAR</code>, <code>BINARY</code>, <code>VARBINARY</code>，不过对<code>TEXT</code>和<code>BLOB</code>不支持。</li></ul><h4 id="2-4-1-RANGE-COLUMNS-Partitioning"><a href="#2-4-1-RANGE-COLUMNS-Partitioning" class="headerlink" title="2.4.1  RANGE COLUMNS Partitioning"></a>2.4.1  RANGE COLUMNS Partitioning</h4><p>Range columns分区和Range分区类似，支持使用多个字段确定分区，同时除了整数类型字段外还支持字符串类型。此外，两者的另一个区别在于，Range分区可以对字段使用一个表达式，比如<code>year(birthday)</code>，而Range columns分区不支持，只能使用字段名。</p><p>使用Range columns的基本格式如下：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> table_namePARTITIONED <span class="token keyword">BY</span> RANGE <span class="token keyword">COLUMNS</span><span class="token punctuation">(</span>column_list<span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> partition_name <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>value_list<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> partition_name <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>value_list<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span>column_list:    column_name<span class="token punctuation">[</span><span class="token punctuation">,</span> column_name<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>value_list:    <span class="token keyword">value</span><span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token keyword">value</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义中使用<code>column_list</code>表示分区定义使用的所有字段列表，<code>value_list</code>列出了每个分区对应字段的取值，对于每一个分区，都要有一个<code>value_list</code>。</p><p>同时<code>column_list</code>的元素个数需要和<code>value_list</code>一致，这样才能对每个字段都确定一个取值的范围；而且，<code>column_list</code>中的字段顺序要和<code>value_list</code>中的取值一一对应。</p><p>和Range分区一样，这里我们也可以使用<code>MAXVALUE</code>来标识最大值。</p><p>一个简单的例子：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> rcx <span class="token punctuation">(</span>    <span class="token number">a</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token number">b</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token number">c</span> CHAR<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token number">d</span> <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token keyword">COLUMNS</span><span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">,</span><span class="token number">d</span><span class="token punctuation">,</span><span class="token number">c</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'ggg'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token string">'mmm'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token string">'sss'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">,</span>MAXVALUE<span class="token punctuation">,</span>MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，表<code>rcx</code>有四个字段，使用了其中的三个来定义分区，在分区定义中每个对每个字段都确定了范围。</p><p>由于使用多个字段来确定分区，所以Range columns决定一条记录的具体分区和Range分区不太一样。在Range分区中，表达式得到的结果如果在分区范围的边界上，那么这条记录是不会放在对应的分区里的（比如<code>PARTITION p0 LESS THAN (5)</code>，如果对应的值刚好是5的话，就不会放在<code>p0</code>里了，会放在下一个分区中）。不过，在Range columns分区中就不太一样了，因为Range columns分区是对多元组（tuple）进行比较的，而不是简单的标量值。</p><p>对于一个下面定义的Range分区表来说：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> r1 <span class="token punctuation">(</span>    <span class="token number">a</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token number">b</span> <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们插入三条记录：<code>(5, 10), (5, 11), (5, 12)</code>，对具体分区起作用的是字段<code>a</code>，所以只比较<code>a</code>的值就可以了。由于这三天记录的<code>a</code>值都大于5，所以这三条记录都放在<code>p1</code>中。</p><p>我们可以使用下面的查询语句来查看一张表中每个分区的记录数：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> PARTITION_NAME<span class="token punctuation">,</span>TABLE_ROWS <span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span>PARTITIONS <span class="token keyword">WHERE</span> TABLE_NAME <span class="token operator">=</span> <span class="token string">'r1'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>好的，让我们来看看下面的Range columns的例子：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> rc1 <span class="token punctuation">(</span>    <span class="token number">a</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token number">b</span> <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token keyword">COLUMNS</span><span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">,</span> <span class="token number">b</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">,</span> MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用两个字段<code>a</code>和<code>b</code>来确定分区。这时，对于给定的记录来说，比较的就不是一个简单的标量值了，而是一个二元组。</p><p>同样，如果我们插入这样的三条记录：<code>(5, 10), (5, 11), (5, 12)</code>，那么每条记录会放在哪个分区呢？</p><p>首先可以使用MySQL的client来比较一下这些二元组：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们的分区定义范围的界线是<code>(5, 12)</code>，所以需要将所有待插入的记录去和这个二元组比较。结果如下：</p><pre class="line-numbers language-shell"><code class="language-shell">+-----------------+-----------------+-----------------+| (5,10) < (5,12) | (5,11) < (5,12) | (5,12) < (5,12) |+-----------------+-----------------+-----------------+|               1 |               1 |               0 |+-----------------+-----------------+-----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，前两条记录会放在<code>p0</code>中，后一条放在<code>p1</code>中。这个例子展示了Range columns分区和Range分区对于确定分区的方式的不同。</p><p>不过，如果Range columns分区只使用一个字段，那么分区的确定方式就和Range分区一致了。</p><p>不过为啥只有一个字段来决定分区不使用Range分区而使用Range columns分区呢？这是因为，Range columns支持字符串。比如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees_by_lname <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>    job_code <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    store_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token keyword">COLUMNS</span> <span class="token punctuation">(</span>lname<span class="token punctuation">)</span>  <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token string">'g'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token string">'m'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token string">'t'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果表已经有定义了，可以使用<code>alter table</code>来创建分区：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> employees <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token keyword">COLUMNS</span> <span class="token punctuation">(</span>lname<span class="token punctuation">)</span>  <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token string">'g'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token string">'m'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token string">'t'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于是比较多元组来决定分区，因此Range columns分区的范围界线中，一个或多个字段的界限值可以是一样的，只要能保证分区定义的多元组是严格递增的：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> rc2 <span class="token punctuation">(</span>    <span class="token number">a</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token number">b</span> <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token keyword">COLUMNS</span><span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">,</span><span class="token number">b</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">,</span>MAXVALUE<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> rc3 <span class="token punctuation">(</span>    <span class="token number">a</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token number">b</span> <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token keyword">COLUMNS</span><span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">,</span><span class="token number">b</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p4 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p5 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">,</span>MAXVALUE<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两个表的分区定义，都是合法的。</p><p>来看看这个定义：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> rc4 <span class="token punctuation">(</span>    <span class="token number">a</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token number">b</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token number">c</span> <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token keyword">COLUMNS</span><span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">,</span><span class="token number">b</span><span class="token punctuation">,</span><span class="token number">c</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">,</span>MAXVALUE<span class="token punctuation">,</span>MAXVALUE<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>乍一看好像不合法，但确实是合法的。我们可以对这些界线多元组进行比较：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果都为1。说明这三个三元组是严格递增的，所以可以在定义中使用。</p><p>但是下面这个就不合法了：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> rcf <span class="token punctuation">(</span>    <span class="token number">a</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token number">b</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token number">c</span> <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token keyword">COLUMNS</span><span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">,</span><span class="token number">b</span><span class="token punctuation">,</span><span class="token number">c</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">,</span>MAXVALUE<span class="token punctuation">,</span>MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样可是使用上面的判断方式，结果<code>(20,20,100)</code>并不小于<code>(10,30,50)</code>。</p><p>那MySQL到底是怎么比较多元组的呢？我猜测是，按照多元组从左到右的顺序进行，比如<code>(a1,a2,a3)</code>和<code>(b1,b2,b3)</code>，先比较下标是1的，如果<code>a1&lt;b1</code>，那么<code>(a1,a2,a3) &lt; (b1,b2,b3)</code>；否则比较下标是2的，一次类推。</p><p>不知道对不对，欢迎打脸。</p><h4 id="2-4-2-LIST-COLUMNS-Partitioning"><a href="#2-4-2-LIST-COLUMNS-Partitioning" class="headerlink" title="2.4.2 LIST COLUMNS Partitioning"></a>2.4.2 LIST COLUMNS Partitioning</h4><p>List columns分区与List分区的区别，和Range columns分区与Range分区的区别是一样的。即，List columns分区可以使用多个字段，也可以使用字符串类型的字段。比如下面的一个分区定义：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> customers_1 <span class="token punctuation">(</span>    first_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    last_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    street_1 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    street_2 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    city <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    renewal <span class="token keyword">DATE</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> LIST <span class="token keyword">COLUMNS</span><span class="token punctuation">(</span>city<span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> pRegion_1 <span class="token keyword">VALUES</span> <span class="token operator">IN</span><span class="token punctuation">(</span><span class="token string">'Oskarshamn'</span><span class="token punctuation">,</span> <span class="token string">'Högsby'</span><span class="token punctuation">,</span> <span class="token string">'Mönsterås'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> pRegion_2 <span class="token keyword">VALUES</span> <span class="token operator">IN</span><span class="token punctuation">(</span><span class="token string">'Vimmerby'</span><span class="token punctuation">,</span> <span class="token string">'Hultsfred'</span><span class="token punctuation">,</span> <span class="token string">'Västervik'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> pRegion_3 <span class="token keyword">VALUES</span> <span class="token operator">IN</span><span class="token punctuation">(</span><span class="token string">'Nässjö'</span><span class="token punctuation">,</span> <span class="token string">'Eksjö'</span><span class="token punctuation">,</span> <span class="token string">'Vetlanda'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> pRegion_4 <span class="token keyword">VALUES</span> <span class="token operator">IN</span><span class="token punctuation">(</span><span class="token string">'Uppvidinge'</span><span class="token punctuation">,</span> <span class="token string">'Alvesta'</span><span class="token punctuation">,</span> <span class="token string">'Växjo'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将同一个区位的几个城市的记录放在一个分区中，这样的定义List分区是实现不了的。</p><h3 id="2-5-HASH-Partitioning"><a href="#2-5-HASH-Partitioning" class="headerlink" title="2.5 HASH Partitioning"></a>2.5 HASH Partitioning</h3><p>前面介绍的Range分区和List分区，以及两者的变型，需要我们手动指定分区的规则。而在Hash分区中，我们只需要指定Hash操作的字段以及划分的分区数就可以了，MySQL会自动计算每条记录所属的分区。</p><h4 id="2-5-1-普通HASH-Partitioning"><a href="#2-5-1-普通HASH-Partitioning" class="headerlink" title="2.5.1 普通HASH Partitioning"></a>2.5.1 普通HASH Partitioning</h4><p>Hash分区的一个主要用途是将所有的数据均匀分配到给定数量的分区中，以此来将一个表可容纳的记录数增加。</p><p>一个简单的例子：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>    job_code <span class="token keyword">INT</span><span class="token punctuation">,</span>    store_id <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> <span class="token keyword">HASH</span><span class="token punctuation">(</span>store_id<span class="token punctuation">)</span>PARTITIONS <span class="token number">4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用<code>store_id</code>字段计算Hash，一共划分成四个分区。如果不指定<code>PARTITIONS 4</code>的话，默认就是一个分区。</p><p>也可以使用一个表达式：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>    job_code <span class="token keyword">INT</span><span class="token punctuation">,</span>    store_id <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> <span class="token keyword">HASH</span><span class="token punctuation">(</span> YEAR<span class="token punctuation">(</span>hired<span class="token punctuation">)</span> <span class="token punctuation">)</span>PARTITIONS <span class="token number">4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用的字段需要是整数类型，或者表达式返回一个整数类型。</p><p>Hash分区使用<code>mod</code>来计算。比如上面这个例子，如果一条记录的<code>YEAR(hired)</code>值是2020，那么对应的分区就是：</p><pre class="line-numbers language-shell"><code class="language-shell">MOD(2020, 4) = 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-5-2-LINER-HASH-Partitioning"><a href="#2-5-2-LINER-HASH-Partitioning" class="headerlink" title="2.5.2 LINER HASH Partitioning"></a>2.5.2 LINER HASH Partitioning</h4><p>Liner Hash分区和Hash分区的不同在于Hash的计算方式，Liner Hash分区使用线性二次幂算法，而Hash分区使用的是取模。</p><p>两者定义的区别也很简单：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>    job_code <span class="token keyword">INT</span><span class="token punctuation">,</span>    store_id <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> LINEAR <span class="token keyword">HASH</span><span class="token punctuation">(</span> YEAR<span class="token punctuation">(</span>hired<span class="token punctuation">)</span> <span class="token punctuation">)</span>PARTITIONS <span class="token number">4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给定一条记录，可以通过下面的算法得到这条记录存储在哪个分区（<code>num</code>表示总分区数，<code>N</code>表示具体的分区）。</p><ol><li>找到下一个大于大于<code>num</code>2次幂的数记作<code>V</code>；</li><li>令<code>N = F(column_list) &amp; (V-1)</code>；</li><li><code>while N&gt;=num</code>:<ul><li>令<code>V = V/2</code>；</li><li>令<code>N = N &amp; (V-1)</code>。</li></ul></li></ol><p>一个简单的例子：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t1 <span class="token punctuation">(</span>col1 <span class="token keyword">INT</span><span class="token punctuation">,</span> col2 CHAR<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> col3 <span class="token keyword">DATE</span><span class="token punctuation">)</span>    <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> LINEAR <span class="token keyword">HASH</span><span class="token punctuation">(</span> YEAR<span class="token punctuation">(</span>col3<span class="token punctuation">)</span> <span class="token punctuation">)</span>    PARTITIONS <span class="token number">6</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>分区数<code>num=6</code>，加入两条待插入记录的<code>col3</code>分别是<code>2003-04-14</code>和<code>1998-10-19</code>，那么对于第一个：</p><pre class="line-numbers language-shell"><code class="language-shell">V = POWER(2, CEILING( LOG(2,6) )) = 8N = YEAR('2003-04-14') & (8 - 1)   = 2003 & 7   = 3(3 >= 6 is FALSE: record stored in partition #3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于第二个：</p><pre class="line-numbers language-shell"><code class="language-shell">V = 8N = YEAR('1998-10-19') & (8 - 1)  = 1998 & 7  = 6(6 >= 6 is TRUE: additional step required)N = 6 & ((8 / 2) - 1)  = 6 & 3  = 2(2 >= 6 is FALSE: record stored in partition #2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相比Hash分区，Liner Hash分区的优点在于，添加、删除、合并和分裂分区很快，尤其是数据量很大的时候。缺点在于，它不像Hash分区那样数据分布均匀。</p><h3 id="2-6-KEY-Partitioning"><a href="#2-6-KEY-Partitioning" class="headerlink" title="2.6 KEY Partitioning"></a>2.6 KEY Partitioning</h3><p>Key分区和Hash分区类似，只不过Hash分区是用户自定义了一个表达式，而Key分区是MySQL自己实现的表达式，在NDB存储引擎中，使用的是<code>md5()</code>。</p><p>一个简单的例子：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> k1 <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>    name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token punctuation">)</span>PARTITIONS <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里<code>KEY()</code>没有指定具体的值，那么就使用主键，即<code>id</code>。如果没有主键有唯一键的话，就使用唯一键：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> k1 <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span><span class="token punctuation">)</span>PARTITIONS <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面两个例子使用的都是字段<code>id</code>。</p><p>不过，如果唯一键没有指定为<code>NOT NULL</code>，就会定义失败。</p><p>也可以使用字符串类型：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> tm1 <span class="token punctuation">(</span>    s1 CHAR<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span>PARTITIONS <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用Key分区，那么定义中使用的键就不能删除了，不然会出错。</p><p>像Hash分区一样，Key分区也可以指定Liner：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> tk <span class="token punctuation">(</span>    col1 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    col2 CHAR<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    col3 <span class="token keyword">DATE</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> LINEAR <span class="token keyword">KEY</span> <span class="token punctuation">(</span>col1<span class="token punctuation">)</span>PARTITIONS <span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，Liner Key分区就和Liner Hash分区类似了，优缺点也一样。</p><h3 id="2-7-子分区：Subpartitioning"><a href="#2-7-子分区：Subpartitioning" class="headerlink" title="2.7 子分区：Subpartitioning"></a>2.7 子分区：Subpartitioning</h3><p>子分区也叫做复合分区，就是将分区表的分区继续分区。比如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> ts <span class="token punctuation">(</span>id <span class="token keyword">INT</span><span class="token punctuation">,</span> purchased <span class="token keyword">DATE</span><span class="token punctuation">)</span>    <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE<span class="token punctuation">(</span> YEAR<span class="token punctuation">(</span>purchased<span class="token punctuation">)</span> <span class="token punctuation">)</span>    SUBPARTITION <span class="token keyword">BY</span> <span class="token keyword">HASH</span><span class="token punctuation">(</span> TO_DAYS<span class="token punctuation">(</span>purchased<span class="token punctuation">)</span> <span class="token punctuation">)</span>    SUBPARTITIONS <span class="token number">2</span> <span class="token punctuation">(</span>        <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1990</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN MAXVALUE    <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个表使用的是Range分区，一共有三个Range分区，其中对于每个分区又使用Hash分区方式分成两个子分区，这样一共有6个子分区。</p><p>只有Range分区和List分区能够继续划分子分区，并且子分区的分区方式是Hash分区或Key分区。</p><p>子分区定义如果使用Hash分区或Key分区的话，那么具体的格式和Hash分区与Key分区类似，不同在于Key分区，子分区如果使用Key分区的话需要指定使用的键。</p><p>在定义中也可以对每个子分区定义子分区的名字：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> ts <span class="token punctuation">(</span>id <span class="token keyword">INT</span><span class="token punctuation">,</span> purchased <span class="token keyword">DATE</span><span class="token punctuation">)</span>    <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE<span class="token punctuation">(</span> YEAR<span class="token punctuation">(</span>purchased<span class="token punctuation">)</span> <span class="token punctuation">)</span>    SUBPARTITION <span class="token keyword">BY</span> <span class="token keyword">HASH</span><span class="token punctuation">(</span> TO_DAYS<span class="token punctuation">(</span>purchased<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>        <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1990</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>            SUBPARTITION s0<span class="token punctuation">,</span>            SUBPARTITION s1        <span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>            SUBPARTITION s2<span class="token punctuation">,</span>            SUBPARTITION s3        <span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN MAXVALUE <span class="token punctuation">(</span>            SUBPARTITION s4<span class="token punctuation">,</span>            SUBPARTITION s5        <span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过要注意，如果要定义的话，需要把所有的子分区的名字都定义了，同时不能有重复的子分区名字，即使两个子分区不在同一个分区下。</p><h3 id="2-8-MySQL分区如何处理NULL值"><a href="#2-8-MySQL分区如何处理NULL值" class="headerlink" title="2.8 MySQL分区如何处理NULL值"></a>2.8 MySQL分区如何处理NULL值</h3><p>分区中可以使用NULL值，在MySQL中，NULL值小于任何一个非NULL值。在不同的分区方式中，对于NULL值的处理是不同的。</p><h4 id="2-8-1-RANGE分区"><a href="#2-8-1-RANGE分区" class="headerlink" title="2.8.1 RANGE分区"></a>2.8.1 RANGE分区</h4><p>如果决定分区的字段可以为NULL值，那么对于这样的记录存在最小的那个分区里。比如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t2 <span class="token punctuation">(</span>    <span class="token number">c1</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token number">c2</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE<span class="token punctuation">(</span><span class="token number">c1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN MAXVALUE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果插入一条<code>c1=null</code>的记录，那么这条记录存在<code>p0</code>中。</p><p>对于使用MySQL函数的分区，也是这么处理NULL值的。比如<code>YEAR(NULL)=NULL</code>，然后存在最小的那个分区里。</p><h4 id="2-8-2-LIST分区"><a href="#2-8-2-LIST分区" class="headerlink" title="2.8.2 LIST分区"></a>2.8.2 LIST分区</h4><p>List分区可以接受NULL值，只要分区定义中给定了NULL值存储的分区即可。如果这样：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> ts1 <span class="token punctuation">(</span>    <span class="token number">c1</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token number">c2</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> LIST<span class="token punctuation">(</span><span class="token number">c1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么插入一条<code>c1=null</code>的记录不会成功。如果这样：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> ts2 <span class="token punctuation">(</span>    <span class="token number">c1</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token number">c2</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> LIST<span class="token punctuation">(</span><span class="token number">c1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么对于所有<code>c1=null</code>的记录都将存在<code>p3</code>中。</p><h4 id="2-8-3-HASH分区和KEY分区"><a href="#2-8-3-HASH分区和KEY分区" class="headerlink" title="2.8.3 HASH分区和KEY分区"></a>2.8.3 HASH分区和KEY分区</h4><p>Hash分区和Key分区对于NULL的处理是将NULL当做0。比如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> th <span class="token punctuation">(</span>    <span class="token number">c1</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>    <span class="token number">c2</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> <span class="token keyword">HASH</span><span class="token punctuation">(</span><span class="token number">c1</span><span class="token punctuation">)</span>PARTITIONS <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么对于<code>c1=null</code>的记录将放在分区ID是0的分区里，和<code>c1=0</code>，<code>c1=2</code>效果一样。对于Key分区也是一样。</p><p>关于MySQL分区其余的部分，参考<a href="https://deuterium.fun/all-you-need-to-know-about-mysql-partitions-part-2/">Part 2</a>。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> partition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Roman Empire</title>
      <link href="/roman-empire/"/>
      <url>/roman-empire/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是根据假期看的《罗马人的故事》记录的罗马流水线的第二部分：罗马帝国。罗马帝国从27BC开始到467AD西罗马帝国灭亡共500年的历史，不包括东罗马帝国（拜占庭帝国）。</p></blockquote><h2 id="1-尤利乌斯·克劳狄乌斯王朝（27BC-68AD）"><a href="#1-尤利乌斯·克劳狄乌斯王朝（27BC-68AD）" class="headerlink" title="1. 尤利乌斯·克劳狄乌斯王朝（27BC-68AD）"></a>1. 尤利乌斯·克劳狄乌斯王朝（27BC-68AD）</h2><p>凯撒绘制了罗马元首制的蓝图。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/1.%E5%B0%A4%E5%88%A9%E4%B9%8C%E6%96%AF-%E5%85%8B%E5%8A%B3%E7%8B%84%E4%B9%8C%E6%96%AF%E7%8E%8B%E6%9C%9D.png" alt="尤利乌斯-克劳狄乌斯王朝"></p><h3 id="1-1-屋大维（27BC0116-14AD0819）"><a href="#1-1-屋大维（27BC0116-14AD0819）" class="headerlink" title="1.1 屋大维（27BC0116-14AD0819）"></a>1.1 屋大维（27BC0116-14AD0819）</h3><p>后三头之一</p><p>凯撒养子</p><p>建立近卫军</p><p>在位时间最长的皇帝</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%85%AC%E5%85%8314%E5%B9%B4%E7%9A%84%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD.png" alt="公元14年的罗马帝国"></p><h3 id="1-2-提比略（14-0918-37-0316）"><a href="#1-2-提比略（14-0918-37-0316）" class="headerlink" title="1.2 提比略（14.0918-37.0316）"></a>1.2 提比略（14.0918-37.0316）</h3><p>北方防线退回莱茵河</p><p>隐退卡普里岛</p><h3 id="1-3-卡利古拉（37-0318-41-0124）"><a href="#1-3-卡利古拉（37-0318-41-0124）" class="headerlink" title="1.3 卡利古拉（37.0318-41.0124）"></a>1.3 卡利古拉（37.0318-41.0124）</h3><p>日尔曼尼库斯的儿子，“小军靴”</p><p>残暴</p><h3 id="1-4-克劳狄乌斯（41-0124-54-1013）"><a href="#1-4-克劳狄乌斯（41-0124-54-1013）" class="headerlink" title="1.4 克劳狄乌斯（41.0124-54.1013）"></a>1.4 克劳狄乌斯（41.0124-54.1013）</h3><p>出兵不列颠</p><p>克劳狄乌斯港</p><h3 id="1-5-尼禄（54-1013-68-0609）"><a href="#1-5-尼禄（54-1013-68-0609）" class="headerlink" title="1.5 尼禄（54.1013-68.0609）"></a>1.5 尼禄（54.1013-68.0609）</h3><p>弑母</p><p>罗马大火</p><p>与帕提亚的和平</p><p>记录抹杀刑</p><h2 id="2-四帝内乱时期（68-69）"><a href="#2-四帝内乱时期（68-69）" class="headerlink" title="2. 四帝内乱时期（68-69）"></a>2. 四帝内乱时期（68-69）</h2><p>尼禄被元老院定为全民公敌，南法高卢总督起兵造反兵败被杀。近西班牙行省总督加尔巴被推举为皇帝，四帝内乱时期开始。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/2.%E5%9B%9B%E5%B8%9D%E5%86%85%E4%B9%B1%E6%97%B6%E6%9C%9F.png" alt="四帝内乱时期"></p><h3 id="2-1-加尔巴（68-0618-69-0115）"><a href="#2-1-加尔巴（68-0618-69-0115）" class="headerlink" title="2.1 加尔巴（68.0618-69.0115）"></a>2.1 加尔巴（68.0618-69.0115）</h3><p>近西班牙行省总督</p><h3 id="2-2-奥托（69-0115-69-0415）"><a href="#2-2-奥托（69-0115-69-0415）" class="headerlink" title="2.2 奥托（69.0115-69.0415）"></a>2.2 奥托（69.0115-69.0415）</h3><p>远西班牙行省总督</p><h3 id="2-3-维特里乌斯（69-0416-69-1220）"><a href="#2-3-维特里乌斯（69-0416-69-1220）" class="headerlink" title="2.3 维特里乌斯（69.0416-69.1220）"></a>2.3 维特里乌斯（69.0416-69.1220）</h3><p>日耳曼军团指挥官</p><h3 id="2-4-韦斯帕芗（69-0701-79-0623）"><a href="#2-4-韦斯帕芗（69-0701-79-0623）" class="headerlink" title="2.4 韦斯帕芗（69.0701-79.0623）"></a>2.4 韦斯帕芗（69.0701-79.0623）</h3><p>军人皇帝</p><h2 id="3-弗拉维王朝（69-96）"><a href="#3-弗拉维王朝（69-96）" class="headerlink" title="3. 弗拉维王朝（69-96）"></a>3. 弗拉维王朝（69-96）</h2><p>韦斯帕芗成为四帝内乱时期唯一的皇帝，开创了弗拉维王朝。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/3.%E5%BC%97%E6%8B%89%E7%BB%B4%E7%8E%8B%E6%9C%9D.png" alt="弗拉维王朝"></p><h3 id="3-1-韦斯帕芗（69-0701-79-0623）"><a href="#3-1-韦斯帕芗（69-0701-79-0623）" class="headerlink" title="3.1 韦斯帕芗（69.0701-79.0623）"></a>3.1 韦斯帕芗（69.0701-79.0623）</h3><p>犹太战争</p><h3 id="3-2-提图斯（79-0624-81-0913）"><a href="#3-2-提图斯（79-0624-81-0913）" class="headerlink" title="3.2 提图斯（79.0624-81.0913）"></a>3.2 提图斯（79.0624-81.0913）</h3><p>在位两年天灾不断</p><p>庞培古城</p><h3 id="3-3-图密善（81-0914-96-0918）"><a href="#3-3-图密善（81-0914-96-0918）" class="headerlink" title="3.3 图密善（81.0914-96.0918）"></a>3.3 图密善（81.0914-96.0918）</h3><p>被刺杀</p><p>记录抹杀刑</p><h2 id="4-安敦尼王朝（96-192）"><a href="#4-安敦尼王朝（96-192）" class="headerlink" title="4. 安敦尼王朝（96-192）"></a>4. 安敦尼王朝（96-192）</h2><p>图密善被刺杀后，涅尔瓦被推举为皇帝。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/4.%E5%AE%89%E6%95%A6%E5%B0%BC%E7%8E%8B%E6%9C%9D.png" alt="安敦尼王朝"></p><h3 id="4-1-涅尔瓦（96-0919-98-0127）"><a href="#4-1-涅尔瓦（96-0919-98-0127）" class="headerlink" title="4.1 涅尔瓦（96.0919-98.0127）"></a>4.1 涅尔瓦（96.0919-98.0127）</h3><p>养子继承制</p><h3 id="4-2-图拉真（98-0127-117-0809）"><a href="#4-2-图拉真（98-0127-117-0809）" class="headerlink" title="4.2 图拉真（98.0127-117.0809）"></a>4.2 图拉真（98.0127-117.0809）</h3><p>罗马帝国的鼎盛时期</p><p>征服达契亚</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD%E5%85%A8%E7%9B%9B%E6%97%B6%E6%9C%9F.png" alt="全盛时期的罗马帝国"></p><h3 id="4-3-哈德良（117-0809-138-0710）"><a href="#4-3-哈德良（117-0809-138-0710）" class="headerlink" title="4.3 哈德良（117.0809-138.0710）"></a>4.3 哈德良（117.0809-138.0710）</h3><p>“哈德良长城”</p><p>日耳曼长城，连接多瑙河防线和莱茵河防线</p><h3 id="4-4-安敦尼·庇护（138-0710-161-0307）"><a href="#4-4-安敦尼·庇护（138-0710-161-0307）" class="headerlink" title="4.4 安敦尼·庇护（138.0710-161.0307）"></a>4.4 安敦尼·庇护（138.0710-161.0307）</h3><p>帝国的鼎盛期</p><h3 id="4-5-马可·奥勒留（161-0308-180-0317）"><a href="#4-5-马可·奥勒留（161-0308-180-0317）" class="headerlink" title="4.5 马可·奥勒留（161.0308-180.0317）"></a>4.5 马可·奥勒留（161.0308-180.0317）</h3><p>“哲学家皇帝”</p><p>死于日耳曼前线</p><h3 id="4-6-康茂德（180-0317-192-1231）"><a href="#4-6-康茂德（180-0317-192-1231）" class="headerlink" title="4.6 康茂德（180.0317-192.1231）"></a>4.6 康茂德（180.0317-192.1231）</h3><p>“角斗士皇帝”</p><p>被暗杀</p><p>记录抹杀刑</p><h2 id="5-五帝之年（193）"><a href="#5-五帝之年（193）" class="headerlink" title="5. 五帝之年（193）"></a>5. 五帝之年（193）</h2><p>康茂德被刺杀后，内乱开始。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/5.%E4%BA%94%E5%B8%9D%E4%B9%8B%E5%B9%B4.png" alt="五帝之年"></p><h3 id="5-1-佩提纳克斯（193-0101-193-0328）"><a href="#5-1-佩提纳克斯（193-0101-193-0328）" class="headerlink" title="5.1 佩提纳克斯（193.0101-193.0328）"></a>5.1 佩提纳克斯（193.0101-193.0328）</h3><p>近卫军长官雷特拥立佩提纳克斯为皇帝。</p><p>后因没满足条件被雷特刺杀。</p><h3 id="5-2-狄第乌斯·尤利安（193-0328-193-0601）"><a href="#5-2-狄第乌斯·尤利安（193-0328-193-0601）" class="headerlink" title="5.2 狄第乌斯·尤利安（193.0328-193.0601）"></a>5.2 狄第乌斯·尤利安（193.0328-193.0601）</h3><p>尤利安和佩提纳克斯的岳父弗拉维斯·斯皮切努斯在近卫军面前竞价成功，被近卫军推举为皇帝。</p><p>塞维鲁进军意大利后被近卫军刺杀。</p><h3 id="5-3-赛普提米乌斯·塞维鲁（193-0411-211-0204）"><a href="#5-3-赛普提米乌斯·塞维鲁（193-0411-211-0204）" class="headerlink" title="5.3 赛普提米乌斯·塞维鲁（193.0411-211.0204）"></a>5.3 赛普提米乌斯·塞维鲁（193.0411-211.0204）</h3><p>近潘诺尼亚行省总督塞维鲁被军团兵推举为皇帝。</p><h3 id="5-4-克劳狄乌斯·亚尔比努斯"><a href="#5-4-克劳狄乌斯·亚尔比努斯" class="headerlink" title="5.4 克劳狄乌斯·亚尔比努斯"></a>5.4 克劳狄乌斯·亚尔比努斯</h3><p>不列颠总督，塞维鲁的共治皇帝。</p><p>尼戈失败后，与塞维鲁战争失败被杀。</p><h3 id="5-5-培辛尼乌斯·尼戈"><a href="#5-5-培辛尼乌斯·尼戈" class="headerlink" title="5.5 培辛尼乌斯·尼戈"></a>5.5 培辛尼乌斯·尼戈</h3><p>叙利亚总督，与塞维鲁争夺帝位失败被杀。</p><h2 id="6-塞维鲁王朝（193-235）"><a href="#6-塞维鲁王朝（193-235）" class="headerlink" title="6. 塞维鲁王朝（193-235）"></a>6. 塞维鲁王朝（193-235）</h2><p>五帝之年唯一胜利者赛普提米乌斯·塞维鲁开创了塞维鲁王朝。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/6.%E5%A1%9E%E7%BB%B4%E9%B2%81%E7%8E%8B%E6%9C%9D.png" alt="塞维鲁王朝"></p><h3 id="6-1-塞维鲁（193-0411-211-0204）"><a href="#6-1-塞维鲁（193-0411-211-0204）" class="headerlink" title="6.1 塞维鲁（193.0411-211.0204）"></a>6.1 塞维鲁（193.0411-211.0204）</h3><p>罗马政权军事化的始作俑者。</p><p>东征帕提亚，征服美索不达米亚。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E4%B8%89%E4%B8%96%E7%BA%AA%E5%88%9D%E7%9A%84%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD.png" alt="三世纪初的罗马帝国"></p><h3 id="6-2-卡拉卡拉（211-0204-217-0408）"><a href="#6-2-卡拉卡拉（211-0204-217-0408）" class="headerlink" title="6.2 卡拉卡拉（211.0204-217.0408）"></a>6.2 卡拉卡拉（211.0204-217.0408）</h3><p>安东尼努斯敕令：帝国全境都成为罗马公民</p><p>杀死弟弟盖塔</p><h3 id="6-3-马克里努斯（217-0411-218）"><a href="#6-3-马克里努斯（217-0411-218）" class="headerlink" title="6.3 马克里努斯（217.0411-218）"></a>6.3 马克里努斯（217.0411-218）</h3><p>与帕提亚媾和，放弃美索不达米亚。</p><p>没有进入罗马的皇帝。</p><h3 id="6-4-埃拉伽巴路斯（218-0516-222-0311）"><a href="#6-4-埃拉伽巴路斯（218-0516-222-0311）" class="headerlink" title="6.4 埃拉伽巴路斯（218.0516-222.0311）"></a>6.4 埃拉伽巴路斯（218.0516-222.0311）</h3><p>第一位出身于叙利亚的皇帝。</p><p>被谋杀。</p><h3 id="6-5-亚历山大·塞维鲁（222-0311-235-0318）"><a href="#6-5-亚历山大·塞维鲁（222-0311-235-0318）" class="headerlink" title="6.5 亚历山大·塞维鲁（222.0311-235.0318）"></a>6.5 亚历山大·塞维鲁（222.0311-235.0318）</h3><p>日耳曼战争中被马克西米努斯杀死。</p><h2 id="7-危机时代（235-268）"><a href="#7-危机时代（235-268）" class="headerlink" title="7. 危机时代（235-268）"></a>7. 危机时代（235-268）</h2><p>亚历山大死后，帝国危机达到高潮。下面列出主要的皇帝，一些共治皇帝没有列出来。</p><h3 id="7-1-马克西米努斯（235-238）"><a href="#7-1-马克西米努斯（235-238）" class="headerlink" title="7.1 马克西米努斯（235-238）"></a>7.1 马克西米努斯（235-238）</h3><p>第一位蛮族出身的皇帝（色雷斯人）。</p><h3 id="7-2-戈尔迪安一世（238-0322-238-0412）"><a href="#7-2-戈尔迪安一世（238-0322-238-0412）" class="headerlink" title="7.2 戈尔迪安一世（238.0322-238.0412）"></a>7.2 戈尔迪安一世（238.0322-238.0412）</h3><p>北非行省总督</p><p>支持马克西米努斯的努米底亚总督造反。</p><p>戈尔迪安一世上吊自杀。</p><h3 id="7-3-戈尔迪安二世（238-0322-238-0412）"><a href="#7-3-戈尔迪安二世（238-0322-238-0412）" class="headerlink" title="7.3 戈尔迪安二世（238.0322-238.0412）"></a>7.3 戈尔迪安二世（238.0322-238.0412）</h3><p>戈尔迪安一世的儿子</p><p>战死</p><h3 id="7-4-普皮恩努斯（238）"><a href="#7-4-普皮恩努斯（238）" class="headerlink" title="7.4 普皮恩努斯（238）"></a>7.4 普皮恩努斯（238）</h3><p>元老院推举的皇帝</p><p>被近卫军杀死</p><h3 id="7-5-巴尔比努斯（238）"><a href="#7-5-巴尔比努斯（238）" class="headerlink" title="7.5 巴尔比努斯（238）"></a>7.5 巴尔比努斯（238）</h3><p>元老院推举的皇帝</p><p>被近卫军杀死</p><h3 id="7-6-戈尔迪安三世（238-244）"><a href="#7-6-戈尔迪安三世（238-244）" class="headerlink" title="7.6 戈尔迪安三世（238-244）"></a>7.6 戈尔迪安三世（238-244）</h3><p>戈尔迪安二世的儿子</p><p>被近卫军杀死</p><h3 id="7-7-阿拉伯人菲利普（244-249）"><a href="#7-7-阿拉伯人菲利普（244-249）" class="headerlink" title="7.7 阿拉伯人菲利普（244-249）"></a>7.7 阿拉伯人菲利普（244-249）</h3><p>庆祝罗马建国1000周年</p><p>与德基乌斯的帝位之争失败后自杀</p><p>记录抹杀刑</p><h3 id="7-8-德基乌斯（249-251）"><a href="#7-8-德基乌斯（249-251）" class="headerlink" title="7.8 德基乌斯（249-251）"></a>7.8 德基乌斯（249-251）</h3><p>第一位与蛮族的战争中战死的罗马皇帝（哥特人）</p><h3 id="7-9-加卢斯（251-253）"><a href="#7-9-加卢斯（251-253）" class="headerlink" title="7.9 加卢斯（251-253）"></a>7.9 加卢斯（251-253）</h3><p>远米西亚行省总督</p><p>与哥特人媾和</p><p>被谋杀</p><h3 id="7-10-瓦勒良（253-260）"><a href="#7-10-瓦勒良（253-260）" class="headerlink" title="7.10 瓦勒良（253-260）"></a>7.10 瓦勒良（253-260）</h3><p>第一个被俘的罗马皇帝（波斯萨珊王朝）</p><h3 id="7-11-加里恩努斯（253-268）"><a href="#7-11-加里恩努斯（253-268）" class="headerlink" title="7.11 加里恩努斯（253-268）"></a>7.11 加里恩努斯（253-268）</h3><p>瓦勒良的儿子</p><p>263年高卢独立成立高卢帝国</p><p>帝国三分</p><h2 id="8-伊利里亚诸帝（268-284）"><a href="#8-伊利里亚诸帝（268-284）" class="headerlink" title="8. 伊利里亚诸帝（268-284）"></a>8. 伊利里亚诸帝（268-284）</h2><p>下面的几个皇帝来自于伊利里亚（巴尔干半岛西北部）。</p><h3 id="8-1-克劳狄乌斯二世（268-270）"><a href="#8-1-克劳狄乌斯二世（268-270）" class="headerlink" title="8.1 克劳狄乌斯二世（268-270）"></a>8.1 克劳狄乌斯二世（268-270）</h3><p>战胜哥特人</p><p>死于瘟疫</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E4%B8%89%E5%88%86%E7%9A%84%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD.png" alt="三分的罗马帝国 公元270年左右"></p><h3 id="8-2-奥勒良（270-275）"><a href="#8-2-奥勒良（270-275）" class="headerlink" title="8.2 奥勒良（270-275）"></a>8.2 奥勒良（270-275）</h3><p>重新统一罗马</p><p>塞尔维乌斯城墙被凯撒推翻后，奥勒良重新建造了奥勒良城墙。</p><p>271年，放弃达契亚。</p><p>被谋杀</p><h3 id="8-3-克劳狄乌斯·塔西佗（275-276）"><a href="#8-3-克劳狄乌斯·塔西佗（275-276）" class="headerlink" title="8.3 克劳狄乌斯·塔西佗（275-276）"></a>8.3 克劳狄乌斯·塔西佗（275-276）</h3><p>历史学家塔西佗的后裔</p><p>病死</p><h3 id="8-4-普罗布斯（276-282）"><a href="#8-4-普罗布斯（276-282）" class="headerlink" title="8.4 普罗布斯（276-282）"></a>8.4 普罗布斯（276-282）</h3><p>克劳狄乌斯·塔西佗的同母异父的弟弟</p><p>数次战胜蛮族入侵</p><p>被谋杀</p><h3 id="8-5-卡鲁斯（282-283）"><a href="#8-5-卡鲁斯（282-283）" class="headerlink" title="8.5 卡鲁斯（282-283）"></a>8.5 卡鲁斯（282-283）</h3><p>东征波斯</p><p>遭雷击而死</p><h3 id="8-6-努梅里安（282-283）"><a href="#8-6-努梅里安（282-283）" class="headerlink" title="8.6 努梅里安（282-283）"></a>8.6 努梅里安（282-283）</h3><p>卡鲁斯的儿子</p><p>卡鲁斯死后被谋杀</p><h3 id="8-7-卡里努斯（282-284）"><a href="#8-7-卡里努斯（282-284）" class="headerlink" title="8.7 卡里努斯（282-284）"></a>8.7 卡里努斯（282-284）</h3><p>卡鲁斯的儿子</p><p>被谋杀</p><h2 id="9-四帝共治（284-337）"><a href="#9-四帝共治（284-337）" class="headerlink" title="9. 四帝共治（284-337）"></a>9. 四帝共治（284-337）</h2><p>从戴克里先开始，罗马帝国由元首制变为绝对君主制。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%9B%9B%E5%B8%9D%E5%85%B1%E6%B2%BB.png" alt="四帝共治"></p><h3 id="9-1-戴克里先（284-1120-305-0501）"><a href="#9-1-戴克里先（284-1120-305-0501）" class="headerlink" title="9.1 戴克里先（284.1120-305.0501）"></a>9.1 戴克里先（284.1120-305.0501）</h3><p>结束了三世纪危机，开启四帝共治制度。</p><p>公元305年退位。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E4%B8%89%E4%B8%96%E7%BA%AA%E6%9C%AB%E7%9A%84%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD.png" alt="三世纪末的罗马帝国"></p><h3 id="9-2-马克西米安（286-305）"><a href="#9-2-马克西米安（286-305）" class="headerlink" title="9.2 马克西米安（286-305）"></a>9.2 马克西米安（286-305）</h3><p>首轮四帝共治的西方正帝</p><p>镇压高卢起义</p><p>自杀</p><h3 id="9-3-伽列里乌斯（305-311）"><a href="#9-3-伽列里乌斯（305-311）" class="headerlink" title="9.3 伽列里乌斯（305-311）"></a>9.3 伽列里乌斯（305-311）</h3><p>第一轮四帝共治的东方副帝</p><p>第二轮四帝共治的东方正帝</p><p>病死</p><h3 id="9-4-君士坦提乌斯一世（305-306）"><a href="#9-4-君士坦提乌斯一世（305-306）" class="headerlink" title="9.4 君士坦提乌斯一世（305-306）"></a>9.4 君士坦提乌斯一世（305-306）</h3><p>第一轮四帝共治的西方副帝</p><p>第二轮四帝共治的西方正帝</p><p>死于不列颠</p><h3 id="9-5-塞维鲁二世（306-307）"><a href="#9-5-塞维鲁二世（306-307）" class="headerlink" title="9.5 塞维鲁二世（306-307）"></a>9.5 塞维鲁二世（306-307）</h3><p>君士坦提乌斯一世死后成为西方正帝</p><p>讨伐马克森提乌斯时自杀</p><h3 id="9-6-马克森提乌斯（306-312）"><a href="#9-6-马克森提乌斯（306-312）" class="headerlink" title="9.6 马克森提乌斯（306-312）"></a>9.6 马克森提乌斯（306-312）</h3><p>马克西米安的儿子，自立为帝</p><p>米里维桥战役失败</p><h3 id="9-7-李锡尼（308-324）"><a href="#9-7-李锡尼（308-324）" class="headerlink" title="9.7 李锡尼（308-324）"></a>9.7 李锡尼（308-324）</h3><p>塞维鲁二世死后任西方正帝</p><p>后与君士坦丁一世的斗争中失败</p><h3 id="9-8-马克西米努斯·代亚（310-313）"><a href="#9-8-马克西米努斯·代亚（310-313）" class="headerlink" title="9.8 马克西米努斯·代亚（310-313）"></a>9.8 马克西米努斯·代亚（310-313）</h3><p>第二轮四帝共治的东方副帝</p><p>战败自杀</p><h3 id="9-9-君士坦丁一世（307-337）"><a href="#9-9-君士坦丁一世（307-337）" class="headerlink" title="9.9 君士坦丁一世（307-337）"></a>9.9 君士坦丁一世（307-337）</h3><p>第二轮四帝共治的西方副帝</p><p>成为唯一的皇帝</p><h2 id="10-君士坦丁王朝（307-364）"><a href="#10-君士坦丁王朝（307-364）" class="headerlink" title="10. 君士坦丁王朝（307-364）"></a>10. 君士坦丁王朝（307-364）</h2><p>经过多年的内战，君士坦丁一世成为唯一的皇帝。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/7.%E5%90%9B%E5%A3%AB%E5%9D%A6%E4%B8%81%E7%8E%8B%E6%9C%9D.png" alt="君士坦丁王朝"></p><h3 id="10-1-君士坦丁一世（307-337）"><a href="#10-1-君士坦丁一世（307-337）" class="headerlink" title="10.1 君士坦丁一世（307-337）"></a>10.1 君士坦丁一世（307-337）</h3><p>米兰敕令：承认基督教</p><p>建设新首都君士坦丁堡</p><p>第一个皈依基督教的罗马皇帝</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%90%9B%E5%A3%AB%E5%9D%A6%E4%B8%81%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BA%BA%E4%BA%8B%E5%9B%BE.png" alt="君士坦丁的继承人事图"></p><h3 id="10-2-君士坦提乌斯二世（337-361）"><a href="#10-2-君士坦提乌斯二世（337-361）" class="headerlink" title="10.2 君士坦提乌斯二世（337-361）"></a>10.2 君士坦提乌斯二世（337-361）</h3><p>君士坦丁一世的儿子</p><p>杀害多名亲属</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%85%AC%E5%85%83%E5%9B%9B%E4%B8%96%E7%BA%AA%E4%B8%AD%E5%8F%B6%E7%9A%84%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD.png" alt="公元四世纪中叶的罗马帝国"></p><h3 id="10-3-尤利安（361-363）"><a href="#10-3-尤利安（361-363）" class="headerlink" title="10.3 尤利安（361-363）"></a>10.3 尤利安（361-363）</h3><p>“叛教者尤利安”</p><p>斯特拉斯堡大捷</p><p>远征波斯战死</p><h3 id="10-4-约维安（363-364）"><a href="#10-4-约维安（363-364）" class="headerlink" title="10.4 约维安（363-364）"></a>10.4 约维安（363-364）</h3><p>尤利安的近卫队长，尤利安死后成为皇帝，与波斯缔结合约后暴毙。</p><p>全面推翻尤利安的政策。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%9B%9B%E4%B8%96%E7%BA%AA%E5%90%8E%E6%9C%9F%E8%9B%AE%E6%97%8F%E7%9A%84%E5%88%86%E5%B8%83%E5%92%8C%E5%85%A5%E4%BE%B5%E8%B7%AF%E7%BA%BF.png" alt="四世纪后期蛮族的分布和入侵路线"></p><h2 id="11-瓦伦提尼安王朝（364-392）"><a href="#11-瓦伦提尼安王朝（364-392）" class="headerlink" title="11. 瓦伦提尼安王朝（364-392）"></a>11. 瓦伦提尼安王朝（364-392）</h2><p>约维安死后，瓦伦提尼安成为皇帝，开始了瓦伦提尼安王朝。</p><h3 id="11-1-瓦伦提尼安一世（364-375）"><a href="#11-1-瓦伦提尼安一世（364-375）" class="headerlink" title="11.1 瓦伦提尼安一世（364-375）"></a>11.1 瓦伦提尼安一世（364-375）</h3><p>纯血统的蛮族人</p><h3 id="11-2-瓦伦斯（364-378）"><a href="#11-2-瓦伦斯（364-378）" class="headerlink" title="11.2 瓦伦斯（364-378）"></a>11.2 瓦伦斯（364-378）</h3><p>允许西哥特人入境居住</p><p>378年在与西哥特人的战争中战死（哈德良堡战役）</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%93%88%E5%BE%B7%E8%89%AF%E5%A0%A1%E6%88%98%E5%BD%B9%E5%90%8E%E7%9A%84%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD.png" alt="哈德良堡战役后的罗马帝国"></p><h3 id="11-3-格拉提安（375-383）"><a href="#11-3-格拉提安（375-383）" class="headerlink" title="11.3 格拉提安（375-383）"></a>11.3 格拉提安（375-383）</h3><p>哈德良堡战役后任命狄奥多西为东方皇帝</p><p>被谋杀</p><h3 id="11-4-瓦伦提尼安二世（375-392）"><a href="#11-4-瓦伦提尼安二世（375-392）" class="headerlink" title="11.4 瓦伦提尼安二世（375-392）"></a>11.4 瓦伦提尼安二世（375-392）</h3><p>被谋杀</p><h2 id="12-狄奥多西王朝（379-423）"><a href="#12-狄奥多西王朝（379-423）" class="headerlink" title="12. 狄奥多西王朝（379-423）"></a>12. 狄奥多西王朝（379-423）</h2><p>哈德良堡战役后，格拉提安任命狄奥多西为东方皇帝（这里没有列出东罗马帝国的皇帝）。</p><h3 id="12-1-狄奥多西一世（379-395）"><a href="#12-1-狄奥多西一世（379-395）" class="headerlink" title="12.1 狄奥多西一世（379-395）"></a>12.1 狄奥多西一世（379-395）</h3><p>统一罗马</p><p>宣布基督教为国教</p><p>公元393年废止奥运会</p><p>分裂罗马帝国</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%9B%9B%E4%B8%96%E7%BA%AA%E6%9C%AB%E7%9A%84%E8%9B%AE%E6%97%8F%E5%85%A5%E4%BE%B5.png" alt="四世纪末的蛮族入侵"></p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%85%AC%E5%85%83395%E5%B9%B4%E4%B8%9C%E8%A5%BF%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD%E7%9A%84%E5%88%86%E8%A3%82.png" alt="公元395年东西罗马帝国的分裂"></p><h3 id="12-2-霍诺里乌斯（395-423）"><a href="#12-2-霍诺里乌斯（395-423）" class="headerlink" title="12.2 霍诺里乌斯（395-423）"></a>12.2 霍诺里乌斯（395-423）</h3><p>西罗马帝国皇帝，狄奥多西一世的儿子</p><p>公元410年第一次罗马浩劫</p><p>失去不列颠</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%85%AC%E5%85%83410%E5%B9%B4%E7%9A%84%E8%A5%BF%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD%E4%B8%8E%E8%9B%AE%E6%97%8F.png" alt="公元410年的西罗马帝国与蛮族"></p><h2 id="13-最后的挣扎（423-476）"><a href="#13-最后的挣扎（423-476）" class="headerlink" title="13. 最后的挣扎（423-476）"></a>13. 最后的挣扎（423-476）</h2><p>霍诺里乌斯死后皇帝由外甥瓦伦提尼安三世继承，但是当时瓦伦提尼安三世太小，真正的统治是在425年开始的。</p><h3 id="13-1-瓦伦提尼安三世（425-455）"><a href="#13-1-瓦伦提尼安三世（425-455）" class="headerlink" title="13.1 瓦伦提尼安三世（425-455）"></a>13.1 瓦伦提尼安三世（425-455）</h3><p>被谋杀</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E4%BA%94%E4%B8%96%E7%BA%AA%E4%B8%AD%E5%8F%B6%E7%9A%84%E8%A5%BF%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD.png" alt="五世纪中叶的西罗马帝国"></p><h3 id="13-2-佩特罗尼乌斯·马克西穆斯（455）"><a href="#13-2-佩特罗尼乌斯·马克西穆斯（455）" class="headerlink" title="13.2 佩特罗尼乌斯·马克西穆斯（455）"></a>13.2 佩特罗尼乌斯·马克西穆斯（455）</h3><p>第二次罗马浩劫</p><p>被谋杀</p><h3 id="13-3-阿维图斯（455-456）"><a href="#13-3-阿维图斯（455-456）" class="headerlink" title="13.3 阿维图斯（455-456）"></a>13.3 阿维图斯（455-456）</h3><p>蛮族推荐的皇帝</p><p>被谋杀</p><h3 id="13-4-马约里安（457-461）"><a href="#13-4-马约里安（457-461）" class="headerlink" title="13.4 马约里安（457-461）"></a>13.4 马约里安（457-461）</h3><p>被谋杀</p><h3 id="13-5-塞维鲁（461-465）"><a href="#13-5-塞维鲁（461-465）" class="headerlink" title="13.5 塞维鲁（461-465）"></a>13.5 塞维鲁（461-465）</h3><p>傀儡皇帝</p><p>被谋杀</p><p>之后皇位空余两年</p><h3 id="13-6-安特米乌斯（467-472）"><a href="#13-6-安特米乌斯（467-472）" class="headerlink" title="13.6 安特米乌斯（467-472）"></a>13.6 安特米乌斯（467-472）</h3><p>东罗马帝国安排的皇帝</p><h3 id="13-7-奥利布里乌斯（472）"><a href="#13-7-奥利布里乌斯（472）" class="headerlink" title="13.7 奥利布里乌斯（472）"></a>13.7 奥利布里乌斯（472）</h3><p>病死</p><h3 id="13-8-格里希里乌斯（473-474）"><a href="#13-8-格里希里乌斯（473-474）" class="headerlink" title="13.8 格里希里乌斯（473-474）"></a>13.8 格里希里乌斯（473-474）</h3><p>退位</p><h3 id="13-9-尤利乌斯·尼波斯（474-475）"><a href="#13-9-尤利乌斯·尼波斯（474-475）" class="headerlink" title="13.9 尤利乌斯·尼波斯（474-475）"></a>13.9 尤利乌斯·尼波斯（474-475）</h3><p>东罗马帝国安排的皇帝</p><p>退位</p><h3 id="13-10-罗慕路斯·奥古斯都（475-476）"><a href="#13-10-罗慕路斯·奥古斯都（475-476）" class="headerlink" title="13.10 罗慕路斯·奥古斯都（475-476）"></a>13.10 罗慕路斯·奥古斯都（475-476）</h3><p>末代皇帝</p><p>被蛮族首领奥多亚克废黜</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%85%AC%E5%85%83500%E5%B9%B4%E5%89%8D%E5%90%8E%E7%9A%84%E5%8E%9F%E8%A5%BF%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD.png" alt="公元500年前后的原西罗马帝国"></p>]]></content>
      
      
      <categories>
          
          <category> reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> history </tag>
            
            <tag> rome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Roman Republic</title>
      <link href="/roman-republic/"/>
      <url>/roman-republic/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于疫情，有了一个漫长的假期。不玩游戏不看电影不追剧，看书成了唯一的消遣。十几天的时间看完了盐野七生的15卷本《罗马人的故事》，对古罗马的脉络有了一个大体的了解。在这篇文章中，对罗马王政时期和共和国时期的历史做一下简单的梳理。</p></blockquote><h2 id="1-王政时期（753BC-509BC）"><a href="#1-王政时期（753BC-509BC）" class="headerlink" title="1. 王政时期（753BC-509BC）"></a>1. 王政时期（753BC-509BC）</h2><h3 id="1-1-建国之王：罗慕路斯（753BC-716BC）"><a href="#1-1-建国之王：罗慕路斯（753BC-716BC）" class="headerlink" title="1.1. 建国之王：罗慕路斯（753BC-716BC）"></a>1.1. 建国之王：罗慕路斯（753BC-716BC）</h3><p>杀死弟弟瑞摩斯成为罗马唯一的王。</p><p>台伯河：发源于亚平宁山脉，全长300多公里。自罗马向前流经约30公里，经过奥斯提亚注入地中海。</p><p>罗马七山丘：</p><ul><li>奎里尔诺山</li><li>维弥纳山</li><li>埃斯奎利山</li><li>卡匹托尔山</li><li>西里欧山</li><li>阿文庭山</li></ul><p>建国纪念日：公元前753年4月21日。</p><p>国王、元老院和市民大会</p><p>国王：宗教祭祀、军事和政治的最高领导人，由市民大会投票选举产生。</p><p>元老院：不是政府官职，向国王提出忠告和建议，不需要通过市民大会的选举，100人。</p><p>市民大会：全体罗马市民。选出国王和各级政府官员，没有制定政策的权力，但是对国王听取元老院的建议后制定出来的政策有赞成和反对的表决权力。对外关系的战和也需要征得市民大会的同意。</p><p>和萨宾的四次战争。</p><p>同化萨宾人。</p><h3 id="1-2-努马（716BC-672BC）"><a href="#1-2-努马（716BC-672BC）" class="headerlink" title="1.2. 努马（716BC-672BC）"></a>1.2. 努马（716BC-672BC）</h3><p>战神雅努斯神殿</p><p>宗教改革</p><p>罗马众神：</p><ul><li>诸神之王朱庇特</li><li>其妻朱诺女神（幸福婚姻和妇女的保护神）</li><li>美和爱的女神维纳斯</li><li>狩猎女神戴安娜</li><li>学问和艺术之神阿波罗</li><li>智慧女神雅典娜</li><li>战神马尔斯（雅努斯呢？）</li><li>谷物女神克瑞斯</li><li>酒神巴克斯</li><li>商业旅行保护神墨丘利</li><li>医神阿斯克勒庇俄斯</li><li>维里普拉卡女神（调解夫妻矛盾的保护神）</li><li>协和女神</li></ul><h3 id="1-3-托里斯·奥斯蒂吕斯（672BC-642BC）"><a href="#1-3-托里斯·奥斯蒂吕斯（672BC-642BC）" class="headerlink" title="1.3. 托里斯·奥斯蒂吕斯（672BC-642BC）"></a>1.3. 托里斯·奥斯蒂吕斯（672BC-642BC）</h3><p>攻占阿鲁巴，拉丁民族的大本营。</p><h3 id="1-4-安库斯·马尔西乌斯（642BC-616BC）"><a href="#1-4-安库斯·马尔西乌斯（642BC-616BC）" class="headerlink" title="1.4. 安库斯·马尔西乌斯（642BC-616BC）"></a>1.4. 安库斯·马尔西乌斯（642BC-616BC）</h3><p>托里斯女婿、努马外孙，萨宾人。</p><p>建造台伯河上第一座桥。</p><p>征服了奥斯提亚，罗马有了港口。</p><h3 id="1-5-塔克文·普利斯库斯（616BC-578BC）"><a href="#1-5-塔克文·普利斯库斯（616BC-578BC）" class="headerlink" title="1.5. 塔克文·普利斯库斯（616BC-578BC）"></a>1.5. 塔克文·普利斯库斯（616BC-578BC）</h3><p>增加元老院人数到200人。</p><p>被先王安库斯的两个儿子暗杀。</p><h3 id="1-6-塞尔维乌斯·图利乌斯（578BC-543BC）"><a href="#1-6-塞尔维乌斯·图利乌斯（578BC-543BC）" class="headerlink" title="1.6. 塞尔维乌斯·图利乌斯（578BC-543BC）"></a>1.6. 塞尔维乌斯·图利乌斯（578BC-543BC）</h3><p>先王塔克文的养子。</p><p>没有经过市民大会的选举，只通过元老院的决议就登上了王位。</p><p>罗马城墙：塞尔维乌斯城墙。</p><p>罗马选举制不是一人一票制，按军团的最小单位百人队一票。</p><p>被女儿图里亚杀死。</p><h3 id="1-7-最后的国王：傲慢者塔克文（543BC-509BC）"><a href="#1-7-最后的国王：傲慢者塔克文（543BC-509BC）" class="headerlink" title="1.7. 最后的国王：傲慢者塔克文（543BC-509BC）"></a>1.7. 最后的国王：傲慢者塔克文（543BC-509BC）</h3><p>第五代国王的儿子，先王塞尔维乌斯的女婿，妻子图里亚。</p><p>没有市民大会的选举，也没有元老院的同意。</p><p>儿子赛克斯图斯侮辱了科拉提努斯的妻子琉克蕾西亚，琉克蕾西亚自杀。</p><p>被罗马人民驱逐。</p><h2 id="2-罗马共和国（509BC-27BC）"><a href="#2-罗马共和国（509BC-27BC）" class="headerlink" title="2. 罗马共和国（509BC-27BC）"></a>2. 罗马共和国（509BC-27BC）</h2><h3 id="2-1-共和政体的创始人：布鲁图斯"><a href="#2-1-共和政体的创始人：布鲁图斯" class="headerlink" title="2.1. 共和政体的创始人：布鲁图斯"></a>2.1. 共和政体的创始人：布鲁图斯</h3><p>509BC年第一位执政官。</p><p>执政官任期一年。</p><p>杀死参与王政复辟的两个儿子。</p><p>在和傲慢者塔克文的战争中战死。</p><h3 id="2-2-亲民者瓦莱利乌斯"><a href="#2-2-亲民者瓦莱利乌斯" class="headerlink" title="2.2. 亲民者瓦莱利乌斯"></a>2.2. 亲民者瓦莱利乌斯</h3><p>509BC年到503BC年担任四届执政官。</p><p>挫败塔克文和伊特鲁里亚联邦的丘西国王波塞纳的复辟计划。</p><h3 id="2-3-寡头政治下的贵族与平民的对立"><a href="#2-3-寡头政治下的贵族与平民的对立" class="headerlink" title="2.3. 寡头政治下的贵族与平民的对立"></a>2.3. 寡头政治下的贵族与平民的对立</h3><p>公元前494年，罗马与邻近部落的战争中，平民拒绝服兵役，平民运动。</p><p>独裁官任期六个月。</p><p>第二个独裁官，亲民者瓦莱利乌斯的弟弟，马尼乌斯。</p><p>设立护民官，由公民大会选举产生，两人。</p><p>公元前五世纪中叶，考察雅典。</p><p>454BC年，成立一个由贵族和平民组成的十人立法委员会。</p><p>451BC年，十人立法委员会颁布法典，刻在10个铜表上。</p><p>449BC年，新增两表，著名的《十二铜表法》。</p><p>445BC年，允许贵族和平民之间的通婚。</p><p>贵族保护人，平民被保护人。</p><h3 id="2-4-六人军事指挥官"><a href="#2-4-六人军事指挥官" class="headerlink" title="2.4. 六人军事指挥官"></a>2.4. 六人军事指挥官</h3><p>410BC年到360BC年，由六个军事指挥官取代两个执政官。</p><h3 id="2-5-高卢人的入侵"><a href="#2-5-高卢人的入侵" class="headerlink" title="2.5. 高卢人的入侵"></a>2.5. 高卢人的入侵</h3><p>凯尔特人是希腊人的称呼，罗马人叫做高卢人。</p><p>396BC年，独裁官马克斯·弗瑞耶斯·卡米卢斯经过十年战争，罗马消灭了伊特鲁里亚人的城市维爱，直接与凯尔特人接壤。</p><p>卡米卢斯五次担任独裁官，举行过四次凯旋仪式，被誉为仅次于罗慕路斯的罗马的第二个创建者。</p><p>390BC年，高卢人攻克罗马，占领七个月。</p><p>待解决问题：</p><ol><li>在注重防卫的同时，重建被毁的罗马；</li><li>与叛离的旧同盟各部族作战，以此确保边境安全；</li><li>消除贵族与平民之间的对立，实现社会安定和舆论统一。</li></ol><h3 id="2-6-政治改革"><a href="#2-6-政治改革" class="headerlink" title="2.6. 政治改革"></a>2.6. 政治改革</h3><p>367BC年，实施《李锡尼法》</p><ol><li>废除六人军事指挥官，恢复两人执政官。明确罗马实行寡头政治；</li><li>规定共和国政府的所有要职向平民出身的人开放。</li></ol><p>古罗马广场内的协和神殿，纪念《李锡尼法》的实施。</p><p>366BC年，第一个平民执政官。</p><p>356BC年，第一个平民独裁官。</p><p>351BC年，第一个平民财务官。</p><p>332BC年，第一个平民法务官。</p><p>322BC年，禁止因无法还清欠债而剥夺其人身自由。</p><p>287BC年，《霍腾休斯法》平民大会通过的决议可以成为国家的法令。</p><h3 id="2-7-罗马政体"><a href="#2-7-罗马政体" class="headerlink" title="2.7. 罗马政体"></a>2.7. 罗马政体</h3><p>公元前四世纪中叶，罗马的共和政体趋于完善。</p><h4 id="2-7-1-罗马的选举制"><a href="#2-7-1-罗马的选举制" class="headerlink" title="2.7.1. 罗马的选举制"></a>2.7.1. 罗马的选举制</h4><p>采用按照收入的多少纳税。</p><p>百人队构成一票。</p><p>市民大会的总投票数是193票，只要有97票就过半数。</p><p>只要第一等级意见一致，就控制了过半的票。</p><h4 id="2-7-2-执政官（Consul）"><a href="#2-7-2-执政官（Consul）" class="headerlink" title="2.7.2. 执政官（Consul）"></a>2.7.2. 执政官（Consul）</h4><p>市民大会选举产生，元老院批准后就职，任期一年，允许再选，年龄下限40岁，两人。</p><p>召开市民大会，内政的最高领导人。</p><p>也是军队的指挥官，前执政官。</p><p>12个刀斧手做开路先锋。</p><h4 id="2-7-3-独裁官（Dictator）"><a href="#2-7-3-独裁官（Dictator）" class="headerlink" title="2.7.3. 独裁官（Dictator）"></a>2.7.3. 独裁官（Dictator）</h4><p>国家处于非常紧急时期任命的官职，独裁官由两位执政官中的一个指定。</p><p>无权决定改变政体，任何问题上享有绝对的决定权。</p><p>一人，任期六个月。</p><p>24个刀斧手做开路先锋。</p><p>509BC年到390BC年，只任命过7位独裁官。</p><h4 id="2-7-4-法务官（Praetor）"><a href="#2-7-4-法务官（Praetor）" class="headerlink" title="2.7.4. 法务官（Praetor）"></a>2.7.4. 法务官（Praetor）</h4><p>任期一年，40岁以上。</p><p>最初1人，后逐渐扩增至16人。</p><p>除了执政官没有扩增外，其余几乎所有官职都扩增了。</p><p>执政官上前线时管理后方，后变为司法负责人。</p><p>执政官不在时，法务官担任议长，召集在首都罗马举行的市民大会。</p><h4 id="2-7-5-财务检察官（Quaestor）"><a href="#2-7-5-财务检察官（Quaestor）" class="headerlink" title="2.7.5. 财务检察官（Quaestor）"></a>2.7.5. 财务检察官（Quaestor）</h4><p>最初2人，共和末期增加到40人。</p><p>任期一年，30岁以上。</p><p>负责前线的财务。</p><h4 id="2-7-6-财务官（Censor）"><a href="#2-7-6-财务官（Censor）" class="headerlink" title="2.7.6. 财务官（Censor）"></a>2.7.6. 财务官（Censor）</h4><p>最初为人口调查而设，每五年进行一次人口调查选举一次。</p><p>任期一年半以上，两人。</p><p>仅次于执政官的权力。</p><h4 id="2-7-7-按察官（Aedilis）"><a href="#2-7-7-按察官（Aedilis）" class="headerlink" title="2.7.7. 按察官（Aedilis）"></a>2.7.7. 按察官（Aedilis）</h4><p>四人，贵族和平民各两人。</p><p>任期一年，30岁以上。</p><p>策划组织庆祝和祭祀活动；公共安全；保障粮食的供给；负责道路维修、交通整顿和上下水道管理；对各种违法行为作出罚款金额的决定；对市场进行严格监管；在共和末期担任向无产者无偿配送小麦。</p><h4 id="2-7-8-护民官（Tribunus-Plebis）"><a href="#2-7-8-护民官（Tribunus-Plebis）" class="headerlink" title="2.7.8. 护民官（Tribunus Plebis）"></a>2.7.8. 护民官（Tribunus Plebis）</h4><p>平民大会上产生（贵族也可以参加市民大会）。</p><p>任期一年，年龄没有限制，两人，后来增加到10人。</p><p>保护平民的权利，有权对征服所做的决定行使否决权，战时不可以。</p><p>护民官任期结束后，通常转为元老院议员。</p><h4 id="2-7-9-元老院（Senatus）"><a href="#2-7-9-元老院（Senatus）" class="headerlink" title="2.7.9. 元老院（Senatus）"></a>2.7.9. 元老院（Senatus）</h4><p>元老院以及罗马市民（SPQR）：Senatus, Populus, Que, Romanus</p><p>只有元老院议员不需要选举，任期终身。</p><h3 id="2-8-罗马联盟"><a href="#2-8-罗马联盟" class="headerlink" title="2.8. 罗马联盟"></a>2.8. 罗马联盟</h3><p>同盟国只需与罗马缔结协议，加盟国之间不可以。</p><p>338BC年成立。</p><h4 id="2-8-1-盟主罗马"><a href="#2-8-1-盟主罗马" class="headerlink" title="2.8.1 盟主罗马"></a>2.8.1 盟主罗马</h4><p>只要是自由民，部分贵族和平民，都有罗马市民权。有服兵役的义务。</p><p>享有投票权和被选举权，以及参与国政的权利。</p><h4 id="2-8-2-旧拉丁同盟的加盟国"><a href="#2-8-2-旧拉丁同盟的加盟国" class="headerlink" title="2.8.2 旧拉丁同盟的加盟国"></a>2.8.2 旧拉丁同盟的加盟国</h4><p>BC390年背离罗马之后又被罗马打败的国家。</p><p>与罗马有相同的语言、宗教和习俗。</p><p>完全的罗马市民权。</p><h4 id="2-8-3-自治城市"><a href="#2-8-3-自治城市" class="headerlink" title="2.8.3 自治城市"></a>2.8.3 自治城市</h4><p>无投票权的罗马市民权。</p><p>没有选举权和被选举权。</p><p>准罗马市民，三年后可以得到罗马市民权。</p><h4 id="2-8-4-殖民地"><a href="#2-8-4-殖民地" class="headerlink" title="2.8.4 殖民地"></a>2.8.4 殖民地</h4><p>只有被认为战略上非常重要的地方，罗马市民团才回开展殖民建设。是罗马殖民地。</p><p>具有完全的罗马市民权。</p><p>拉丁殖民地：罗马联盟其他加盟国的人民建设的殖民地。</p><h4 id="2-8-5-统称“同盟国”的国家"><a href="#2-8-5-统称“同盟国”的国家" class="headerlink" title="2.8.5 统称“同盟国”的国家"></a>2.8.5 统称“同盟国”的国家</h4><p>当时叫做“同盟市”。</p><p>350BC年以后被罗马打败的国家。</p><p>具有完全的国内自治，允许保留自己的语言、宗教和习俗。</p><p>只需要提供兵力。</p><h3 id="2-9-对意大利中南部的征服"><a href="#2-9-对意大利中南部的征服" class="headerlink" title="2.9 对意大利中南部的征服"></a>2.9 对意大利中南部的征服</h3><p>主要有意大利中南部山岳地带的萨莫奈人，和伊庇鲁斯国王皮洛士。</p><h4 id="2-9-1-萨莫奈人"><a href="#2-9-1-萨莫奈人" class="headerlink" title="2.9.1 萨莫奈人"></a>2.9.1 萨莫奈人</h4><p>第一次萨莫奈战争（343BC-341BC）</p><p>第二次萨莫奈战争（327BC-304BC）</p><p>321BC年考地乌姆耻辱</p><p>第三次萨莫奈战争（298BC-290BC）</p><p>北边高卢人、伊特鲁里亚人和翁布里亚人参战，南部萨莫奈人参战。</p><p>297BC年，昆图斯·费边第五次当选执政官，另一人是德西乌斯第四次当选（平民）。</p><h4 id="2-9-2-意大利南部希腊"><a href="#2-9-2-意大利南部希腊" class="headerlink" title="2.9.2 意大利南部希腊"></a>2.9.2 意大利南部希腊</h4><p>塔兰托和希腊北部的伊庇鲁斯国王皮洛士。</p><p>皮洛士战争（280BC-275BC）</p><p>272BC年，罗马攻陷塔兰托。</p><p>270BC年，完成卢孔比河以南意大利半岛的统一。</p><h3 id="2-10-布匿战争"><a href="#2-10-布匿战争" class="headerlink" title="2.10 布匿战争"></a>2.10 布匿战争</h3><p>罗马和迦太基争夺地中海霸权的战争。</p><h4 id="2-10-1-第一次布匿战争（264BC-241BC）"><a href="#2-10-1-第一次布匿战争（264BC-241BC）" class="headerlink" title="2.10.1 第一次布匿战争（264BC-241BC）"></a>2.10.1 第一次布匿战争（264BC-241BC）</h4><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B8%83%E5%8C%BF%E6%88%98%E4%BA%89%E5%89%8D%E7%9A%84%E7%BD%97%E9%A9%AC%E5%92%8C%E8%BF%A6%E5%A4%AA%E5%9F%BA.png" alt="第一次布匿战争前的罗马和迦太基"></p><p>288BC年，一群叙拉古雇佣兵占领墨西拿。</p><p>265BC年，叙拉古国王希伦二世出兵墨西拿驱逐雇佣兵。</p><p>265BC年，墨西拿向罗马求救。</p><p>264BC年，第一次布匿战争开始。</p><p>262BC年，阿格里真托战役。</p><p>260BC年，米列海战（现在的米拉佐，罗马海军获胜，第一次使用乌鸦吊桥）。</p><p>257BC年，巴勒莫海战（罗马海军获胜）。</p><p>256BC年，埃克诺穆斯海战（现在的利卡塔，罗马海军获胜）。</p><p>256BC年，罗马远征军登陆非洲，战败。</p><p>241BC年，埃加迪群岛海战（罗马海军获胜）。</p><p>结果：罗马获得西西里岛、萨丁岛和科西嘉岛。</p><h4 id="2-10-2-第二次布匿战争（汉尼拔战争，218BC-202BC）"><a href="#2-10-2-第二次布匿战争（汉尼拔战争，218BC-202BC）" class="headerlink" title="2.10.2 第二次布匿战争（汉尼拔战争，218BC-202BC）"></a>2.10.2 第二次布匿战争（汉尼拔战争，218BC-202BC）</h4><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%B8%83%E5%8C%BF%E6%88%98%E4%BA%89%E5%89%8D%E7%9A%84%E7%BD%97%E9%A9%AC%E5%92%8C%E8%BF%A6%E5%A4%AA%E5%9F%BA.png" alt="第二次布匿战争前的罗马和迦太基"></p><p>218BC年，汉尼拔从西班牙出发，跨过阿尔卑斯山，进入意大利。</p><p>218BC年，提契诺河战役（汉尼拔获胜）。</p><p>218BC年，特雷比亚河战役（汉尼拔获胜）。</p><p>217BC年，特拉西梅诺湖战役（汉尼拔获胜）。</p><p>216BC年，坎尼会战（汉尼拔获胜）。</p><p>大西庇阿，普布利乌斯·科尔内利乌斯·西庇阿（235BC-183BC），阿非利加努斯。</p><p>征服西班牙</p><p>征战非洲</p><p>202BC，扎马战役（西庇阿获胜）。</p><p>结果：迦太基只剩下非洲，海军解散，任何自卫战争需征得罗马同意。罗马成为地中海最强大的国家。</p><h4 id="2-10-3-第三次布匿战争（149BC-146BC）"><a href="#2-10-3-第三次布匿战争（149BC-146BC）" class="headerlink" title="2.10.3 第三次布匿战争（149BC-146BC）"></a>2.10.3 第三次布匿战争（149BC-146BC）</h4><p>三年围城战，迦太基灭亡。</p><h3 id="2-11-马其顿战争"><a href="#2-11-马其顿战争" class="headerlink" title="2.11 马其顿战争"></a>2.11 马其顿战争</h3><p>第一次马其顿战争（214BC-205BC），马其顿和汉尼拔结盟。</p><p>第二次马其顿战争（200BC-196BC）。</p><p>塞琉古战争（192BC-188BC），罗马和叙利亚塞琉古王朝的战争。</p><p>第三次马其顿战争（171BC-168BC）。</p><p>第四次马其顿战争（150BC-148BC），战后，马其顿成为罗马的一个行省。</p><h3 id="2-12-格拉古兄弟改革"><a href="#2-12-格拉古兄弟改革" class="headerlink" title="2.12 格拉古兄弟改革"></a>2.12 格拉古兄弟改革</h3><p>格拉古兄弟是大西庇阿的外孙。</p><h4 id="2-12-1-第一次改革：提比略·格拉古"><a href="#2-12-1-第一次改革：提比略·格拉古" class="headerlink" title="2.12.1 第一次改革：提比略·格拉古"></a>2.12.1 第一次改革：提比略·格拉古</h4><p>提比略·格拉古（168BC-133BC）</p><p>133BC年当选护民官，提出土地法案，每户所占公有土地不可以超过1000尤格（约650英亩）。超过部分国家补偿并收回，发放给贫穷农民，三人委员会负责处理。</p><p>被反对派杀死，改革终止。</p><h4 id="2-12-2-第二次改革：盖约·格拉古"><a href="#2-12-2-第二次改革：盖约·格拉古" class="headerlink" title="2.12.2 第二次改革：盖约·格拉古"></a>2.12.2 第二次改革：盖约·格拉古</h4><p>盖约·格拉古（154BC-121BC）</p><p>123BC，122BC年， 当选护民官，陪审团全部由骑士阶级担任；建设海外殖民地安置平民；粮食法低价购买粮食；拉丁公民获得罗马公民权，其余意大利人获得拉丁公民权（未成功）。</p><p>121BC年，被反对派杀死。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%85%AC%E5%85%83%E5%89%8D130%E5%B9%B4%E7%9A%84%E5%9C%B0%E4%B8%AD%E6%B5%B7%E4%B8%96%E7%95%8C.png" alt="公元前130年的地中海世界"></p><h3 id="2-13-西西里奴隶起义"><a href="#2-13-西西里奴隶起义" class="headerlink" title="2.13 西西里奴隶起义"></a>2.13 西西里奴隶起义</h3><p>第一次西西里奴隶起义：137BC-132BC</p><p>第二次西西里奴隶起义：104BC-101BC</p><h3 id="2-14-军人共和"><a href="#2-14-军人共和" class="headerlink" title="2.14 军人共和"></a>2.14 军人共和</h3><h4 id="2-14-1-盖乌斯·马略"><a href="#2-14-1-盖乌斯·马略" class="headerlink" title="2.14.1 盖乌斯·马略"></a>2.14.1 盖乌斯·马略</h4><p>盖乌斯·马略（157BC-86BC），平民。</p><p>辛布里战争（113BC-101BC），日耳曼族入侵。马略成功击败。</p><p>军事改革（志愿兵制）</p><p>晚年和苏拉的斗争。</p><h4 id="2-14-2-路奇乌斯·科尔内利乌斯·苏拉"><a href="#2-14-2-路奇乌斯·科尔内利乌斯·苏拉" class="headerlink" title="2.14.2 路奇乌斯·科尔内利乌斯·苏拉"></a>2.14.2 路奇乌斯·科尔内利乌斯·苏拉</h4><p>路奇乌斯·科尔内利乌斯·苏拉（138BC-78BC）</p><p>朱古达战争（111BC-105BC），努米底亚</p><p>同盟者战争（91BC-88BC），原罗马同盟者</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%90%8C%E7%9B%9F%E6%88%98%E4%BA%89%E6%97%B6%E7%9A%84%E6%84%8F%E5%A4%A7%E5%88%A9%E5%8D%97%E9%83%A8.png" alt="同盟战争时期的意大利南部"></p><p>第一次米特拉达梯战争（89BC-84BC）本都王国</p><p>第一次苏拉内战（88BC-87BC）</p><p>第二次苏拉内战（83BC-81BC）</p><p>81BC-79BC：苏拉独裁</p><h4 id="2-14-3-卢库卢斯"><a href="#2-14-3-卢库卢斯" class="headerlink" title="2.14.3 卢库卢斯"></a>2.14.3 卢库卢斯</h4><p>卢库卢斯（117BC-56BC）</p><p>第一次米特拉达梯战争（89BC-84BC）</p><p>第二次米特拉达梯战争（74BC-66BC）</p><h4 id="2-14-4-马库斯·李锡尼·克拉苏"><a href="#2-14-4-马库斯·李锡尼·克拉苏" class="headerlink" title="2.14.4 马库斯·李锡尼·克拉苏"></a>2.14.4 马库斯·李锡尼·克拉苏</h4><p>前三头之一</p><p>马库斯·李锡尼·克拉苏（115BC-53BC）</p><p>斯巴达克斯起义（73BC-71BC）</p><p>东征帕提亚失败被杀</p><h4 id="2-14-5-格涅乌斯·庞培"><a href="#2-14-5-格涅乌斯·庞培" class="headerlink" title="2.14.5 格涅乌斯·庞培"></a>2.14.5 格涅乌斯·庞培</h4><p>庞培·阿格努斯（伟大的庞培，106BC-48BC）</p><p>肃清海盗</p><p>与凯撒的内战中战败被杀</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%BA%9E%E5%9F%B9%E5%B9%B3%E5%AE%9A%E4%B8%9C%E6%96%B9%EF%BC%88%E5%89%8D63%E5%B9%B4%EF%BC%89%E7%9A%84%E5%9C%B0%E4%B8%AD%E6%B5%B7.png" alt="庞培平定东方（前63年）的地中海"></p><h4 id="2-14-5-凯撒"><a href="#2-14-5-凯撒" class="headerlink" title="2.14.5 凯撒"></a>2.14.5 凯撒</h4><p>盖乌斯·尤利乌斯·凯撒（100BC-44BC）</p><p>前三头之一</p><p>征服高卢（58BC-49）</p><p>渡过卢孔比河，内战（49BC-45BC）</p><p>终身独裁官</p><p>被刺杀（44BC）</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E9%AB%98%E5%8D%A2%E6%88%98%E8%AE%B0%E4%B8%8E%E5%86%85%E6%88%98%E8%AE%B0.png" alt="高卢战记与内战记"></p>]]></content>
      
      
      <categories>
          
          <category> reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> history </tag>
            
            <tag> rome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSL and TLS (Part 3): Protocol</title>
      <link href="/ssl-and-tls-part-3-protocol/"/>
      <url>/ssl-and-tls-part-3-protocol/</url>
      
        <content type="html"><![CDATA[<p>在前面的文章中，我们从密码学的角度讨论了一些主要的密码原语（cryptographic primitive），最后通过组合这些密码原语构成一个可用的安全通信协议。</p><p>这篇文章更进一步，看看TLS是怎么做的。不过TLS的细节太多了也有点难，这里只是在较高的层次上给出一个清晰的认识，不深入复杂的细节。</p><h2 id="1-Record-Protocol"><a href="#1-Record-Protocol" class="headerlink" title="1. Record Protocol"></a>1. Record Protocol</h2><p>像网络模型里其它层一样，TLS也需要一个协议来对数据进行封装。这就是Record Protocol，每个TLS record结构如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/tls_record.png"><p>如果数据过长，TLS会将数据分成大小合适的两条record；如果数据少的话也会合并到一起构成一个record。</p><p>record中的data就是使用Alice和Bob协商的方法和参数加密后的数据了。这样，只要有一个建立好的TLS链接，后续传输的数据都是安全的了。</p><p>那么接下来的问题就是，<strong>TLS是怎么建立一条安全的链接的</strong>。</p><h2 id="2-Handshake-Protocol"><a href="#2-Handshake-Protocol" class="headerlink" title="2. Handshake Protocol"></a>2. Handshake Protocol</h2><p>Handshake Protocol是TLS中最重要的一个协议。在这个过程中，通信的双方，Alice和Bob需要商量好一个具体的方法以及参数，用来在接下来的通信过程中对数据进行加密。这就是Handshake Protocol的目的。</p><p>根据支持的协议和配置的不同，Handshake Protocol主要有三种变形：</p><ol><li>full handshake with server authentication（和一个认证的服务器来一次完整的握手）；</li><li>handshake with client and server authentication（一个认证的client和一个认证的server之前的握手）</li><li>abbreviated handshake that resumes an earlier session（之前握过手，这次就可以简单点了）。</li></ol><p>在讨论握手细节之前，看看消息的格式。</p><h3 id="2-1-Message"><a href="#2-1-Message" class="headerlink" title="2.1 Message"></a>2.1 Message</h3><p>Handshake Protocol的消息格式如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span><span class="token punctuation">{</span>    HandshakeType msg_type<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* handshake type */</span>    uint24 length<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/* remaining bytes in message */</span>    HandshakeMessage message<span class="token punctuation">;</span><span class="token punctuation">}</span> Handshake<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在协商的过程中会有不同的阶段，也有不同类型的消息，每个消息都有自己的格式。<code>message</code>字段的内容根据消息类型而定。</p><h3 id="2-2-Full-Handshake"><a href="#2-2-Full-Handshake" class="headerlink" title="2.2 Full Handshake"></a>2.2 Full Handshake</h3><p>好的，两个之前完全陌生的人见面了，需要“完整地握一次手”认识一下。</p><p>在一个Full Handshake过程中，client和server主要完成下面的四步操作：</p><ol><li>交换容量（capabilities）并确定其他连接参数；</li><li>认证证书，或者使用其他方式进行认证（<strong>真实性</strong>）；</li><li>协商构造一个master secret，用来对会话进行加密（<strong>保密性</strong>）；</li><li>验证Handshake消息的完整性（<strong>完整性</strong>）。</li></ol><p>其中，第2和第3步在一个操作中完成，叫做秘钥交换（key exchange）。分成这两个是为了强调认证的过程，毕竟真实性是很重要的一部分。</p><p>下图展示了一个未认证的client和一个已认证的server之间的Full Handshake流程：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/full_handshake.png"><ol><li>client开启会话并向server发送自己的容量，其中还有很多额外的信息；</li><li>server选择连接的参数；</li><li>server发送自己的证书链（必要的时候）；</li><li>根据选择的参数，server发送生成master secret需要的额外信息；</li><li>server发送一条信息标识协商结束；</li><li>client发送生成master secret需要的额外信息；</li><li>client开启加密模式并通知server；</li><li>client对自己发送和收到的Handshake消息生成一个MAC并发送给server；</li><li>server开启加密模式并通知client；</li><li>server对自己发送和收到的Handshake消息生成一个MAC并发送给client。</li></ol><p>到目前为止，如果没有错误的话，那么一个安全的连接就建立了。接下来详细看看Handshake消息的细节。</p><h4 id="2-2-1-ClientHello"><a href="#2-2-1-ClientHello" class="headerlink" title="2.2.1 ClientHello"></a>2.2.1 ClientHello</h4><p>作为握手的第一个消息，ClientHello包含一些重要的参数和首选项。</p><p>毕竟是要和sever协商一个加密的方法，所以client需要告诉server，我都支持哪些加密算法。之外，如果不是第一次建立连接，希望复用之前协商的结果的话，就应该有个字段标识出之前保存的会话（session）。这就大概包含了主要的信息：</p><table><thead><tr><th>字段</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>Version</td><td>版本</td><td>比如TLS 1.2</td></tr><tr><td>Random</td><td>随机信息</td><td>包含一个随机字符串（32字节）</td></tr><tr><td>Session ID</td><td>会话ID</td><td>第一次为空，如果希望复用的话就使用对应的ID</td></tr><tr><td>Cipher suites</td><td>支持的加密算法</td><td></td></tr><tr><td>Extensions</td><td>扩展模块</td><td>其他的信息可以放在这个模块中</td></tr></tbody></table><h4 id="2-2-2-ServerHello"><a href="#2-2-2-ServerHello" class="headerlink" title="2.2.2 ServerHello"></a>2.2.2 ServerHello</h4><p>对于server，当收到一个ClientHello后，就需要作出回应。因为client在ClientHello中列出了支持的算法，这里server需要选择一个，加上其他的参数一起通知给client，这就是ServerHello的作用。</p><p>ServerHello和ClientHello的消息格式大致相同。</p><h4 id="2-2-3-Certificate"><a href="#2-2-3-Certificate" class="headerlink" title="2.2.3 Certificate"></a>2.2.3 Certificate</h4><p>连接参数和加密算法商量好之后，server需要发送证书给client，以便client来做认证。这就是Certificate消息的作用。</p><p>server需要保证发送的证书和之前协商好的加密算法匹配。常用的证书是X.509格式的。</p><p>大多数情况下使用的是公钥加密算法来进行认证（RSA或ECDSA）。</p><p>Certificate消息是可选的，因为有的认证方法不需要证书。</p><h4 id="2-2-4-SeverKeyExchange"><a href="#2-2-4-SeverKeyExchange" class="headerlink" title="2.2.4 SeverKeyExchange"></a>2.2.4 SeverKeyExchange</h4><p>好的，发送完Certificate之后，client认证了server。接下来就可以开始秘钥交换了（key exchange）。这就是ServerKeyExchange消息的作用。随着使用的秘钥交换协议的不同，这个消息的格式也不一样。知道这个消息的作用就好了。</p><p>ServerKeyExchange也是可选的。</p><h4 id="2-2-5-ServerHelloDone"><a href="#2-2-5-ServerHelloDone" class="headerlink" title="2.2.5 ServerHelloDone"></a>2.2.5 ServerHelloDone</h4><p>到这里，server要做的就暂时结束了，接下来就发送一个ServerHelloDone通知一下client，然后等着client的进一步消息。</p><h4 id="2-2-6-ClientKeyExchange"><a href="#2-2-6-ClientKeyExchange" class="headerlink" title="2.2.6 ClientKeyExchange"></a>2.2.6 ClientKeyExchange</h4><p>秘钥交换是需要通信的双方一起的。server发送完ServerKeyExchange之后，需要client发送自己的消息，这就是ClientKeyExchange。</p><p>这里对秘钥交换多说一些。在TLS中，会话的安全依赖于一个48位长的秘钥，叫做master secret。但是在秘钥交换过程中交换的不是这个master secret，而是另一个值，premaster secret，通过这个值client和server能够计算出master secret。</p><p>TLS支持多种秘钥交换算法比如RSA、DHE_RSA、ECDHE_RSA和ECDHE_ECDSA等。不用管细节了，这些算法都挺复杂的。</p><h4 id="2-2-7-ChangeCipherSpec"><a href="#2-2-7-ChangeCipherSpec" class="headerlink" title="2.2.7 ChangeCipherSpec"></a>2.2.7 ChangeCipherSpec</h4><p>当client接收了ServerKeyExchange并生成自己的ClientKeyExchange之后，那就完成了秘钥交换（具体是怎么做的就不展开了）。根据协商好的秘钥，就可以对后序的数据加密了。同时，对于server来说，收到ClientKeyExchange之后也可以获得通信的秘钥了，然后就可以是所有这个秘钥加密通信了。</p><p>这就是ChangeCipherSpec的作用。不过ChangeCipherSpec不是Handshake Message。</p><h4 id="2-2-8-Finished"><a href="#2-2-8-Finished" class="headerlink" title="2.2.8 Finished"></a>2.2.8 Finished</h4><p>秘钥交换完了，那握手就可以结束了。不过，前面的过程我们实现了保密性和真实性，还少了完整性，这就是Finished达到的目标。</p><p>Finished中有一个<code>verify_data</code>字段，这个字段是通过下面的方法计算得到的，可以用来保证数据的完整性，并在有中间人修改时可以检测到：</p><pre><code>verify_data = PRF(master_secret, finished_label, Hash(handshake_message))</code></pre><p>其中<code>PRF()</code>是为随机函数（pseudorandom function），可以生成任意长度的随机数；<code>finished_label</code>对于不同的消息值也不同（client发送的就是”client finished”，server发送的就是”server finished”）；<code>Hash()</code>是协商好的哈希函数。</p><h3 id="2-3-Client-Authentication"><a href="#2-3-Client-Authentication" class="headerlink" title="2.3 Client Authentication"></a>2.3 Client Authentication</h3><p>server是必须认证的，client的认证是可选的。不过server可以通过发送一个CertificateRequest来请求对client进行认证。然后client发送自己的Certificate消息。整体的流程如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/client_authentication.png"><h4 id="2-3-1-CertificateRequest"><a href="#2-3-1-CertificateRequest" class="headerlink" title="2.3.1 CertificateRequest"></a>2.3.1 CertificateRequest</h4><p>server通过发送这个消息来请求对client进行认证。</p><h4 id="2-3-2-CertificateVerify"><a href="#2-3-2-CertificateVerify" class="headerlink" title="2.3.2 CertificateVerify"></a>2.3.2 CertificateVerify</h4><p>client发送这个消息来对自己的身份进行认证。这个消息包含对到目前为止收到的Handshake消息的签名。这样server就可以进行认证了。</p><h3 id="2-4-Session-Resumption"><a href="#2-4-Session-Resumption" class="headerlink" title="2.4 Session Resumption"></a>2.4 Session Resumption</h3><p>由于加密算法的协商和参数的选择，一个完整的握手需要两个RTT（round-trip time）。同时，握手期间的加解密操作也很耗时，如果能复用之间协商的结果的话，那就可以减轻负担了。</p><p>在一个完整握手过程中，如果server希望复用，那么就可以在ServerHello中返回一个session ID给client，然后将数据保存起来。如果client希望复用，在ClientHello中加上那个session ID就可以了：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/session_resumption.png"><p>这样只有一个RTT就完成了握手。</p><p>除了session ID，还可以使用session tickets的方式来恢复会话。在TLS 1.3中，使用的是PSK（Pre-Shared Key）。</p><p>这里简单描述了一个握手的整个过程。握手完成之后，就可以安全地通信了。</p><h2 id="3-加密"><a href="#3-加密" class="headerlink" title="3. 加密"></a>3. 加密</h2><p>完成了认证和秘钥交换，就可以进行加密操作了。TLS支持多种加密算法，常用的是AES，有三种不同类型的加密，stream，block和authenticated。在TLS中，数据的完整性校验也包含在加密过程中。</p><h3 id="3-1-Stream-Encryption"><a href="#3-1-Stream-Encryption" class="headerlink" title="3.1 Stream Encryption"></a>3.1 Stream Encryption</h3><p>流密码的加密过程如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/stream_encryption.png"><p>有两个步骤：</p><ol><li>将序列号（Sequence Number）、头部Header和明文数据组合在一起生成MAC，由于Header数据没有被加密，在计算MAC过程中包含Header可以防止Header被篡改；包含序列号可以防止重放攻击；</li><li>明文数据和第一步计算出来的MAC放在一起加密得到密文。</li></ol><h3 id="3-2-Block-Encryption"><a href="#3-2-Block-Encryption" class="headerlink" title="3.2 Block Encryption"></a>3.2 Block Encryption</h3><p>使用分组密码的流程如下：</p><ol><li>计算序列号、header和明文的MAC（和流密码一样）；</li><li>由于使用分组密码，可能需要填充padding操作（通常分组是16字节）；</li><li>生成初始向量（initialization vector，IV），长度和分组一样长；</li><li>使用CBC模式加密明文，MAC和padding；</li><li>发送IV和密文。</li></ol><p>如图：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/block_encryption.png"><p>这里有个问题就是，padding没有放在计算MAC之内。</p><h3 id="3-3-Authenticated-Encryption"><a href="#3-3-Authenticated-Encryption" class="headerlink" title="3.3 Authenticated Encryption"></a>3.3 Authenticated Encryption</h3><p>认证密码把加密和完整性校验放在了一起，全称叫做authenticated encryption with associated data(AEAD)。过程如下：</p><ol><li>生成一个64位的nonce；</li><li>对明文加密，同时使用认证算法将序列号和header添加进来；</li><li>将密文和nonce一起发送。</li></ol><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/authenticated_encryption.png"><h2 id="4-密码学操作"><a href="#4-密码学操作" class="headerlink" title="4. 密码学操作"></a>4. 密码学操作</h2><p>上面是在较高的层次的层次上讨论TLS是怎么做的。接下来从密码学的角度看看一些操作。</p><h3 id="4-1-伪随机函数"><a href="#4-1-伪随机函数" class="headerlink" title="4.1 伪随机函数"></a>4.1 伪随机函数</h3><p>前面我们说过了伪随机函数PRF（pseudorandom function），用来产生任意长度的伪随机数。从TLS 1.2开始，所有的算法都需要指定自己的PRF。TLS 1.2中，PRF定义在P_hash函数上的：</p><pre><code>PRF(secret, label, seed) = P_hash(secret, label + seed)</code></pre><p>三个参数，<code>secret</code>，<code>label</code>和<code>seed</code>。</p><p>而<code>P_hash</code>函数是基于HMAC的：</p><pre><code>P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +                       HMAC_hash(secret, A(2) + seed) +                       HMAC_hash(secret, A(3) + seed) + ...</code></pre><p>其中<code>A(i)</code>函数定义如下：</p><pre><code>A(1) = HMAC_hash(secret, seed)A(2) = HMAC_hash(secret, A(1))...A(i) = HMAC_hash(secret, A(i-1))</code></pre><p>由于使用了<code>seed</code>和<code>label</code>，同一个<code>secret</code>可以使用多次。</p><h3 id="4-2-Master-Secret"><a href="#4-2-Master-Secret" class="headerlink" title="4.2 Master Secret"></a>4.2 Master Secret</h3><p>之前说过，秘钥交换的不是master secret，而是premaster secret，然后生成master secret。通过下面的方法可以生成48字节长的master secret：</p><pre><code>master_secret = PRF(pre_master_secret, &quot;master secret&quot;, ClientHello.random + ServerHello.random)</code></pre><h3 id="4-3-生成秘钥"><a href="#4-3-生成秘钥" class="headerlink" title="4.3 生成秘钥"></a>4.3 生成秘钥</h3><p>有了master secret之后，就可以生成秘钥了：</p><pre><code>key_block = PRF(SecurityParamters.master_secret,                &quot;key expansion&quot;,                SecurityParameters.server_random + SecurityParameters.client_random)</code></pre><p>生成的key_block可以分成六部分：两个MAC秘钥，两个加密秘钥还有两个初始化变量（IV）。不同的秘钥用于不同的操作，这样可以防止秘钥的重复使用。</p><h2 id="5-Cipher-Suites"><a href="#5-Cipher-Suites" class="headerlink" title="5. Cipher Suites"></a>5. Cipher Suites</h2><p>最后，介绍一下加密算法。一个cipher suite就是一组密码原语以及定义实现的参数的组合。主要包括下面的东西：</p><ul><li>认证方法（Authentication method）</li><li>秘钥交换方法（Key exchange method）</li><li>加密算法（Encryption algorithm）</li><li>加密秘钥长度（Encryption key size）</li><li>密码模式（Cipher mode）</li><li>MAC算法（MAC algorithm）</li><li>PRF</li><li>Finished消息使用的哈希函数</li><li>verify_data的长度</li></ul><p>一个cipher suite的名字就指出了上面那些内容的具体实现：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/cipher_suite_name.png"><p>下表列出了一些常见的cipher suite：</p><table><thead><tr><th>Cipher Suite Name</th><th>Auth</th><th>KX</th><th>Cipher</th><th>MAC</th><th>PRF</th></tr></thead><tbody><tr><td>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</td><td>RSA</td><td>ECDHE</td><td>AES-128-GCM</td><td>-</td><td>SHA256</td></tr><tr><td>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</td><td>ECDSA</td><td>ECDHE</td><td>AES-256-GCM</td><td>-</td><td>SHA384</td></tr><tr><td>TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA</td><td>RSA</td><td>DHE</td><td>3DES-EDE-CBC</td><td>SHA1</td><td>Protocol</td></tr><tr><td>TLS_RSA_WITH_AES_128_CBC_SHA</td><td>RSA</td><td>RSA</td><td>AES-128_CBC</td><td>SHA1</td><td>Protocol</td></tr><tr><td>TLS_ECDHE_ECDSA_WITH_AES_128_CCM</td><td>ECDSA</td><td>ECDHE</td><td>AES-128-CCM</td><td>-</td><td>SHA256</td></tr></tbody></table><p>好了，到现在为止我们对TLS是如何操作的有了一个大概的认识。</p><p>To Be Continued…</p>]]></content>
      
      
      <categories>
          
          <category> cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tls </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSL and TLS (Part 2): Cryptography</title>
      <link href="/ssl-and-tls-part-2-cryptography/"/>
      <url>/ssl-and-tls-part-2-cryptography/</url>
      
        <content type="html"><![CDATA[<p>在<a href="https://deuterium.fun/ssl-and-tls-part-1-brief-intro/">SSL and TLS (Part 1): Brief Intro</a>中简单介绍了一下SSL/TLS，并以需要解决的三个问题结尾。这三个问题是：</p><ol><li><strong>保密性（Confidentiality）</strong></li><li><strong>真实性（Authenticity）</strong></li><li><strong>完整性（Integrity）</strong></li></ol><p>这篇文章中，我们主要在密码学的角度，来看看如果通过密码学来解决上面的三个问题。</p><h2 id="1-角色登场"><a href="#1-角色登场" class="headerlink" title="1. 角色登场"></a>1. 角色登场</h2><p>在解决问题之前，先看看在一个简单的场景中，都会有哪些角色。</p><p>首先是通信的双方。Alice和Bob通过互联网愉快地沟通。</p><p>由于通信链路的不安全，任何中间节点的人都可以监听Alice和Bob之间的对话，这也是SSL/TLS需要避免的问题。这里，链路中间多了一个中间人（Man in the Middle），我们把他叫做Mallory。</p><p>这样，一个简单的场景包含两个角色三个参与者：两个通信人Alice和Bob，一个中间人Mallory：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/mallory.png"><h2 id="2-对称加密（私钥加密）"><a href="#2-对称加密（私钥加密）" class="headerlink" title="2. 对称加密（私钥加密）"></a>2. 对称加密（私钥加密）</h2><p>就像钥匙和锁一样，一个简单的加密思路就是一把钥匙（secret key，秘钥）既可以将需要加密的文本（plaintext，明文）加密成别人看不出来的文本（ciphertext，密文）；同时也可以使用密钥将密文解密成明文。就像下面的过程：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/symmetric_encryption.png"><p>这就是对称加密算法（symmetric encryption），也叫私钥加密（private-key cryptography）。对称的意思是说一个秘钥即可以加密又可以解密；而私钥意味着，这个秘钥是需要保密的，不能让别人知道。</p><p>这样，如果Alice和Bob之间有一个只有他们两个人才知道的密钥并通过这个密钥进行加密，那么不知道密钥的Mallory是不知道他俩之间的通信内容的。</p><p>对称加密算法历史悠久，著名的就是凯撒密码。这是一种替换加密算法（substitution cipher），即使用字母表后三位的字母来替换明文中的字母。比如将明文中的a替换为d，以此类推。在这种加密算法中，没有密钥（其实也可以说3就是密钥），算法的安全性依赖于加密方法的保密性。如果敌人知道加密算法了，那么也就会解密了。</p><p>随着密码学的发展，一个加密算法需要满足下面的特征才能算是安全的：</p><blockquote><p>一个攻击者即使知道关于加密算法的所有细节，但是不知道密钥，算法仍是安全的。</p></blockquote><p>这时，密文的安全性依赖于密钥。如果密钥是从一个非常大的可选空间中选择的，并且破解这个密钥需要巨大的计算能力，那么这个加密算法就是计算安全的。</p><p>这样，如果我们有一个计算安全的加密算法，我们就解决了第一个问题：<strong>保密性</strong>，只要我们保证密钥的安全即可。</p><p>加密算法可以分为两种：流密码（stream cipher）和分组密码（block cipher）。</p><h3 id="2-1-流密码"><a href="#2-1-流密码" class="headerlink" title="2.1 流密码"></a>2.1 流密码</h3><p>流密码（stream cipher），从名字就可以想象出这种加密算法的加密方式。把加密算法当做一个机器，每来一个字节明文经过这个机器，就输出一个字节的密文，直到所有的明文都经过加密。对于解密，就是过程反过来。</p><p>RC4是一种比较知名的流密码，它的加密过程如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/rc4.png"><p>算法的核心是一个有限长度的随机密钥流（keystream），然后用这个keystream对明文进行异或操作得到密文。解密的时候使用密文亦或keystream就可以得到明文了。</p><p>这个算法的一个特点是每个keystream只能使用一次，重复使用会增大被破解的概率。</p><p>RC4算法现在已经是不安全的了。</p><h3 id="2-2-分组密码"><a href="#2-2-分组密码" class="headerlink" title="2.2 分组密码"></a>2.2 分组密码</h3><p>分组密码（block cipher），就是对一块一块的明文进行加密得到一块一块的密文。现代的分组密码的分组大小一般是128位（16字节）。分组密码也可以看做是一个机器，输入一个分组的明文，机器一顿操作得到一个分组的密文。如果key一致，那么对于不同的明文，都会有唯一对应的密文。</p><p>分组密码有一些缺点：</p><ol><li>只能加密一定长度的明文。使用分组密码需要对变长明文进行一定操作来满足要求（就是下面的padding填充）；</li><li>分组密码是确定的，明文相同，那么对应的密文也相同。这个特性增大了被攻击的概率。</li></ol><p>同时，分组密码也是好多加密方法的基础，比如哈希函数，消息验证码，伪随机数生成器，甚至流密码。</p><p>比较著名的分组密码是AES（Advanced Encryption Standard），分组的大小有128位，192位和256位可供选择。</p><p>在实际应用中，分组密码通常通过分组密码模式（block cipher mode）的方式来使用。模式就是在分组密码的基础上扩展的加密方式，使之方便使用。这里只介绍两个模式：ECB和CBC模式。</p><h4 id="2-2-1-Electronic-Codebook-Mode"><a href="#2-2-1-Electronic-Codebook-Mode" class="headerlink" title="2.2.1 Electronic Codebook Mode"></a>2.2.1 Electronic Codebook Mode</h4><p>ECB，电子密码本模式，是最简单的加密模式。只对满足一定条件长度的明文进行加密，不满足的需要先使用padding方式填充。</p><p>加密时将明文分成一定长度的块，然后分别加密。</p><p>简单是它的缺点。</p><h4 id="2-2-2-Cipher-Block-Chaining-Mode"><a href="#2-2-2-Cipher-Block-Chaining-Mode" class="headerlink" title="2.2.2 Cipher Block Chaining Mode"></a>2.2.2 Cipher Block Chaining Mode</h4><p>CBC，密码块链模式，通过引入初始向量值（initialization vector，IV）的方式来解决分组密码的确定性，这样，即使明文相同，不同时间加密后的密文也不一样：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/cbc.png"><p>初始向量IV的值是随机生成的（<strong>这里，又引出一个问题，怎么生成一个随机值呢？</strong>）。从上图可以看出Chaining是怎么形成的。</p><h3 id="2-3-Padding"><a href="#2-3-Padding" class="headerlink" title="2.3 Padding"></a>2.3 Padding</h3><p>使用分组密码时，如果明文长度不满足条件，需要对明文进行padding操作。比如，AES需要的输入是128位，同时生成128位的密文。如果明文不是128位的倍数，那么就需要对最后一个不足128位的分组进行填充。</p><p>为了能让Bob知道Alice对最后一个分组填充了多少数据，填充的内容不能是随机的。在TLS中，最后一个字节标识填充字节的长度（除了最后一个字节），然后填充字节的内容和长度一致。比如：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/tlb_padding.png"><p>Bob收到密文解密后查看最后一个分组的最后一个字节，内容是3，表示还需要去掉三个字节。这样就得到了明文。</p><h2 id="3-哈希函数"><a href="#3-哈希函数" class="headerlink" title="3. 哈希函数"></a>3. 哈希函数</h2><p>哈希函数（hash function）是一个将任意长的输入转换成固定长度输出的函数，结果也可以简单的叫哈希值（hash）。在编程语言中哈希函数很常用，但是这些都不适合在加密中使用。密码学中的哈希函数应该满足下面的要求：</p><ol><li><strong>Preimage Resistance</strong>：就是说，给定一个哈希值，很难找到一个输入可以生成这个哈希值；</li><li><strong>Second Preimage Resistance</strong>：给定一个输入和对应的哈希值，很难找到一个不同的输入可以生成同样的哈希值；</li><li><strong>Collision Resistance</strong>：很难找到两个不同的输入可以得到相同的哈希值。</li></ol><p>哈希函数对于比较大文件来说很有用。不用直接比较两个大文件，比较两个文件的哈希值就可以了。哈希函数也可以叫做指纹（fingerprints）、消息摘要（message digests）或摘要（digests）。</p><p>现在常用的哈希函数有SHA1，生成160位的结果，推荐使用更强的版本SHA256。</p><h2 id="4-消息验证码"><a href="#4-消息验证码" class="headerlink" title="4. 消息验证码"></a>4. 消息验证码</h2><p>哈希函数可以用于验证数据的完整性，因为对原始数据的一点点修改都会导致哈希值发生很大的变化。但是这需要数据和哈希值分开传输，否则Mallory就可以同时修改数据和对应的哈希值。</p><p>消息验证码（message authentication codes，MAC）在哈希函数的基础上增加了认证，也就是需要有一个hashing key，只有拥有hashing key的人才可以生成一个有效的MAC。</p><p>这样，当一个MAC和数据一起传输的时候，接收者Bob就可以通过hashing key和收到的MAC来检查数据是否被修改过。</p><p>使用哈希函数的消息验证码叫做HMAC（hash-based message authentication code）。实际上，HMAC通过安全的方式将hashing key和数据组合在一起。</p><p>这样，我们就解决了第三个问题：<strong>完整性</strong>。</p><h2 id="5-非对称加密（公钥加密）"><a href="#5-非对称加密（公钥加密）" class="headerlink" title="5. 非对称加密（公钥加密）"></a>5. 非对称加密（公钥加密）</h2><p>对称加密的一个优点是加密速度快。但是当参与通信的人越来越多的时候，对称加密就会有如下的缺点：</p><ol><li>如果同一个群体成员使用相同的秘钥的话，那么随着成员的增加，密钥泄漏的风险也在增加；</li><li>如果不使用同一个密钥，每两个人使用一个密钥，那么随着成员的增加，秘钥将爆炸增长；</li><li>对于无人值守系统不能使用对称加密来保护数据。因为同一个秘钥既可以加密也可以解密。</li></ol><p>非对称加密（asymmetric encryption，public-key cryptography）使用两个秘钥来进行加密和解密，一个秘钥是私有的，叫做私钥（private key），只能由私钥的所有者知道；另一个是公钥（public key），所有人都可以知道。</p><p>如果使用公钥加密，那么只有对应的私钥所有者才能解密；如果使用私钥加密，那么所有人都可以解密，因为私钥对应的公钥是公开的，所有人都可以知道。后一个加密方式可以当做一个数字签名，因为只有私钥持有人才可以用私钥加密。</p><p>非对称加密过程如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/asymmetric_encryption.png"><p>使用非对称加密可以解决大规模群体间的加密问题。任何人都可以使用公钥对私钥持有人发送加密消息；如果对方使用私钥加密，那么你也可以确切地知道对方是谁。</p><p>不过，非对称加密也有缺点：加密很慢，不适合大量数据。</p><p>RSA是现在最出名的非对称加密算法，推荐的秘钥长度是2048位。</p><h2 id="6-数字签名"><a href="#6-数字签名" class="headerlink" title="6. 数字签名"></a>6. 数字签名</h2><p>数字签名（digital signature）是一种密码学方案，用来验证消息的真实性。MAC也可以用来验证消息的真实性，不过需要一个事先准备好私有的hashing key，这就是它的一个缺点。</p><p>通过非对称加密可以达到数字签名的作用。比如，使用RSA的私钥加密，那么只有对应的公钥才能解密：</p><ol><li>计算一个需要签名的文件或数据的哈希值，不管文件或数据多大，哈希值总是固定长度的。比如SHA256的值就是256位；</li><li>将一些基本信息和哈希值放在一起，比如生成这个哈希值的算法；</li><li>将上面的数据使用私钥加密，结果就可以用来验证原始数据的真实性了。</li></ol><p>接收者使用公钥解密，得到使用的哈希函数，用这个函数对文件或数据计算哈希值，如果这个值和接收到的哈希值一致，说明文件没有问题。</p><p>有了数字签名，我们就解决了第二个问题：<strong>真实性</strong>。</p><h2 id="7-生成随机数"><a href="#7-生成随机数" class="headerlink" title="7. 生成随机数"></a>7. 生成随机数</h2><p>密码学中秘钥是一个重要的数据，需要随机生成。这就需要有一个随机数生成器。但是计算机生成的随机数有一定的可预测性，不能生成真随机数（true of random number），只能生成伪随机数（pseudorandom number）。通过seeding来生成伪随机数的过程就是伪随机数生成器（pseudorandom number generator，PRNG）。密码学中对随机数要求更高，需要使用密码学伪随机数生成器（cryptographic pseudorandom number generator，CPRNG）。</p><h2 id="8-混合在一起"><a href="#8-混合在一起" class="headerlink" title="8. 混合在一起"></a>8. 混合在一起</h2><p>前面介绍的内容都可以叫做密码原语（cryptographic primitive）。比如对称加密、哈希函数和非对称加密等。这些加密原语只做一件事情，单独使用不能保证通信的安全。因此，可以将一些密码原语组合在一起使用，形成加密方案或加密协议。</p><p>这里通过一个简单的例子，组合上面的密码原语构成一个加密协议，来保证Alice和Bob之间的通信安全。</p><p>首先Alice和Bob使用对称加密算法对数据进行加密，比如使用AES。这样，Mallory就不能通过观察的方式直接查看内容了。</p><p>但是Mallory可以劫持Alice和Bob之间的通信，篡改通信的内容而不会被Alice和Bob发现。不行，需要改进。</p><p>为了保证数据的完整性，Alice和Bob可以使用只有他们两人知道的hashing key对消息生成一个MAC，将MAC和加密后的密文一起传输，这样Mallory就不能篡改了，不然Alice和Bob就会发现。</p><p>不过Mallory还可以将劫持到的消息丢弃或重放，这时我们可以使用一个序列号，在计算MAC的时候把序列号放进去。这样当我们发现序列号缺失的时候，就知道了数据有丢失；序列号重复的时候，就检测到了一个重放攻击。最后，Alice和Bob使用一个特殊的消息标识会话结束。</p><p>到现在为止都还好，但是Alice和Bob怎么交换秘钥呢？首先可以在对话开始前使用公钥加密的方法传输一些信息，并验证对方是否是想要对话的人。这样就保证了真实性。</p><p>然后就可以通过秘钥交换协议来构造对称加密的秘钥了。常用的秘钥交换协议有RSA和Diffie-Hellman (DH)。</p><p>这样，我们就有了一个安全通信协议：</p><ol><li>第一次握手验证真实性并构造一个加密的秘钥；</li><li>使用秘钥加密数据并构造MAC，保证保密性和完整性；</li><li>会话结束时使用特殊的会话终止消息标识。</li></ol><p>这其实就和SSL/TLS的做法差不多了。</p><p>这篇文章从密码学的角度讨论了一些基本的密码学知识，并讨论如何使用这些基本的密码学方法构造一个可用的安全通信协议。对相应的密码学细节没有深入讨论，只是简单叙述。</p><p>To Be Continued…</p>]]></content>
      
      
      <categories>
          
          <category> cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tls </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSL and TLS (Part 1): Brief Intro</title>
      <link href="/ssl-and-tls-part-1-brief-intro/"/>
      <url>/ssl-and-tls-part-1-brief-intro/</url>
      
        <content type="html"><![CDATA[<p>在万物互联的时代，We don’t connect to the Internet, we <em>are</em> the Internet.</p><p>如此重要的互联网，需要一种协议来保护传输中的信息安全，那就是SSL（Secure Socket Layer）和TLS（Transport Layer Security）。</p><p>这篇文章就简单介绍一下SSL/TLS。</p><h3 id="1-一开始，我们裸奔"><a href="#1-一开始，我们裸奔" class="headerlink" title="1. 一开始，我们裸奔"></a>1. 一开始，我们裸奔</h3><p>当互联网刚开始设计的时候，并没有将安全考虑进去。所以我们的数据都是明文传输的。这在一开始接入的节点很少的时候没有问题，大家依赖君子协议也能很好地工作。</p><p>但是随着接入节点的增多以及使用互联网的业务越来越重要，这种“裸奔”越来越不合适。所以，需要一种方法对传输的数据进行加密。</p><p>未加密时，网络模型如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/network.PNG"><p>既然有五层，那就有多个地方可以完成加密的操作。这样，就引出了第一个问题：哪里加密？</p><h3 id="2-Protect-the-Transport"><a href="#2-Protect-the-Transport" class="headerlink" title="2. Protect the Transport"></a>2. Protect the Transport</h3><p>SSL/TLS是在传输层（Transport Layer）上面应用层（Application Layer）下面对数据进行加密的：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/network_tls.PNG"><p>这也是TLS名字的由来。</p><p>从这里也可以看出网络分层的优势：每一层只关注自己的任务即可而不需要操心其他。应用层只需要把数据交给TLS层即可，TLS负责加密，然后数据就这么一层一层下发直到传输到对面节点，对面节点逆序处理，就可以得到原始数据了。</p><p>如果不需要加密，那么去除TLS层，不会影响其他层的工作。</p><p>TLS的主要目标有四个：</p><ol><li><strong>加密安全（Cryptographic Security）</strong>：主要职责，保证通信链路的安全；</li><li><strong>互通性（Interoperability）</strong>：独立开发人员可以通过共同的加密参数使用不同的开发工具开发出可以一起工作的程序或库；</li><li><strong>可扩展性（Extensibility）</strong>：TLS支持多种加密方法，这需要TLS具有可扩展性，方便加密方法的变更；</li><li><strong>高效性（Efficiency）</strong>：由于加密是一个耗时的操作，因此TLS需要把加密的额外性能消耗降到最低。</li></ol><p>接下来，看看SSL和TLS的历史，以及两者之间的关系。</p><h3 id="3-A-Brief-History-of-SSL-TLS"><a href="#3-A-Brief-History-of-SSL-TLS" class="headerlink" title="3. A Brief History of SSL/TLS"></a>3. A Brief History of SSL/TLS</h3><ol><li>1994年网景公司（Netscape）发布SSL协议，由于严重的安全缺陷SSL 1.0没有应用；</li><li>1995年发布SSL 2.0，第一次在网景公司的浏览器上应用；</li><li>1996年发布全新的SSL 3.0版本；</li><li>1996年五月，成立TLS工作组，将SSL标准化；</li><li>1999年，发布TLS 1.0；</li><li>2006年发布TLS 1.1；</li><li>2008年发布TLS 1.2；</li><li>2018年发布TLS 1.3。</li></ol><p>这里，我们使用TLS这个名称。</p><h3 id="4-好的，加密吧"><a href="#4-好的，加密吧" class="headerlink" title="4. 好的，加密吧"></a>4. 好的，加密吧</h3><p>一种加密方法，在正确部署与使用的情况下，需要解决三个问题：</p><ol><li><strong>保密性（Confidentiality）</strong>：消息不能再裸奔了，不能让人一看就知道是啥；</li><li><strong>真实性（Authenticity）</strong>：我要知道你说你是谁是不是真的；</li><li><strong>完整性（Integrity）</strong>：保护传输链路的安全，消息不能被篡改，即使被篡改也能发现。</li></ol><p>为了解决这些问题，我们需要讨论一下密码学。不过只是在较高的层次上来谈论，忽略一些底层的细节，当需要的时候再详细讨论。毕竟，密码学是一门涉及很广也和数学有很多关联的科学。</p><p>To Be Continued…</p>]]></content>
      
      
      <categories>
          
          <category> cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tls </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Web (Part 4): Cookie</title>
      <link href="/go-web-part-4-cookie/"/>
      <url>/go-web-part-4-cookie/</url>
      
        <content type="html"><![CDATA[<p>HTTP是一个无状态的协议。</p><p>这意味着服务器不会记录客户的状态。但是有时候服务器需要知道客户端的状态，这个时候就可以使用Cookie了。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb11.png"><h3 id="1-Cookie-in-Golang"><a href="#1-Cookie-in-Golang" class="headerlink" title="1. Cookie in Golang"></a>1. Cookie in Golang</h3><p>在Go中，定义了Cookie的结构：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Cookie <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name  <span class="token builtin">string</span>    Value <span class="token builtin">string</span>    Path       <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// optional</span>    Domain     <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// optional</span>    Expires    time<span class="token punctuation">.</span>Time <span class="token comment" spellcheck="true">// optional</span>    RawExpires <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// for reading cookies only</span>    <span class="token comment" spellcheck="true">// MaxAge=0 means no 'Max-Age' attribute specified.</span>    <span class="token comment" spellcheck="true">// MaxAge&lt;0 means delete cookie now, equivalently 'Max-Age: 0'</span>    <span class="token comment" spellcheck="true">// MaxAge>0 means Max-Age attribute present and given in seconds</span>    MaxAge   <span class="token builtin">int</span>    Secure   <span class="token builtin">bool</span>    HttpOnly <span class="token builtin">bool</span>    SameSite SameSite    Raw      <span class="token builtin">string</span>    Unparsed <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token comment" spellcheck="true">// Raw text of unparsed attribute-value pairs</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实Cookie就是一个key-value对，用来存储一些简单的信息。也就是上面的字段中，<code>Name</code>和<code>Value</code>是必须的，其余的都是可选的。</p><p><code>Expires</code>和<code>MaxAge</code>都可以用来设置Cookie的有效期。不同在于：</p><ol><li><code>Expires</code>指定了Cookie过期的具体时间，比如一个Cookie会在2020-02-02 02:02:02过期；</li><li><code>MaxAge</code>指定了一个Cookie在被浏览器创建后可以存在的时间，单位是秒；</li><li>几乎所有的浏览器都支持<code>Expires</code>，但是IE6、IE7和IE8不支持<code>MaxAge</code>。</li></ol><p>使用这两种方式不是Go的原因，而是浏览器的支持情况决定的。</p><h3 id="2-设置Cookie"><a href="#2-设置Cookie" class="headerlink" title="2. 设置Cookie"></a>2. 设置Cookie</h3><p>服务器设置Cookie本质上就是将一个字符串写入response中的”Set-Cookie” Header中。而这个写入的字符串，是对Cookie结构的一个序列化结果（就是<code>Cookie.String()</code>方法）。</p><pre class="line-numbers language-go"><code class="language-go">c <span class="token operator">:=</span> http<span class="token punctuation">.</span>Cookie<span class="token punctuation">{</span>    Name<span class="token punctuation">:</span>  <span class="token string">"cookie"</span><span class="token punctuation">,</span>    Value<span class="token punctuation">:</span> <span class="token string">"go web"</span><span class="token punctuation">,</span><span class="token punctuation">}</span>w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Set-Cookie"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打开浏览器可以看到下面的结果：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/cookie_result.png"><p>也可以使用<code>http.SetCookie()</code>方法：</p><pre class="line-numbers language-go"><code class="language-go">c <span class="token operator">:=</span> http<span class="token punctuation">.</span>Cookie<span class="token punctuation">{</span>    Name<span class="token punctuation">:</span>  <span class="token string">"cookie"</span><span class="token punctuation">,</span>    Value<span class="token punctuation">:</span> <span class="token string">"go web"</span><span class="token punctuation">,</span><span class="token punctuation">}</span>http<span class="token punctuation">.</span><span class="token function">SetCookie</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果也是一样，不过要注意，这里使用的是Cookie的指针。</p><h3 id="3-读取Cookie"><a href="#3-读取Cookie" class="headerlink" title="3. 读取Cookie"></a>3. 读取Cookie</h3><p>服务器写入Cookie的Header是<code>Set-Cookie</code>，浏览器向服务器传递Cookie的Header是<code>Cookie</code>，可以通过这个Header来读取浏览器的Cookie：</p><pre class="line-numbers language-go"><code class="language-go">h <span class="token operator">:=</span> r<span class="token punctuation">.</span>Header<span class="token punctuation">[</span><span class="token string">"Cookie"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样获取到的是所有的Cookie切片。为了获取所有的Cookie，还可以使用下面的方法：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Cookies parses and returns the HTTP cookies sent with the request.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">Cookies</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Cookie <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">readCookies</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Header<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面两个方法获得的是所有的Cookie，还可以获取指定的Cookie：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Cookie returns the named cookie provided in the request or</span><span class="token comment" spellcheck="true">// ErrNoCookie if not found.</span><span class="token comment" spellcheck="true">// If multiple cookies match the given name, only one cookie will</span><span class="token comment" spellcheck="true">// be returned.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">Cookie</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Cookie<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> c <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token function">readCookies</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Header<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> c<span class="token punctuation">,</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> ErrNoCookie<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过这会在Cookie不存在的时候返回一个错误。具体使用如下：</p><pre class="line-numbers language-go"><code class="language-go">c<span class="token punctuation">,</span> err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">Cookie</span><span class="token punctuation">(</span><span class="token string">"cookie"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"no such cookie"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-删除一个Cookie"><a href="#4-删除一个Cookie" class="headerlink" title="4. 删除一个Cookie"></a>4. 删除一个Cookie</h3><p>Go里没有删除Cookie的方法，不过可以通过设置一个Cookie有效期来间接删除一个Cookie。</p><p>可以将一个Cookie的<code>Expires</code>设置为一个过去的时间，或者<code>MaxAge</code>设置为负数，就可以删除一个Cookie了：</p><pre class="line-numbers language-go"><code class="language-go">c <span class="token operator">:=</span> http<span class="token punctuation">.</span>Cookie<span class="token punctuation">{</span>    Name<span class="token punctuation">:</span> <span class="token string">"old_cookie"</span><span class="token punctuation">,</span>    MaxAge<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>    Expires<span class="token punctuation">:</span> time<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span>http<span class="token punctuation">.</span><span class="token function">SetCookie</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这篇文章简单介绍了一下在Go中如果使用Cookie，包括添加、读取以及删除。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb12.png"><p>To Be Continued…</p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Web (Part 3): response</title>
      <link href="/go-web-part-3-response/"/>
      <url>/go-web-part-3-response/</url>
      
        <content type="html"><![CDATA[<p>有请求就要有响应，一来一回。这篇文章来看看response的细节。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb9.png"><h3 id="1-从处理器Handler开始"><a href="#1-从处理器Handler开始" class="headerlink" title="1. 从处理器Handler开始"></a>1. 从处理器Handler开始</h3><p>对于Request，在前一篇文章中已经知道了整个的流程。Go会构造一个<code>Request</code>结构体，将接收到的请求中的信息解析到这个结构体中。对于一些信息（比如三个Form）需要手动调用一些函数来填充。这样在之后的处理过程中就可以通过这个<code>Request</code>结构来获取具体的请求信息了。</p><p>那么对于Response，是不是也是这个过程呢？创建一个Response结构，将数据保存在这个结构中，然后返回给客户端？</p><p>不是的，服务端返回响应的时候，使用的是<code>ResponseWriter</code>接口。这一点可以从处理器Handler的定义来看：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>两个参数分别对应响应和请求。</p><p><code>net/http</code>包内部使用<code>response</code>结构来处理响应，由于是非导出类型，不能直接操作，所以通过这个接口，来操作具体的响应。</p><p>而在通过<code>ResponseWriter</code>接口操作<code>response</code>时，传递的也是指向<code>response</code>结构的指针，这也解释了为什么处理器Handler的两个参数一个是值一个是引用，因为底层实际上都是引用。</p><h3 id="2-使用ResponseWriter进行写入"><a href="#2-使用ResponseWriter进行写入" class="headerlink" title="2. 使用ResponseWriter进行写入"></a>2. 使用ResponseWriter进行写入</h3><p>在具体看看Go是怎么处理response的之前，先看看怎么使用<code>ResponseWriter</code>进行写入。</p><p><code>ResponseWriter</code>接口有三个方法：</p><ul><li><code>Write</code>：将指定的数据写入对应的链接作为响应结果；</li><li><code>WriteHeader</code>：用来写入一个HTTP响应码（比如200 OK）；</li><li><code>Header</code>：返回Header，可以用来设置值。</li></ul><p>而<code>response</code>结构实现了这几个方法。</p><h4 id="2-1-Sending-Header"><a href="#2-1-Sending-Header" class="headerlink" title="2.1 Sending Header"></a>2.1 Sending Header</h4><p>可以直接通过<code>WriteHeader()</code>方法来写入HTTP响应码：</p><pre class="line-numbers language-go"><code class="language-go">w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Server"</span><span class="token punctuation">,</span> <span class="token string">"A Test Server"</span><span class="token punctuation">)</span>w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里首先通过<code>Header()</code>方法返回Header然后设置一个值，接下来通过<code>WriteHeader()</code>方法设置HTTP响应码为200。</p><p>通过curl可以看到下面的结果：</p><pre class="line-numbers language-shell"><code class="language-shell">HTTP/1.1 200 OKServer: A Test ServerDate: Thu, 02 Jan 2020 08:18:24 GMTContent-Length: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其实，对于HTTP响应码200来说，不用显示写入，默认就会写入这个响应码。对于<code>WriteHeader</code>方法来说，最常见的应用是写入HTTP的错误码。</p><p>比如，下面的代码实现了一次HTTP重定向：</p><pre class="line-numbers language-go"><code class="language-go">w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Location"</span><span class="token punctuation">,</span> <span class="token string">"http://google.com"</span><span class="token punctuation">)</span>w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span><span class="token number">302</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这时启动浏览器之后就会自动跳到Google的页面了。</p><h4 id="2-2-Rendering-Plain-Text"><a href="#2-2-Rendering-Plain-Text" class="headerlink" title="2.2 Rendering Plain Text"></a>2.2 Rendering Plain Text</h4><p>在之前的文章中，都是通过<code>fmt.Fprintf(w, &quot;hello&quot;)</code>这种方式写入响应的。原理都是一样，也可以使用<code>Write()</code>方法来写入结果：</p><pre class="line-numbers language-go"><code class="language-go">w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"I'm a Test Server"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不同在于，这里的参数是一个<code>[]byte</code>。结果：</p><pre class="line-numbers language-shell"><code class="language-shell">HTTP/1.1 200 OKDate: Thu, 02 Jan 2020 08:27:49 GMTContent-Length: 17Content-Type: text/plain; charset=utf-8I'm a Test Server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出：</p><ul><li>对于200响应码不用手动写入；</li><li><code>Content-Length</code>字段标识了响应的长度。</li></ul><h4 id="2-3-Rendering-JSON"><a href="#2-3-Rendering-JSON" class="headerlink" title="2.3 Rendering JSON"></a>2.3 Rendering JSON</h4><p>上面写入的响应是一个纯文本。同样可以对响应写入JSON格式的数据：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>        Name <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>        Age  <span class="token builtin">int</span>    <span class="token string">`json:"age"`</span>    <span class="token punctuation">}</span>    data<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>User<span class="token punctuation">{</span><span class="token string">"Valineliu"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json"</span><span class="token punctuation">)</span>    w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意需要通过<code>Header()</code>方法将内容类型设置成<code>application/json</code>，不然就是纯文本了。结果：</p><pre class="line-numbers language-shell"><code class="language-shell">HTTP/1.1 200 OKContent-Type: application/jsonDate: Thu, 02 Jan 2020 08:32:49 GMTContent-Length: 29{"name":"Valineliu","age":25}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然除了JSON格式外，还可以写入XML等格式。</p><h4 id="2-4-Serving-a-File"><a href="#2-4-Serving-a-File" class="headerlink" title="2.4 Serving a File"></a>2.4 Serving a File</h4><p>还可以发送一个文件：</p><pre class="line-numbers language-go"><code class="language-go">http<span class="token punctuation">.</span><span class="token function">ServeFile</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token string">"luffy.jpg"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过这个函数就可以了。打开浏览器就可以看到结果。使用curl结果：</p><pre class="line-numbers language-shell"><code class="language-shell">HTTP/1.1 200 OKAccept-Ranges: bytesContent-Length: 54146Content-Type: image/jpegLast-Modified: Wed, 06 Nov 2019 01:50:35 GMTDate: Thu, 02 Jan 2020 08:39:48 GMT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-看看具体发生了什么"><a href="#3-看看具体发生了什么" class="headerlink" title="3. 看看具体发生了什么"></a>3. 看看具体发生了什么</h3><p>除了上面的那些类型的内容外，还可以返回一个HTML模板，这里就不详细说了。</p><p>接下来看看<code>net/http</code>包是怎么通过<code>ResponseHeader</code>操作<code>response</code>的。</p><p><code>response</code>定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> response <span class="token keyword">struct</span> <span class="token punctuation">{</span>    conn             <span class="token operator">*</span>conn    req              <span class="token operator">*</span>Request <span class="token comment" spellcheck="true">// request for this response</span>    reqBody          io<span class="token punctuation">.</span>ReadCloser    w  <span class="token operator">*</span>bufio<span class="token punctuation">.</span>Writer    <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里只是一部分的字段，原来这个<code>response</code>结构竟然还有请求的字段。</p><p>当链接收到一个请求后，会调用<code>server()</code>方法进行处理，简略的过程如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Serve a new connection.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">serve</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>    w<span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">readRequest</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>    <span class="token operator">...</span>    req <span class="token operator">:=</span> w<span class="token punctuation">.</span>req    <span class="token operator">...</span>    serverHandler<span class="token punctuation">{</span>c<span class="token punctuation">.</span>server<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> w<span class="token punctuation">.</span>req<span class="token punctuation">)</span>    <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先通过<code>readRequest()</code>方法获得<code>response</code>，这个时候里面的<code>Resquest</code>已经构造好了。之后就可以使用<code>w</code>和<code>w.req</code>作为参数调用<code>ServeHTTP</code>了。</p><p>而在<code>readRequest()</code>方法中：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Read next request from connection.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">readRequest</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>    req<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">readRequest</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>bufr<span class="token punctuation">,</span> keepHostHeader<span class="token punctuation">)</span>    <span class="token operator">...</span>    w <span class="token operator">=</span> <span class="token operator">&amp;</span>response<span class="token punctuation">{</span>        conn<span class="token punctuation">:</span>          c<span class="token punctuation">,</span>        cancelCtx<span class="token punctuation">:</span>     cancelCtx<span class="token punctuation">,</span>        req<span class="token punctuation">:</span>           req<span class="token punctuation">,</span>        reqBody<span class="token punctuation">:</span>       req<span class="token punctuation">.</span>Body<span class="token punctuation">,</span>        handlerHeader<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span>Header<span class="token punctuation">)</span><span class="token punctuation">,</span>        contentLength<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>        closeNotifyCh<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// We populate these ahead of time so we're not</span>        <span class="token comment" spellcheck="true">// reading from req.Header after their Handler starts</span>        <span class="token comment" spellcheck="true">// and maybe mutates it (Issue 14940)</span>        wants10KeepAlive<span class="token punctuation">:</span> req<span class="token punctuation">.</span><span class="token function">wantsHttp10KeepAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        wantsClose<span class="token punctuation">:</span>       req<span class="token punctuation">.</span><span class="token function">wantsClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> isH2Upgrade <span class="token punctuation">{</span>        w<span class="token punctuation">.</span>closeAfterReply <span class="token operator">=</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span>    w<span class="token punctuation">.</span>cw<span class="token punctuation">.</span>res <span class="token operator">=</span> w    w<span class="token punctuation">.</span>w <span class="token operator">=</span> <span class="token function">newBufioWriterSize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">.</span>cw<span class="token punctuation">,</span> bufferBeforeChunkingSize<span class="token punctuation">)</span>    <span class="token keyword">return</span> w<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这个<code>response</code>的整个构造过程。这样，后序的处理就可以通过<code>ResponseWriter</code>接口来处理了。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb10.png"><p>To Be Continued…</p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Year Reading in 2019</title>
      <link href="/year-reading-in-2019/"/>
      <url>/year-reading-in-2019/</url>
      
        <content type="html"><![CDATA[<p>又是一年岁暮时。</p><p>最近才意识到，便随着2019年的过去，一个时代也过去了。</p><p>年初定的超过2017年的读书计划，接近但是没有完成（2017年120本，2019年113本，2018年太惨了28本）。</p><p>一个华丽的柱状图：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Life/reading_2019.png" alt="奥古斯都月太惨了"></p><p>距离2019年结束还有五天，剩下的时间最多只能看一本了。</p><p>对于今年还算满意，按分类统计：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Life/reading_category_2019.png" alt="我还是爱看故事哇"></p><h2 id="读阿婆，看人性"><a href="#读阿婆，看人性" class="headerlink" title="读阿婆，看人性"></a>读阿婆，看人性</h2><blockquote><p>人性在哪里都一样。</p></blockquote><p>年初的时候，计算用半年的时间看完阿婆的所有小说，一共八十多本。</p><p>结果我失败了（只看了30多本）。</p><p>失败的原因不是我不能坚持下来，是因为大名鼎鼎的阿婆也有好多一般甚至不咋地的书。</p><p>但这不能磨灭我对阿婆的爱！</p><p>阿婆的小说深入人性，绝大多数谋杀都是为了自己的私欲（也有个别的不是比如东方快车）。场景布局大多在不大的空间中，比如庄园、轮船或火车等。一开始就疑云密布，稍不注意就会被误导，结局又往往大出所料。</p><p>其中，我觉得精彩的有：</p><img src="http://img3.doubanio.com/view/subject/l/public/s26849345.jpg" style="zoom:20%"><p><a href="https://book.douban.com/subject/24859822/" target="_blank" rel="noopener">无人生还</a></p><p>★★★★★8.6</p><p>人在面临死亡的时候很难冷静下来，从而作出错误的决定。勿以恶小。</p><img src="http://img1.doubanio.com/view/subject/l/public/s1765799.jpg" style="zoom:37%"><p><a href="https://book.douban.com/subject/1827374/" target="_blank" rel="noopener">东方快车谋杀案</a></p><p>★★★★★9.0</p><p>心理描写过于精彩。</p><img src="http://img1.doubanio.com/view/subject/l/public/s27027698.jpg" style="zoom:22%"><p><a href="https://book.douban.com/subject/25697546/" target="_blank" rel="noopener">尼罗河上的惨案</a></p><p>★★★★★8.6</p><p>许多伟大的爱情都是悲剧。重要的不是过去，而是未来。</p><img src="http://img1.doubanio.com/view/subject/l/public/s26716169.jpg" style="zoom:23%"><p><a href="https://book.douban.com/subject/24737009/" target="_blank" rel="noopener">ABC谋杀案</a></p><p>★★★★☆8.3</p><p>一系列谋杀是为了掩盖另一个谋杀。</p><img src="http://img9.doubanio.com/view/subject/l/public/s26841474.jpg" style="zoom:23%"><p><a href="https://book.douban.com/subject/24852594/" target="_blank" rel="noopener">底牌</a></p><p>★★★★☆8.0</p><p>波洛从人性与性格方面入手以及分析真的是太精彩了。还有，犯罪不能纵容，不然会越来越严重。</p><img src="http://img3.doubanio.com/view/subject/l/public/s27988902.jpg" style="zoom:23%"><p><a href="https://book.douban.com/subject/26292535/" target="_blank" rel="noopener">帷幕</a></p><p>★★★★★8.9</p><p>一生都在制止谋杀的人在最后亲自谋杀了一个人渣。有时候，法律也是很无力。</p><h2 id="认真，不麻烦别人"><a href="#认真，不麻烦别人" class="headerlink" title="认真，不麻烦别人"></a>认真，不麻烦别人</h2><blockquote><p>我喜欢认真的人，与此同时最害怕那些把自己的欲望放在第一位、给别人添了麻烦也毫不在乎的人。哪怕他们再遵纪守法，不顾他人感受并且不以为然这一点仍让我觉得可怕，不想和他们做朋友。我总在想，这个世界全靠认真的人才得以运转。</p></blockquote><p>有那么四个人，他们是“十恶不赦”的银行劫匪，但又是四个最可爱的人。他们处处为他人着想，又努力维持正义。</p><p>伊坂幸太郎说他喜欢认真不给别人带来麻烦的人。我觉得，不麻烦别人是最大的美德了吧。</p><p>这是我喜欢伊坂幸太郎小说的一个原因。它给我带来快乐，让我思考，最后成为指导以后做事的准则。</p><p>当然，还有那暖暖的句子啊。</p><blockquote><p>面对一头剃了毛的羊，上天都会让吹到它身上的风变得温柔。</p></blockquote><img src="http://img1.doubanio.com/view/subject/l/public/s33490929.jpg" style="zoom:25%"><p><a href="https://book.douban.com/subject/30157645/" target="_blank" rel="noopener">阳光劫匪日常与袭击</a></p><p>★★★★☆8.2</p><img src="http://img9.doubanio.com/view/subject/l/public/s29787404.jpg" style="zoom:47%"><p><a href="https://book.douban.com/subject/27609210/" target="_blank" rel="noopener">阳光劫匪倒转地球</a></p><p>★★★★☆8.2</p><img src="http://img1.doubanio.com/view/subject/l/public/s33490927.jpg" style="zoom:25%"><p><a href="https://book.douban.com/subject/30203733/" target="_blank" rel="noopener">阳光劫匪友情测试</a></p><p>★★★★☆8.2</p><h2 id="世界很残酷，但还是活着吧"><a href="#世界很残酷，但还是活着吧" class="headerlink" title="世界很残酷，但还是活着吧"></a>世界很残酷，但还是活着吧</h2><p>上班后一年就磨灭了上学时对工作的种种美好的幻想。</p><p>这个世界，真的太残酷了。</p><p>996，ICU，还有那神奇的251天。</p><p>不过，还是要保持乐观哇，活着，就有希望。</p><img src="http://img3.doubanio.com/view/subject/l/public/s29053580.jpg" style="zoom:80%"><p><a href="https://book.douban.com/subject/4913064/" target="_blank" rel="noopener">活着</a></p><p>★★★★★9.4</p><p>死亡永远不是最可怕的，最可怕的是死亡带走身边所有重要的人，独留自己一个。再读《活着》，悲伤double。</p><img src="http://img3.doubanio.com/view/subject/l/public/s24575140.jpg" style="zoom:80%"><p><a href="https://book.douban.com/subject/4760224/" target="_blank" rel="noopener">许三观卖血记</a></p><p>★★★★★9.0</p><p>小人物艰难生存。我们都是小人物。</p><img src="http://img9.doubanio.com/view/subject/l/public/s29864884.jpg" style="zoom:25%"><p><a href="https://book.douban.com/subject/30259153/" target="_blank" rel="noopener">第七天</a></p><p>★★★★☆7.6</p><p>小人物的种种不幸，就像活生生发生在身边。 如果真的有那个地方，那我们是不是可以死后见想见的人，说想说的话，尽情弥补生前的各种悔恨。 不过，那是死无葬身之地。 人间不值得，人间又值得。珍惜吧。</p><img src="http://img1.doubanio.com/view/subject/l/public/s33463759.jpg" style="zoom:50%"><p><a href="https://book.douban.com/subject/34434309/" target="_blank" rel="noopener">82年生的金智英</a></p><p>★★★★☆7.9</p><p>一篇表面是小说本质是韩国现代女性生存现状的报告。作为男生看了也会对这种种的不平等深感震惊与羞愧。我我我，也有责任。</p><img src="http://img9.doubanio.com/view/subject/l/public/s29952694.jpg" style="zoom:25%"><p><a href="https://book.douban.com/subject/30374817/" target="_blank" rel="noopener">小偷家族</a></p><p>★★★★★8.6</p><p>小偷家族没有偷来什么贵重的东西，但是却偷来了最珍贵的亲情，那些在亲人那里得不到的亲情。又是小人物的艰难生存。</p><h2 id="保持好奇，不停学习"><a href="#保持好奇，不停学习" class="headerlink" title="保持好奇，不停学习"></a>保持好奇，不停学习</h2><blockquote><p>心智是宇宙间最宝贵的东西。</p></blockquote><p>克拉克在《太空漫游中》这么说道。我直到现在，才看了大名鼎鼎的《太空漫游》系列。</p><p>这是什么神仙想象！</p><p>与之类似的，是《猎魔人》。</p><blockquote><p>选取一个有趣的时间段，特别是大动荡时期：战争、宗教冲突、政治压迫、革命等等，把你的主角丢进这个女巫的坩埚，让他在里面寻找出路，让他做出抉择，让他因错误的选择而饱受磨难，让他接受洗礼，让他成熟，让他找到或是失去他的真爱、良知、理想和人性。</p></blockquote><p>《猎魔人》作者安德烈·斯帕克沃斯基这样描述历史奇幻小说的创作方法。</p><p>不管是科幻还是奇幻，都需要大量的知识来支撑庞大的背景设定。出于现实而又高于现实，丰富的想象力与创造力必不可少。</p><p>阅读这样的作品，多多少少能提高一点点创造力吧。</p><p>这个世界很奇妙，很有趣，也很复杂。</p><p>但我好想一点点弄懂啊，了解缤纷世界背后的故事。</p><p>只能不断学习。</p><p>阅读《费恩曼物理学讲义》，析万物之理。</p><p>阅读《经济学原理》，明白生活背后的道理。</p><p>看《地理学与生活》，重拾小时候看地图的乐趣。</p><p>不过这三本我都没看完，，，sad。</p><img src="http://img3.doubanio.com/view/subject/l/public/s32323941.jpg" style="zoom:25%"><p><a href="https://book.douban.com/subject/30481003/" target="_blank" rel="noopener">“太空漫游”四部曲</a></p><p>★★★★★9.0</p><img src="http://img3.doubanio.com/view/subject/l/public/s27987690.jpg" style="zoom:40%"><p><a href="https://book.douban.com/subject/26267087/" target="_blank" rel="noopener">猎魔人1：白狼崛起</a></p><p>★★★★★8.6</p><h2 id="其实还有很多"><a href="#其实还有很多" class="headerlink" title="其实还有很多"></a>其实还有很多</h2><p>除了上面那些，2019年也读了很多别的书。比如托尔斯泰的两部大部头《战争与和平》《安娜·卡列尼娜》，2020年，计划多读这样的名著。</p><p>今年，也开始记录计算机专业书籍了。基础知识需要牢固，希望2020年继续巩固自己的知识网络。</p><p>自己之前一直不屑的howto类书籍，今年也开始看了而且真香，明年继续，形成自己的方法论，这比埋头苦干更重要。</p><h2 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h2><p>最后，附上阅读清单。</p><h3 id="一月"><a href="#一月" class="headerlink" title="一月"></a>一月</h3><ol><li><p>《人性记录》阿加莎</p></li><li><p>《云中命案》阿加莎</p></li><li><p>《万圣节前夜的谋杀》阿加莎</p></li><li><p>《大象的证词》阿加莎</p></li><li><p>《寓所谜案》阿加莎</p></li><li><p>《七面钟之谜》阿加莎</p></li><li><p>《悬崖山庄奇案》阿加莎</p></li><li><p>《藏书室女尸之谜》阿加莎</p></li><li><p>《底牌》阿加莎</p></li><li><p>《天涯过客》阿加莎</p></li><li><p>《长夜》阿加莎</p></li><li><p>《怪屋》阿加莎</p></li><li><p>《魔手》阿加莎</p></li><li><p>《古墓之谜》阿加莎</p></li><li><p>《沉默的证人》阿加莎</p></li></ol><h3 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h3><ol start="16"><li><p>《高尔夫球场命案》阿加莎</p></li><li><p>《流浪地球》刘慈欣</p></li><li><p>《桑苏西来客》阿加莎</p></li><li><p>《阳光下的罪恶》阿加莎</p></li><li><p>《谋杀启事》阿加莎</p></li><li><p>《空幻之屋》阿加莎</p></li><li><p>《命案目睹记》阿加莎</p></li><li><p>《葬礼之后》阿加莎</p></li><li><p>《MySQL必知必会》Ben Forta</p></li><li><p>《鸽群中的猫》阿加莎</p></li></ol><h3 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h3><ol start="26"><li><p>《他们来到巴格达》阿加莎</p></li><li><p>《祖先》易中天</p></li><li><p>《国家》易中天</p></li><li><p>《帷幕》阿加莎</p></li><li><p>《奠基者》易中天</p></li><li><p>《青春志》易中天</p></li><li><p>《从春秋到战国》易中天</p></li><li><p>《百家争鸣》易中天</p></li><li><p>《秦并天下》易中天</p></li><li><p>《汉武的帝国》易中天</p></li><li><p>《阳光劫匪友情测试》伊坂幸太郎</p></li></ol><h3 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h3><ol start="37"><li><p>《作死的兔子大全集》安迪 莱利</p></li><li><p>《两汉两罗马》易中天</p></li><li><p>《阳光劫匪倒转地球》伊坂幸太郎</p></li><li><p>《三国纪》易中天</p></li><li><p>《魏晋风度》易中天</p></li><li><p>《南朝，北朝》易中天</p></li><li><p>《隋唐定局》易中天</p></li></ol><h3 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h3><ol start="44"><li><p>《禅宗兴起》易中天</p></li><li><p>《女皇武则天》易中天</p></li><li><p>《安史之乱》易中天</p></li><li><p>《大宋革新》易中天</p></li><li><p>《王安石变法》易中天</p></li><li><p>《风流南宋》易中天</p></li><li><p>《铁血蒙元》易中天</p></li><li><p>《朱明王朝》易中天</p></li><li><p>《阳光劫匪日常与袭击》伊坂幸太郎</p></li></ol><h3 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h3><ol start="53"><li><p>《H庄园的午餐》阿加莎</p></li><li><p>《金色梦乡》伊坂幸太郎</p></li><li><p>《棋王》阿城</p></li><li><p>《许三观卖血记》余华</p></li><li><p>《兄弟上》余华</p></li></ol><h3 id="七月"><a href="#七月" class="headerlink" title="七月"></a>七月</h3><ol start="58"><li><p>《兄弟下》余华</p></li><li><p>《在细雨中呼喊》余华</p></li><li><p>《第七天》余华</p></li><li><p>《大明王朝的七张面孔》张宏杰</p></li><li><p>《黄昏里的男孩》余华</p></li><li><p>《小狗钱钱》博多 费舍尔</p></li><li><p>《战栗》余华</p></li><li><p>《没有一条道路是重复的》余华</p></li></ol><h3 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h3><ol start="66"><li><p>《野性的呼唤》杰克 伦敦</p></li><li><p>《小狗钱钱2》博多 费舍尔</p></li><li><p>《战争与和平》托尔斯泰</p></li></ol><h3 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h3><ol start="69"><li><p>《海边理发店》荻原浩</p></li><li><p>《七堂极简物理课》卡洛 罗韦利</p></li><li><p>《代码整洁之道：程序员的职业素养》罗伯特 马丁</p></li><li><p>《安娜·卡列尼娜》托尔斯泰</p></li><li><p>《活着》余华</p></li><li><p>《给青年的十二封信》朱光潜</p></li><li><p>《牧羊少年的奇幻之旅》保罗 柯艾略</p></li><li><p>《Go语言实战》</p></li><li><p>《半小时漫画中国史1》陈磊</p></li><li><p>《半小时漫画中国史2》陈磊</p></li><li><p>《半小时漫画中国史3》陈磊</p></li><li><p>《半小时漫画世界史》陈磊</p></li><li><p>《哈佛极简中国史》阿尔伯特 克雷格</p></li></ol><h3 id="十月"><a href="#十月" class="headerlink" title="十月"></a>十月</h3><ol start="82"><li><p>《博物馆里的极简中国史》张经纬</p></li><li><p>《两个故宫的离合》夜岛刚</p></li><li><p>《Redis 4.x Cookbook 》</p></li><li><p>《借镜杀人》阿加莎</p></li><li><p>《时间之书》余世存 老树</p></li><li><p>《我在故宫修文物》</p></li><li><p>《这里是中国》</p></li><li><p>《红墙黄瓦》张克群</p></li><li><p>《半小时漫画唐诗》陈磊</p></li><li><p>《半小时漫画唐诗2》陈磊</p></li><li><p>《万古江河》许倬云</p></li><li><p>《这样读书就够了》赵周</p></li><li><p>《半小时漫画经济学》陈磊</p></li><li><p>《半小时漫画经济学2》陈磊</p></li></ol><h3 id="十一月"><a href="#十一月" class="headerlink" title="十一月"></a>十一月</h3><ol start="96"><li><p>《四魔头》阿加莎</p></li><li><p>《地理的故事》房龙</p></li><li><p>《何以中国》许宏</p></li><li><p>《日本人为何选择了战争》加藤阳子</p></li><li><p>《思维导图》胡雅茹</p></li><li><p>《万物发明指南》瑞安 诺思</p></li><li><p>《2001：太空漫游》克拉克</p></li><li><p>《如何高效学习》斯科特 杨</p></li><li><p>《2010：太空漫游》克拉克</p></li></ol><h3 id="十二月"><a href="#十二月" class="headerlink" title="十二月"></a>十二月</h3><ol start="105"><li><p>《2061：太空漫游》克拉克</p></li><li><p>《3001：太空漫游》克拉克</p></li><li><p>《82年生的金智英》赵南柱</p></li><li><p>《山茶文具店》小川糸</p></li><li><p>《少帅》张爱玲</p></li><li><p>《Go Web编程》</p></li><li><p>《猎魔人1：白狼崛起》斯帕克沃斯基</p></li><li><p>《小偷家族》是枝裕和</p></li><li><p>《猎魔人2：宿命之剑》斯帕克沃斯基</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Web (Part 2): Request</title>
      <link href="/go-web-part-2-request/"/>
      <url>/go-web-part-2-request/</url>
      
        <content type="html"><![CDATA[<p>在了解了使用<code>net/http</code>构建go web服务之后，这篇文章深入了解一下在Go中如何处理一个请求。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb7.png"><h3 id="1-请求包含什么"><a href="#1-请求包含什么" class="headerlink" title="1. 请求包含什么"></a>1. 请求包含什么</h3><p>HTTP Message有Request和Response两种。这里详细看看Request Message，一个请求消息的格式如下：</p><pre class="line-numbers language-shell"><code class="language-shell">method request-URL versionheadersentity-body<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Go中的<code>net/http</code>包提供了一个用于表示HTTP请求消息的结构<code>Reqeust</code>。<code>Request</code>将上面请求消息的内容经过分析后存储在不同的字段中，还包括一系列有用的方法。主要的字段有：</p><ul><li>URL</li><li>Header</li><li>Body</li><li>Form, PostForm, MultipartForm</li></ul><p>除了这些字段，还可以使用<code>Request</code>的一些方法处理请求中的cookie等。</p><h3 id="2-URL"><a href="#2-URL" class="headerlink" title="2. URL"></a>2. URL</h3><p><code>Request</code>中的<code>URL</code>字段可以存储请求中URL的信息，在<code>Reqeuest</code>中的<code>URL</code>字段是一个指向<code>net/url</code>包中<code>URL</code>结构的指针，<code>URL</code>结构主要字段如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> URL <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Scheme     <span class="token builtin">string</span>    User       <span class="token operator">*</span>Userinfo <span class="token comment" spellcheck="true">// username and password information</span>    Host       <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// host or host:port</span>    Path       <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// path (relative paths may omit leading slash)</span>    RawPath    <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// encoded path hint (see EscapedPath method)</span>    RawQuery   <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// encoded query values, without '?'</span>    Fragment   <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// fragment for references, without '#'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>URL的一般格式是这样的：</p><pre class="line-numbers language-shell"><code class="language-shell">scheme://[userinfo@]host/path[?query][#fragment]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中[]中的是可选的信息。</p><p>在<code>net/url</code>包中有解析URL的函数<code>Parse()</code>和<code>ParseRequestURI()</code>，两者都是将传进来的URL解析成一个<code>URL</code>结构并返回这个<code>URL</code>的指针。</p><p>比如这个URL：<a href="https://book.douban.com/people/valineliu/collect?start=30&amp;sort=time&amp;rating=all&amp;filter=all&amp;mode=list#here" target="_blank" rel="noopener">https://book.douban.com/people/valineliu/collect?start=30&amp;sort=time&amp;rating=all&amp;filter=all&amp;mode=list#here</a></p><p>解析之后的结果如下：</p><table><thead><tr><th>Field</th><th>Value</th></tr></thead><tbody><tr><td><code>Scheme</code></td><td>https</td></tr><tr><td><code>Host</code></td><td>book.douban.com</td></tr><tr><td><code>Path</code></td><td>/people/valineliu/collect</td></tr><tr><td><code>RawQuery</code></td><td>start=0&amp;sort=time&amp;rating=all&amp;filter=all&amp;mode=list</td></tr><tr><td><code>Fragment</code></td><td>here</td></tr></tbody></table><p><code>Parse()</code>和<code>ParseRequestURI()</code>不解析<code>RawPath</code>字段，需要调用<code>URL.EscapedPath()</code>函数来获得这个字段值。</p><p><code>RawQuery</code>字段包含了没有解析的查询参数，可以通过对这个参数的解析获得URL中的查询参数，不过可以直接使用<code>Request</code>结构中的<code>Form</code>字段来获取，后面再详细介绍。</p><p>还有一个需要注意的问题就是，如果请求是通过浏览器发送的话，程序就得不到<code>Fragment</code>字段，因为浏览器会截断<code>Fragment</code>，与<code>net/http</code>库无关。</p><h3 id="3-Header"><a href="#3-Header" class="headerlink" title="3. Header"></a>3. Header</h3><p>HTTP请求和响应消息都有一个Header结构，在go中，<code>net/http</code>包中有一个<code>Header</code>结构来存储Header结构。</p><p><code>Header</code>本质上就是一个<code>map</code>，定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Header <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不过值是一个<code>[]string</code>，也就是说，对一个key可以有多个值。</p><p><code>Header</code>有四个基本方法，可以方便地对内容进行操作，分别是<code>Add</code>, <code>Del</code>, <code>Set</code>, <code>Get</code>。其中<code>Set</code>方法会对已有的值进行覆盖。</p><p>除了<code>Get</code>方法外，还可以直接访问<code>Header</code>中某个key的值：</p><pre class="line-numbers language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Header<span class="token punctuation">[</span><span class="token string">"Accept-Encoding"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就像访问一个<code>map</code>一样。这种方式和<code>Get</code>的区别在于，直接访问得到的是一个字符串切片，而使用<code>Get</code>方法得到的是所有的值用逗号分割的字符串：</p><pre class="line-numbers language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Header<span class="token punctuation">[</span><span class="token string">"Accept-Encoding"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"Accept-Encoding"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">[gzip, deflate, br]gzip, deflate, br<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-Body"><a href="#4-Body" class="headerlink" title="4. Body"></a>4. Body</h3><p><code>Request</code>中的<code>Body</code>不仅是请求的Body，也是响应的Body，这里不展开描述。</p><p><code>Body</code>是一个<code>io.ReaderCloser</code>接口，意味着可以调用<code>Read</code>和<code>Close</code>两个方法。下面的例子描述了如何读取请求中的Body：</p><pre class="line-numbers language-go"><code class="language-go">length <span class="token operator">:=</span> r<span class="token punctuation">.</span>ContentLengthbody <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span>r<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>Request</code>中有一个<code>ContentLength</code>字段，这个字段记录了Body的长度，可以通过这个字段指定长度来读取Body中的内容。</p><p>GET请求没有Body，所以需要一个POST请求，可以使用curl：</p><pre class="line-numbers language-shell"><code class="language-shell">curl -id "start=30&sort=time&rating=all&filter=all&mode=list" localhost:8080/world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就可以得到Body了：</p><pre class="line-numbers language-shell"><code class="language-shell">start=30&sort=time&rating=all&filter=all&mode=list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-Form-PostForm-amp-MultipartForm"><a href="#5-Form-PostForm-amp-MultipartForm" class="headerlink" title="5. Form, PostForm &amp; MultipartForm"></a>5. Form, PostForm &amp; MultipartForm</h3><p>前面几个字段在请求达到服务器的时候就通过一定的流程解析出来了，而<code>Request</code>中的这几个关于Form的字段不是自动解析的，需要手动调用各自对应的函数来解析。</p><h4 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h4><p>这几个字段的定义如下：</p><pre class="line-numbers language-go"><code class="language-go">Form url<span class="token punctuation">.</span>ValuesPostForm url<span class="token punctuation">.</span>ValuesMultipartForm <span class="token operator">*</span>multipart<span class="token punctuation">.</span>Form<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中<code>Form</code>和<code>PostForm</code>类型一样：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Values <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也就是一个<code>map</code>，key是字符串，而值是一个字符串切片。即，对于一个key来说，可以有多个值。</p><p><code>MultipartForm</code>的类型不一样：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Form <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Value <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>    File  <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>FileHeader<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>多了一个<code>File</code>字段，这是因为<code>MultipartForm</code>还需要存储文件。</p><p>请求中的参数可以在URL中，也就是这种格式：<code>/people/valineliu/collect?start=30&amp;sort=time</code>，也可以在Body中，比如：<code>curl -id &quot;start=40&quot; localhost:8080/world</code>。同时请求消息中Body中的数据可以通过不同的格式编码发送给服务器。其中常用的有<code>application/x-www-form-urlencoded</code>和<code>multipart/form-data</code>。前一种格式可以将Body中的参数按照URL中参数的格式编码，而后者会将数据编码成一条MIME报文。</p><p>这就导致，三种Form字段在不同的编码方式下能够获得的数据也是不一样的。</p><h4 id="5-2-Form-amp-PostForm"><a href="#5-2-Form-amp-PostForm" class="headerlink" title="5.2 Form &amp; PostForm"></a>5.2 Form &amp; PostForm</h4><p>为了获得<code>Form</code>和<code>PostForm</code>字段，需要调用<code>ParseForm</code>方法：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">ParseForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> err <span class="token builtin">error</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>PostForm <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> r<span class="token punctuation">.</span>Method <span class="token operator">==</span> <span class="token string">"POST"</span> <span class="token operator">||</span> r<span class="token punctuation">.</span>Method <span class="token operator">==</span> <span class="token string">"PUT"</span> <span class="token operator">||</span> r<span class="token punctuation">.</span>Method <span class="token operator">==</span> <span class="token string">"PATCH"</span> <span class="token punctuation">{</span>            r<span class="token punctuation">.</span>PostForm<span class="token punctuation">,</span> err <span class="token operator">=</span> <span class="token function">parsePostForm</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> r<span class="token punctuation">.</span>PostForm <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            r<span class="token punctuation">.</span>PostForm <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span>Values<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>Form <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>PostForm<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>            r<span class="token punctuation">.</span>Form <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span>Values<span class="token punctuation">)</span>            <span class="token function">copyValues</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Form<span class="token punctuation">,</span> r<span class="token punctuation">.</span>PostForm<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">var</span> newValues url<span class="token punctuation">.</span>Values        <span class="token keyword">if</span> r<span class="token punctuation">.</span>URL <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> e <span class="token builtin">error</span>            newValues<span class="token punctuation">,</span> e <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">ParseQuery</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>RawQuery<span class="token punctuation">)</span>            <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                err <span class="token operator">=</span> e            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> newValues <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            newValues <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span>Values<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> r<span class="token punctuation">.</span>Form <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            r<span class="token punctuation">.</span>Form <span class="token operator">=</span> newValues        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">copyValues</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Form<span class="token punctuation">,</span> newValues<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> err<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数是幂等的，也就是多次调用效果一样。从这个解析过程可以发现：</p><ul><li>函数首先解析<code>PostForm</code>字段，然后解析<code>Form</code>字段；</li><li>而在<code>parsePostForm()</code>函数中，只对Body中<code>application/x-www-form-urlencoded</code>编码的参数解析，其余编码格式下<code>PostForm</code>字段为空；</li><li><code>Form</code>中包含<code>PostForm</code>中的信息，而且<code>PostForm</code>中的信息优先级高；</li><li>URL中的参数只会到被解析到<code>Form</code>字段中。</li></ul><p>下面的例子演示了上面的分析：</p><pre class="line-numbers language-go"><code class="language-go">r<span class="token punctuation">.</span><span class="token function">ParseForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span>Form<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span>PostForm<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用curl模拟一个请求：</p><pre class="line-numbers language-shell"><code class="language-shell">curl -id "start=30&mode=list" "localhost:8080/world?start=40&sort=time"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">map[mode:[list] sort:[time] start:[30 40]]map[mode:[list] start:[30]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一个<code>map</code>是<code>Form</code>，第二个是<code>PostForm</code>，从结果可以看到两者的区别。</p><h4 id="5-3-MultipartForm"><a href="#5-3-MultipartForm" class="headerlink" title="5.3 MultipartForm"></a>5.3 MultipartForm</h4><p>对于<code>MultipartForm</code>，需要调用<code>ParseMultipartForm</code>方法，这个方法会在需要的时候（也就是<code>Form</code>和<code>PostForm</code>为<code>nil</code>的时候）调用<code>ParseForm</code>方法先来解析<code>Form</code>和<code>PostForm</code>两个字段：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">ParseMultipartForm</span><span class="token punctuation">(</span>maxMemory <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>MultipartForm <span class="token operator">==</span> multipartByReader <span class="token punctuation">{</span>        <span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"http: multipart handled by MultipartReader"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>Form <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">ParseForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> err        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>MultipartForm <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span>    mr<span class="token punctuation">,</span> err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">multipartReader</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> err    <span class="token punctuation">}</span>    f<span class="token punctuation">,</span> err <span class="token operator">:=</span> mr<span class="token punctuation">.</span><span class="token function">ReadForm</span><span class="token punctuation">(</span>maxMemory<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> err    <span class="token punctuation">}</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>PostForm <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        r<span class="token punctuation">.</span>PostForm <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span>Values<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> f<span class="token punctuation">.</span>Value <span class="token punctuation">{</span>        r<span class="token punctuation">.</span>Form<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Form<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token operator">...</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// r.PostForm should also be populated. See Issue 9305.</span>        r<span class="token punctuation">.</span>PostForm<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>PostForm<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    r<span class="token punctuation">.</span>MultipartForm <span class="token operator">=</span> f    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时需要一个最大读取字节数的参数。</p><p>从这个解析过程可以看到：</p><ul><li>如果<code>Form</code>和<code>PostForm</code>为<code>nil</code>的话，这个函数就先调用<code>ParseForm</code>来进行解析；</li><li>不过如果编码格式是<code>multipart/form-data</code>的话，<code>Form</code>中就只会有URL中的参数，而<code>PostForm</code>中啥也没有（暂时）；</li><li><code>ParseMultipartForm</code>方法会解析Body中<code>multipart/form-data</code>格式的数据到<code>MultipartForm</code>字段中；</li><li>最后还会将Body中的参数添加到<code>Form</code>和<code>PostForm</code>中。</li></ul><p>例子：</p><pre class="line-numbers language-go"><code class="language-go">r<span class="token punctuation">.</span><span class="token function">ParseMultipartForm</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span>Form<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span>PostForm<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span>MultipartForm<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用curl模拟一个请求：</p><pre class="line-numbers language-shell"><code class="language-shell">curl -F "start=30" -F "mode=list" -F upload=@hello "localhost:8080/world?start=40&sort=time"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中前两个-F生成两个<code>multipart/form-data</code>格式的参数，而后一个-F上传一个文件。结果：</p><pre class="line-numbers language-shell"><code class="language-shell">map[mode:[list] sort:[time] start:[40 30]]map[mode:[list] start:[30]]&{map[mode:[list] start:[30]] map[upload:[0xc0000fa140]]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>前两个<code>map</code>还是和之前的一样，最后一个就是<code>MultipartForm</code>，这是两个<code>map</code>，一个是Body中的参数，一个是上传的文件。</p><p>关于<code>Form</code>和之前有一个不同，就是<code>start</code>值的顺序。之前使用<code>ParseForm</code>解析的时候30在前而现在40在前。从两个函数的代码中我们可以看到这个结果的原因。</p><h4 id="5-4-Another-Way"><a href="#5-4-Another-Way" class="headerlink" title="5.4 Another Way"></a>5.4 Another Way</h4><p>除了上面调用<code>ParseForm</code>和<code>ParseMultipartForm</code>函数外，还可以通过其它的方法获取值：<code>FormValue()</code>和<code>PostFormValue()</code>。两个方法的定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">FormValue</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>Form <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        r<span class="token punctuation">.</span><span class="token function">ParseMultipartForm</span><span class="token punctuation">(</span>defaultMaxMemory<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> vs <span class="token operator">:=</span> r<span class="token punctuation">.</span>Form<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">len</span><span class="token punctuation">(</span>vs<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> vs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">PostFormValue</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>PostForm <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        r<span class="token punctuation">.</span><span class="token function">ParseMultipartForm</span><span class="token punctuation">(</span>defaultMaxMemory<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> vs <span class="token operator">:=</span> r<span class="token punctuation">.</span>PostForm<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">len</span><span class="token punctuation">(</span>vs<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> vs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两个函数都会在必要的时候调用<code>ParseMultipartForm</code>函数来进行解析。和前面的方法不同在于，这两个方法返回的是对应key的第一个value值，而不是一个字符串切片。</p><p>例子：</p><pre class="line-numbers language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span><span class="token function">FormValue</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span><span class="token function">PostFormValue</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">4030<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个结果很奇怪是吧，所以对于既在URL中也在Body中的参数，在获取的时候需要小心一些。最好的办法就是参数只出现在一个地方，要么URL中，要么Body中。</p><p>其实常用的编码还有<code>application/json</code>，也就是读取的Body数据可以解析成一个Json结构，这也很常见，不过不在这里细说了。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb8.png"><p>To Be Continued…</p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Web (Part 1): Handler &amp; ServeMux</title>
      <link href="/go-web-part-1-handler-servemux/"/>
      <url>/go-web-part-1-handler-servemux/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Begin"><a href="#1-Begin" class="headerlink" title="1. Begin"></a>1. Begin</h3><p>使用Go语言的标准库<code>net/http</code>可以快速构建一个简单的web服务。这篇文章从零开始构建一个简单的web服务器，并主要聚焦于处理器Handler和多路复用器ServeMux。</p><p>在开始之前，MindMap里一无所有：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb1.png"><h3 id="2-The-Simplest-Server"><a href="#2-The-Simplest-Server" class="headerlink" title="2. The Simplest Server"></a>2. The Simplest Server</h3><p>使用<code>net/http</code>包中的<code>ListenAndServe()</code>函数可以快速构建一个最简单的服务器：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>go run</code>命令执行程序，然后在本地浏览器打开<a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> ，得到<code>404 page not found</code>的错误。</p><p>这就是一个最简单的服务器，什么也不做，但确实是一个服务器。</p><p>现在MindMap里多了点东西：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb2.png"><h3 id="3-发生了什么"><a href="#3-发生了什么" class="headerlink" title="3. 发生了什么"></a>3. 发生了什么</h3><p>调用<code>http.ListenAndServe()</code>函数就可以启动一个服务器，那么发生了什么呢？</p><p>查看源码可知这个函数的实现：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span>addr <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    server <span class="token operator">:=</span> <span class="token operator">&amp;</span>Server<span class="token punctuation">{</span>Addr<span class="token punctuation">:</span> addr<span class="token punctuation">,</span> Handler<span class="token punctuation">:</span> handler<span class="token punctuation">}</span>    <span class="token keyword">return</span> server<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>原来是通过构造一个<code>Server</code>并调用这个<code>Server</code>的<code>ListenAndServe()</code>函数实现的。</p><p>那也就是说，我们可以自己构造一个<code>Server</code>，然后启动服务器：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    s <span class="token operator">:=</span> http<span class="token punctuation">.</span>Server<span class="token punctuation">{</span>        Addr<span class="token punctuation">:</span>    <span class="token string">"127.0.0.1:8080"</span><span class="token punctuation">,</span>        Handler<span class="token punctuation">:</span> <span class="token boolean">nil</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    s<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动之后结果一样（如果端口被占用可以换一个端口）。</p><p>使用<code>http.ListenAndServe()</code>函数可以使用两个参数（<code>Addr</code>服务器地址和<code>Handler</code>处理器）就可以启动一个简单的服务。如果需要更加复杂的设置，需要使用<code>Server</code>结构。<code>Server</code>定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// A Server defines parameters for running an HTTP server.</span><span class="token comment" spellcheck="true">// The zero value for Server is a valid configuration.</span><span class="token keyword">type</span> Server <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Addr    <span class="token builtin">string</span>  <span class="token comment" spellcheck="true">// TCP address to listen on, ":http" if empty</span>    Handler Handler <span class="token comment" spellcheck="true">// handler to invoke, http.DefaultServeMux if nil</span>    TLSConfig <span class="token operator">*</span>tls<span class="token punctuation">.</span>Config    ReadTimeout time<span class="token punctuation">.</span>Duration    ReadHeaderTimeout time<span class="token punctuation">.</span>Duration    WriteTimeout time<span class="token punctuation">.</span>Duration    IdleTimeout time<span class="token punctuation">.</span>Duration    MaxHeaderBytes <span class="token builtin">int</span>    TLSNextProto <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>Server<span class="token punctuation">,</span> <span class="token operator">*</span>tls<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> Handler<span class="token punctuation">)</span>    ConnState <span class="token keyword">func</span><span class="token punctuation">(</span>net<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> ConnState<span class="token punctuation">)</span>    ErrorLog <span class="token operator">*</span>log<span class="token punctuation">.</span>Logger    BaseContext <span class="token keyword">func</span><span class="token punctuation">(</span>net<span class="token punctuation">.</span>Listener<span class="token punctuation">)</span> context<span class="token punctuation">.</span>Context    ConnContext <span class="token keyword">func</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> c net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> context<span class="token punctuation">.</span>Context<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，MindMap中又多了点东西，也知道了一些关联：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb3.png"><h3 id="3-处理器Handler"><a href="#3-处理器Handler" class="headerlink" title="3. 处理器Handler"></a>3. 处理器Handler</h3><p>由于<code>Handler</code>为空，所以这个服务器什么也不做只是返回404。为了让服务器做事情，需要添加处理器Handler：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> MyHandler <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mh <span class="token operator">*</span>MyHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    s <span class="token operator">:=</span> http<span class="token punctuation">.</span>Server<span class="token punctuation">{</span>        Addr<span class="token punctuation">:</span>    <span class="token string">"127.0.0.1:8080"</span><span class="token punctuation">,</span>        Handler<span class="token punctuation">:</span> <span class="token operator">&amp;</span>MyHandler<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    s<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果就是得到了一个<code>Hello World</code>。</p><p>这里定义了一个简单的处理器<code>MyHandler</code>，然后添加到定义的<code>Server</code>中。</p><p>所以为了让服务器有事情做，需要定义<code>Handler</code>告诉它做什么。一个<code>Handler</code>其实是一个接口：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Handler <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>任何结构只要有一个签名是这样的函数，都可以作为<code>Server</code>的处理器；同样，任何接受这两个参数的函数，也可以当做一个处理器。</p><p>不过这么做有个明显的缺陷就是，服务器不会通过URL来将请求路由到不同的处理器。为了能根据URL处理不同的请求，我们需要多个处理器。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb4.png"><h3 id="4-多个Handler"><a href="#4-多个Handler" class="headerlink" title="4. 多个Handler"></a>4. 多个Handler</h3><p>直接对<code>Server</code>指定<code>Handler</code>只能添加一个处理器，为了支持多个处理器，需要别的做法：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> HelloHandler <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>hh <span class="token operator">*</span>HelloHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">type</span> WorldHandler <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>wh <span class="token operator">*</span>WorldHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    s <span class="token operator">:=</span> http<span class="token punctuation">.</span>Server<span class="token punctuation">{</span>        Addr<span class="token punctuation">:</span> <span class="token string">"127.0.0.1:8080"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>HelloHandler<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/world"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>WorldHandler<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    s<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里定义了两个<code>Handler</code>，然后通过<code>http.Handle()</code>函数注册这两个<code>Handler</code>而不是直接对<code>Server</code>指定，这样就可以使用两个处理器了。在浏览器中分别访问<a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a> 和 <a href="http://localhost:8080/world" target="_blank" rel="noopener">http://localhost:8080/world</a> 可以得到不同的结果。</p><p>来看看<code>http.Handle()</code>函数做了什么：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Handle registers the handler for the given pattern</span><span class="token comment" spellcheck="true">// in the DefaultServeMux.</span><span class="token comment" spellcheck="true">// The documentation for ServeMux explains how patterns are matched.</span><span class="token keyword">func</span> <span class="token function">Handle</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token punctuation">{</span> DefaultServeMux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> handler<span class="token punctuation">)</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>原来是把具体的<code>Handler</code>注册到了一个叫做<code>DefaultServeMux</code>的变量里，在详细看看具体做了什么之前，先看看处理器函数<code>HandlerFunc</code>。</p><h3 id="5-处理器函数HandlerFunc"><a href="#5-处理器函数HandlerFunc" class="headerlink" title="5. 处理器函数HandlerFunc"></a>5. 处理器函数HandlerFunc</h3><p>除了使用Handler结构外，还可以使用具有相同参数的函数，只不过需要使用<code>http.HandleFunc()</code>函数：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">world</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    s <span class="token operator">:=</span> http<span class="token punctuation">.</span>Server<span class="token punctuation">{</span>        Addr<span class="token punctuation">:</span> <span class="token string">"127.0.0.1:8080"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span> hello<span class="token punctuation">)</span>    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/world"</span><span class="token punctuation">,</span> world<span class="token punctuation">)</span>    s<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果和使用<code>http.Handle()</code>一样。处理器函数能够完成和处理器一样的功能，代码也更简洁一些。可以在实际使用中根据不同场景使用不同的方式。比如，如果代码中已经有处理的接口，只需要添加一个<code>ServeHTTP</code>函数就可以把这个接口转换成处理器了。</p><p>来看看<code>http.HandleFunc()</code>做了什么：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// HandleFunc registers the handler function for the given pattern</span><span class="token comment" spellcheck="true">// in the DefaultServeMux.</span><span class="token comment" spellcheck="true">// The documentation for ServeMux explains how patterns are matched.</span><span class="token keyword">func</span> <span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    DefaultServeMux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>又是<code>DefaultServeMux</code>，接下来详细看看这个是什么，以及它是怎么和<code>Server</code>关联起来的。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb5.png"><h3 id="6-多路复用器ServeMux和DefaultServeMux"><a href="#6-多路复用器ServeMux和DefaultServeMux" class="headerlink" title="6. 多路复用器ServeMux和DefaultServeMux"></a>6. 多路复用器ServeMux和DefaultServeMux</h3><p>不管使用<code>http.Handle()</code>注册处理器<code>Handler</code>还是使用<code>http.HandleFunc()</code>注册处理器函数<code>HandlerFunc</code>，内部都涉及到了一个变量<code>DefaultServeMux</code>，这个是默认的多路复用器，即<code>ServeMux</code>的一个实例：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// DefaultServeMux is the default ServeMux used by Serve.</span><span class="token keyword">var</span> DefaultServeMux <span class="token operator">=</span> <span class="token operator">&amp;</span>defaultServeMux<span class="token keyword">var</span> defaultServeMux ServeMux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>多路复用器的作用就是根据URL将不同的请求路由到不同的处理器上进行处理：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/servemux.PNG"><p><code>ServeMux</code>结构里有一个<code>map</code>，用来保存路由和处理器的映射：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> ServeMux <span class="token keyword">struct</span> <span class="token punctuation">{</span>    mu    sync<span class="token punctuation">.</span>RWMutex    m     <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>muxEntry    es    <span class="token punctuation">[</span><span class="token punctuation">]</span>muxEntry <span class="token comment" spellcheck="true">// slice of entries sorted from longest to shortest.</span>    hosts <span class="token builtin">bool</span>       <span class="token comment" spellcheck="true">// whether any patterns contain hostnames</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而<code>ServeMux</code>的<code>Handle()</code>和<code>HandleFunc()</code>函数就是将处理器注册到这个<code>map</code>里的。</p><p>不过<code>HandleFunc()</code>怎么把一个函数变成一个处理器呢？</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// HandleFunc registers the handler function for the given pattern.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> handler <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"http: nil handler"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    mux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> <span class="token function">HandlerFunc</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原来使用了一个名叫<code>HandlerFunc</code>的结构（注意和<code>http.HandleFunc</code>的区别）完成了转换。<code>HandlerFunc</code>定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// The HandlerFunc type is an adapter to allow the use of</span><span class="token comment" spellcheck="true">// ordinary functions as HTTP handlers. If f is a function</span><span class="token comment" spellcheck="true">// with the appropriate signature, HandlerFunc(f) is a</span><span class="token comment" spellcheck="true">// Handler that calls f.</span><span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// ServeHTTP calls f(w, r).</span><span class="token keyword">func</span> <span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们就理解了不管是<code>http.Handle()</code>还是<code>http.HandleFunc()</code>最终都归结于<code>ServeMux.Handle()</code>。如果不指定<code>ServeMux</code>的话，就使用默认的<code>DefaultServeMux</code>。</p><p>还需要注意一点就是，<code>ServeMux</code>本身也实现了<code>ServeHTTP()</code>函数，也是可以作为处理器的，这就是<code>DefaultServeMux</code>可以作为处理器的原因。</p><h3 id="7-ServeMux是如何路由的"><a href="#7-ServeMux是如何路由的" class="headerlink" title="7. ServeMux是如何路由的"></a>7. ServeMux是如何路由的</h3><p>我们已经大致了解了<code>ServeMux</code>是根据内部维护的一个<code>map</code>来找到具体的处理器的。这里来看看具体的实现细节，对于理解整个流程很有帮助。</p><p>回到最开始，不管是使用<code>http.ListenAndServe()</code>还是<code>Server.ListenAndServe()</code>，都是需要先<code>Listen</code>然后<code>Serve</code>，主要的过程就是创建一个TCP链接然后监听请求，最终就是到<code>serve()</code>函数里，主要代码如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">serve</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>    serverHandler<span class="token punctuation">{</span>c<span class="token punctuation">.</span>server<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> w<span class="token punctuation">.</span>req<span class="token punctuation">)</span>    <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用了一个叫做<code>serverHandler</code>的代理：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> serverHandler <span class="token keyword">struct</span> <span class="token punctuation">{</span>    srv <span class="token operator">*</span>Server<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>sh serverHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>rw ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    handler <span class="token operator">:=</span> sh<span class="token punctuation">.</span>srv<span class="token punctuation">.</span>Handler    <span class="token keyword">if</span> handler <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        handler <span class="token operator">=</span> DefaultServeMux    <span class="token punctuation">}</span>    <span class="token keyword">if</span> req<span class="token punctuation">.</span>RequestURI <span class="token operator">==</span> <span class="token string">"*"</span> <span class="token operator">&amp;&amp;</span> req<span class="token punctuation">.</span>Method <span class="token operator">==</span> <span class="token string">"OPTIONS"</span> <span class="token punctuation">{</span>        handler <span class="token operator">=</span> globalOptionsHandler<span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span>    handler<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>rw<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这里可以看到<code>DefaultServeMux</code>就是默认的多路复用器。所以如果给<code>Server</code>指定了一个<code>Handler</code>，那么就会调用这个<code>Handler</code>的<code>ServeHTTP()</code>函数；如果没有指定的话，就调用<code>DefaultServeMux</code>的<code>ServeHTTP()</code>函数，毕竟我们在前面已经知道<code>DefaultServeMux</code>就是<code>ServeMux</code>的一个实例，而<code>ServeMux</code>实现了<code>ServeHTTP()</code>函数：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// ServeHTTP dispatches the request to the handler whose</span><span class="token comment" spellcheck="true">// pattern most closely matches the request URL.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>RequestURI <span class="token operator">==</span> <span class="token string">"*"</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> r<span class="token punctuation">.</span><span class="token function">ProtoAtLeast</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Connection"</span><span class="token punctuation">,</span> <span class="token string">"close"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>StatusBadRequest<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    h<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">Handler</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>    h<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数所做的就是根据请求找到对应的<code>Handler</code>，然后让这个处理器完成具体的工作。下面就是<code>ServeMux.Handler()</code>函数的主要部分<code>ServeMux.handler()</code>：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// handler is the main implementation of Handler.</span><span class="token comment" spellcheck="true">// The path is known to be in canonical form, except for CONNECT methods.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">handler</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> path <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>h Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// Host-specific pattern takes precedence over generic ones</span>    <span class="token keyword">if</span> mux<span class="token punctuation">.</span>hosts <span class="token punctuation">{</span>        h<span class="token punctuation">,</span> pattern <span class="token operator">=</span> mux<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>host <span class="token operator">+</span> path<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        h<span class="token punctuation">,</span> pattern <span class="token operator">=</span> mux<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        h<span class="token punctuation">,</span> pattern <span class="token operator">=</span> <span class="token function">NotFoundHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">""</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>里面调用了<code>ServeMux.match()</code>函数，其实就是根据URL到<code>map</code>去找具体的<code>Handler</code>：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Find a handler on a handler map given a path string.</span><span class="token comment" spellcheck="true">// Most-specific (longest) pattern wins.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">match</span><span class="token punctuation">(</span>path <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>h Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Check for exact match first.</span>    v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> mux<span class="token punctuation">.</span>m<span class="token punctuation">[</span>path<span class="token punctuation">]</span>    <span class="token keyword">if</span> ok <span class="token punctuation">{</span>        <span class="token keyword">return</span> v<span class="token punctuation">.</span>h<span class="token punctuation">,</span> v<span class="token punctuation">.</span>pattern    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Check for longest valid match.  mux.es contains all patterns</span>    <span class="token comment" spellcheck="true">// that end in / sorted from longest to shortest.</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> e <span class="token operator">:=</span> <span class="token keyword">range</span> mux<span class="token punctuation">.</span>es <span class="token punctuation">{</span>        <span class="token keyword">if</span> strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> e<span class="token punctuation">.</span>pattern<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> e<span class="token punctuation">.</span>h<span class="token punctuation">,</span> e<span class="token punctuation">.</span>pattern        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，精确匹配，找到了就返回。如果没有找到，就根据一定的规则来找，最后如果还没有找到，那么返回404。</p><p>在后面的那个循环中，来找最长匹配的URL。<code>mux.es</code>是一个切片，这里存储的都是在注册<code>Handler</code>时模式以<code>/</code>结尾的：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">Handle</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>    <span class="token keyword">if</span> pattern<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'/'</span> <span class="token punctuation">{</span>        mux<span class="token punctuation">.</span>es <span class="token operator">=</span> <span class="token function">appendSorted</span><span class="token punctuation">(</span>mux<span class="token punctuation">.</span>es<span class="token punctuation">,</span> e<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就清楚了，路由过程如下：</p><ol><li>精确匹配，找到就返回；</li><li>如果没有精确匹配到，就到所有注册<code>Handler</code>时模式以<code>/</code>结尾的模式中寻找，原则是最长匹配；</li><li>还没有找到的话，就404。</li></ol><p>举个例子，比如注册时将<code>hello</code>这个处理器注册到了<code>/hello/</code>下，那么对于<code>/hello/wrong</code>这个请求如果精确匹配没找到的话就可以匹配<code>/hello/</code>，因为这个模式以<code>/</code>结尾；如果注册<code>hello</code>处理器的时候模式是<code>/hello</code>的话，那就不会把<code>/hello/wrong</code>路由到<code>/hello</code>对应的处理器上来了。</p><p><code>ServeMux</code>有一个缺点就是无法使用变量来实现URL模式匹配，比如<code>/post/123</code>这种，可以使用第三方库来避开这个限制。</p><p>这篇文章梳理了一下<code>net/http</code>包中下面的几个概念：</p><ul><li><code>http.ListenAndServe()</code></li><li><code>Server.ListenAndServe()</code></li><li><code>http.Handle()</code></li><li><code>Handler</code></li><li><code>http.HandleFunc()</code></li><li><code>HandlerFunc</code></li><li><code>DefaultServeMux</code></li></ul><p>而在我们的MindMap中，形成了下面的结构：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb6.png"><p>To Be Continued…</p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What Happens When Using LOAD DATA</title>
      <link href="/what-happens-when-using-load-data/"/>
      <url>/what-happens-when-using-load-data/</url>
      
        <content type="html"><![CDATA[<p>在之前的文章<a href="https://deuterium.fun/files-to-mysql/">Files to MySQL</a>中简单介绍了mysqlimport和<code>LOAD DATA</code>的使用，也知道了mysqlimport其实就是使用了<code>LOAD DATA</code>语句。在这篇文章中详细介绍一下<code>LOAD DATA</code>这个语句，来看看当使用这个语句导入数据时到底发生了什么以及一些需要注意的地方。</p><h3 id="1-从Manual开始"><a href="#1-从Manual开始" class="headerlink" title="1. 从Manual开始"></a>1. 从Manual开始</h3><p>在<a href="https://dev.mysql.com/doc/refman/8.0/en/load-data.html" target="_blank" rel="noopener">MySQL手册</a>中详细介绍了<code>LOAD DATA</code>这个语句。下面是这个语句的格式：</p><pre class="line-numbers language-mysql"><code class="language-mysql">LOAD DATA    [LOW_PRIORITY | CONCURRENT] [LOCAL]    INFILE 'file_name'    [REPLACE | IGNORE]    INTO TABLE tbl_name    [PARTITION (partition_name [, partition_name] ...)]    [CHARACTER SET charset_name]    [{FIELDS | COLUMNS}        [TERMINATED BY 'string']        [[OPTIONALLY] ENCLOSED BY 'char']        [ESCAPED BY 'char']    ]    [LINES        [STARTING BY 'string']        [TERMINATED BY 'string']    ]    [IGNORE number {LINES | ROWS}]    [(col_name_or_user_var        [, col_name_or_user_var] ...)]    [SET col_name={expr | DEFAULT},        [, col_name={expr | DEFAULT}] ...]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数还是挺多的，可以在手册里看到详细的介绍。不管怎么样，可以使用这个语句来导入数据了。</p><h3 id="2-文件放在哪"><a href="#2-文件放在哪" class="headerlink" title="2. 文件放在哪"></a>2. 文件放在哪</h3><p>像之前一样，创建一个测试表和测试文件：one_piece表和one_piece.txt文件。</p><p>然后，这个文件放在哪呢？</p><p>毕竟现在涉及到两台机器：mysql client机器和server机器。</p><p>在手册上写着：</p><blockquote><p>If <code>LOCAL</code> is specified, the file is read by the client program on the client host and sent to the server.</p></blockquote><p>就是说MySQL根据<code>LOCAL</code>这个参数来标识在哪里去找这个文件。如果指定了<code>LOCAL</code>就在客户端上找，否则就在服务器上找。</p><h3 id="3-在server上"><a href="#3-在server上" class="headerlink" title="3. 在server上"></a>3. 在server上</h3><p>首先现在服务器上尝试。先看看MySQL存放数据的地方：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT @@datadir;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+------------------------+| @@datadir              |+------------------------+| /usr/local/mysql/data/ |+------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在我的机器上，目录是这个。</p><p>然后把文件放在这个目录下的test目录下，这个test就是对应的数据库。</p><p>然后导入数据：</p><pre class="line-numbers language-mysql"><code class="language-mysql">LOAD DATA INFILE 'one_piece.txt' INTO TABLE one_piece FIELDS TERMINATED BY '\t' IGNORE 1 LINES (no,name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>好的，那看看<code>secure_file_priv</code>是什么：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT @@secure_file_priv;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+--------------------+| @@secure_file_priv |+--------------------+| NULL               |+--------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果是NULL，这意味着不允许MySQL从文件系统里读取文件，当然是为了安全。</p><p>可以在启动mysql服务的时候设置这个值来允许mysql读取文件：</p><pre class="line-numbers language-shell"><code class="language-shell">/usr/local/mysql/bin/mysqld --user=_mysql --basedir=/usr/local/mysql \--datadir=/usr/local/mysql/data \--plugin-dir=/usr/local/mysql/lib/plugin \--log-error=/usr/local/mysql/data/mysqld.local.err \--pid-file=/usr/local/mysql/data/mysqld.local.pid \--secure-file-priv=/usr/local/mysql/data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样查看<code>secure_file_priv</code>就是设置的值了：</p><pre class="line-numbers language-shell"><code class="language-shell">+------------------------+| @@secure_file_priv     |+------------------------+| /usr/local/mysql/data/ |+------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后导入数据就可以了：</p><pre class="line-numbers language-shell"><code class="language-shell">Query OK, 10 rows affected (0.08 sec)Records: 10  Deleted: 0  Skipped: 0  Warnings: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>MySQL的默认设置是不允许这么操作的，这也可以理解。上面这么操作主要是为了演示从服务器里导入数据的过程，实际不建议这么操作，都是在客户端导入文件到MySQL服务器。</p><h3 id="4-在client上"><a href="#4-在client上" class="headerlink" title="4. 在client上"></a>4. 在client上</h3><p>由于一些原因我们不能在MySQL服务器上导入文件，这个时候需要在客户端上来导入文件了，这也是<code>LOCAL</code>选项的含义。从客户端导入数据到MySQL服务器的过程中涉及到一些步骤，如下图：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/load_data.png"><p>简单来说涉及到下面的几个步骤：</p><ol><li>客户端发送<code>COM_QUERY</code>到服务端来执行命令，在这个例子中就是<code>LOAD DATA LOCAL INFILE xxx</code>；</li><li>服务端发送一个特殊的响应<code>OxFB</code>和文件名给客户端，来告诉客户端发送的文件名；</li><li>客户端开始将文件内容发送给服务端；</li><li>客户端发送完文件内容后，发送一个空包来通知服务端文件发文完毕；</li><li>服务端开始执行命令，执行完毕后返回一个结果（OK或者错误）。</li></ol><p>可是为什么服务端要把发送的文件名给客户端呢？客户端不知道应该发送哪个文件吗？</p><p>是这样的，SQL语句分析起来比较麻烦，所以MySQL把SQL的解析都放在了服务端，服务端解析完了告诉客户端，这样客户端就不需要解析复杂的SQL语句了。</p><p>好的，开始使用<code>LOCAL</code>导入数据：</p><pre class="line-numbers language-mysql"><code class="language-mysql">LOAD DATA INFILE 'one_piece.txt' LOCALINTO TABLE one_piece FIELDS TERMINATED BY '\t' IGNORE 1 LINES (no,name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">ERROR 1148 (42000): The used command is not allowed with this MySQL version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>失败了，不过这个错误信息不好看到底是什么错误。其实这个错误是有关安全的一些设置。</p><h3 id="5-为了安全"><a href="#5-为了安全" class="headerlink" title="5. 为了安全"></a>5. 为了安全</h3><p>在手册上，有关于<code>LOAD DATA</code>的一些<a href="https://dev.mysql.com/doc/refman/8.0/en/load-data-local.html" target="_blank" rel="noopener">安全设置</a>：</p><blockquote><p>The <code>local_infile</code> system variable controls server-side <code>LOCAL</code> capability. Depending on the <code>local_infile</code> setting, the server refuses or permits local data loading by clients that have <code>LOCAL</code> enabled on the client side. By default, <code>local_infile</code> is disabled.</p></blockquote><p>这个是MySQL 8.0版本的说明，<code>local_infile</code>默认是不开启的，在之前的版本中都是默认开启的：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT @@local_infile;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+----------------+| @@local_infile |+----------------+|              0 |+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>了解了，设置<code>local_infile=1</code>试试：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SET GLOBAL local_infile=1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后重试导入数据。结果：</p><pre class="line-numbers language-shell"><code class="language-shell">ERROR 1148 (42000): The used command is not allowed with this MySQL version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>怎么还错了呢？</p><p>在上面客户端和服务端数据交换的过程中可以知道，这个过程涉及到客户端和服务端两个机器，上面的设置只是设置了服务端允许客户端发送文件，但是客户端也需要允许服务端来读取这个文件：</p><blockquote><p>For the <strong>mysql</strong> client, local data loading is disabled by default. To disable or enable it explicitly, use the <code>--local-infile=0</code> or <code>--local-infile[=1\]</code> option.</p></blockquote><p>也就是说，对于mysql客户端，启动的时候需要设置一下<code>--local-infile</code>：</p><pre class="line-numbers language-shell"><code class="language-shell">mysql -u root -p --local_infile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后再试一次。结果：</p><pre class="line-numbers language-shell"><code class="language-shell">Query OK, 10 rows affected (0.05 sec)Records: 10  Deleted: 0  Skipped: 0  Warnings: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>终于成功了。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Files to MySQL</title>
      <link href="/files-to-mysql/"/>
      <url>/files-to-mysql/</url>
      
        <content type="html"><![CDATA[<p><strong>问题</strong>：把一个本地的文件（比如.txt或.csv文件）导入到指定的一张MySQL表中。可以使用mysqlimport或者<code>LOAD DATA</code>命令来完成。这篇文章仅仅是简单介绍一下mysqlimport和<code>LOAD DATA</code>的简单用法。关于<code>LOAD DATA</code>的详细说明，参考<a href="https://deuterium.fun/what-happens-when-using-load-data/">What Happens When Using LOAD DATA</a>。</p><h2 id="1-Prework：创建测试表和文件"><a href="#1-Prework：创建测试表和文件" class="headerlink" title="1. Prework：创建测试表和文件"></a>1. Prework：创建测试表和文件</h2><p>首先创建一个测试表：</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE one_piece (    `no`    INT,    `name`    VARCHAR(15));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后创建一个测试文件：</p><pre class="line-numbers language-shell"><code class="language-shell">cat one_piece.txtno      name100     luffy200     zoro300     nami400     usopp500     sanji600     chopper700     robin800     franky900     brook1000    jinbe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-使用mysqlimport导入文件"><a href="#2-使用mysqlimport导入文件" class="headerlink" title="2. 使用mysqlimport导入文件"></a>2. 使用mysqlimport导入文件</h2><p>使用下面的命令可以将上面创建的one_piece.txt的内容导入表中：</p><pre class="line-numbers language-shell"><code class="language-shell">mysqlimport --ignore-lines=1 \--fields-terminated-by='\t' \--local \-h host \-P port \-u username \-p db_name \/path/to/one_piece.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行后会让输入密码，之后就执行成功了。</p><p>可以查看一下：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM one_piece;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+------+---------+| no   | name    |+------+---------+|  100 | luffy   ||  200 | zoro    ||  300 | nami    ||  400 | usopp   ||  500 | sanji   ||  600 | chopper ||  700 | robin   ||  800 | franky  ||  900 | brook   || 1000 | jinbe   |+------+---------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，导入的文件名需要和对应的表名一样，比如上面的one_piece.txt和对应的表名one_piece。不然会找不到表名。</p><h2 id="3-导入多个文件到多张表中"><a href="#3-导入多个文件到多张表中" class="headerlink" title="3. 导入多个文件到多张表中"></a>3. 导入多个文件到多张表中</h2><p>使用上面的命令我们可以将多个文件导入多张表中：</p><pre class="line-numbers language-shell"><code class="language-shell">mysqlimport --ignore-lines=1 \--fields-terminated-by='\t' \--local \-h host \-P port \-u username \-p db_name \/path/to/one_piece.txt/path/to/steins_gate.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-指定导入的字段"><a href="#4-指定导入的字段" class="headerlink" title="4. 指定导入的字段"></a>4. 指定导入的字段</h2><p>如果想只导入指定的字段，可以使用<code>--columns</code>选项（也叫<code>-c</code>）。字段使用英文逗号隔开。比如：</p><pre class="line-numbers language-shell"><code class="language-shell">mysqlimport --ignore-lines=1 \--fields-terminated-by='\t' \--columns no,name--local \-h 10.55.142.100 \-P3596 \-u db_szdev \-p test \/path/to/one_piece.txt/path/to/steins_gate.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-使用LOAD-DATA导入文件"><a href="#5-使用LOAD-DATA导入文件" class="headerlink" title="5. 使用LOAD DATA导入文件"></a>5. 使用<code>LOAD DATA</code>导入文件</h2><p>mysqlimport其实是对<code>LOAD DATA</code>的一层封装，这样我们就可以使用<code>LOAD DATA</code>导入文件：</p><pre class="line-numbers language-mysql"><code class="language-mysql">LOAD DATA LOCAL INFILE '/path/to/one_piece.txt' INTO TABLE one_piece FIELDS TERMINATED BY '\t' LINES TERMINATED BY '\n' IGNORE 1 LINES (no,name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果是一样的。</p><h2 id="6-mysqlimport常用选项"><a href="#6-mysqlimport常用选项" class="headerlink" title="6. mysqlimport常用选项"></a>6. mysqlimport常用选项</h2><p>mysqlimport的参数比较多，接下来看看一些常用的参数：</p><p><code>--ignore-lines</code>：用来标识忽略的行数，比如如果文件有表头的话，可以忽略这一行；</p><p><code>--fields-terminated-by</code>：用来标识字段分隔符，常用的有<code>\t</code>和<code>,</code>；</p><p><code>--local</code>：表示读取本地文件，如果不加的话就会出错；</p><p><code>--delete</code>：在导入之前先删除所有的数据；</p><p><code>-h</code>和<code>-P</code>：表示MySQL服务器的地址，不加的话就是本地的MySQL服务器；</p><p><code>-p</code>：使用密码；</p><p>后面的<code>test</code>就是对应的数据库名。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Types in MySQL</title>
      <link href="/data-types-in-mysql/"/>
      <url>/data-types-in-mysql/</url>
      
        <content type="html"><![CDATA[<h3 id="1-开始"><a href="#1-开始" class="headerlink" title="1. 开始"></a>1. 开始</h3><p>为了能更好地理解与使用MySQL，根据MySQL文档花点时间整理了一下MySQL的数据类型。MySQL中一共有五大类数据类型，如下图：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/mysql_datatypes.PNG"><p>这篇文章只对其中的数字类型、字符串类型和时间类型进行总结。</p><p>在这些数据类型的使用中，有几个需要提前知道的地方：</p><ol><li>在整数中，<em><code>M</code></em>代表最大的展示宽度；而在浮点数和定点数中，<em><code>M</code></em>代表可以存储的总位数（也就是精度,precision）；对于字符串类型，<em><code>M</code></em>代表所能存储的最长字符数。不同类型的<em><code>M</code></em>也是不一样的；</li><li><em><code>D</code></em>适用于浮点数和定点数，表示小数点后面的位数。<em><code>D</code></em>最大值是30，但是不能大于<em><code>M-2</code></em>；</li><li><em><code>fsp</code></em>适用于时间类型，表示小于秒的精度。这个值在0和6之间，也就是说MySQL的时间可以精确到微秒级；</li><li>类型定义中的<code>[</code>和<code>]</code>表示可选项。</li></ol><p>不管什么数据类型，计算机的存储都是一样的，不同在于对于底层存储数据的解释不同。</p><p>接下来，详细看看各种数据类型是怎么存储的，以及MySQL是怎么解释的。</p><h3 id="2-Numeric类型"><a href="#2-Numeric类型" class="headerlink" title="2. Numeric类型"></a>2. Numeric类型</h3><p>数字类型还可以细分成如下的几种类型：整数、实数和位数据类型。</p><p>数字类型支持有符号和无符号属性，分别是<code>UNSIGNED</code>和<code>SIGNED</code>。其中<code>SIGNED</code>可以不写在类型定义中，默认就是有符号的。</p><h4 id="2-1-Integer类型"><a href="#2-1-Integer类型" class="headerlink" title="2.1 Integer类型"></a>2.1 Integer类型</h4><p>整数类型根据所占空间大小可以分为五种：<code>TINYINT</code>, <code>SMALLINT</code>, <code>MEDIUMINT</code>, <code>INT</code>, <code>BIGINT</code>。其中<code>INT</code>也是<code>INTEGER</code>。</p><p>按照有无符号又可以分为两种：<code>SIGNED</code>和<code>UNSIGNED</code>，其中默认是有符号的，只需要在指定无符号时使用<code>UNSIGNED</code>。</p><p>整数类型基本情况如下表：</p><table><thead><tr><th>Type</th><th>Bytes</th><th>Min Signed</th><th>Max Signed</th><th>Min Unsigned</th><th>Max Unsigned</th></tr></thead><tbody><tr><td><code>TINYINT</code></td><td>1</td><td>-128</td><td>127</td><td>0</td><td>255</td></tr><tr><td><code>SMALLINT</code></td><td>2</td><td>-32768</td><td>32767</td><td>0</td><td>65535</td></tr><tr><td><code>MEDIUMINT</code></td><td>3</td><td>-8388608</td><td>8388607</td><td>0</td><td>16777215</td></tr><tr><td><code>INT</code></td><td>4</td><td>-2147483648</td><td>2147483647</td><td>0</td><td>4294967295</td></tr><tr><td><code>BIGINT</code></td><td>8</td><td>-2^63</td><td>2^63-1</td><td>0</td><td>2^64-1</td></tr></tbody></table><p>有符号与无符号类型使用相同的存储空间，也具有相同的性能，可以根据需要来选择。不过如果选择了无符号类型，当插入的数据是负数时，会保存为0，需要注意。</p><p>对于整数的<em><code>M</code></em>，比如<code>INT(11)</code>，对于大多数应用这是没有意义的，因为这不会限制值的合法范围，只是规定了MySQL的一些交互工具（比如MySQL命令行客户端）用来显示字符的个数。对于存储和计算来说，<code>INT(1)</code>和<code>INT(11)</code>是相同的。</p><p>还有一个类型，<code>BOOL</code>(也可以是<code>BOOLEAN</code>)，这个类型和<code>TINYINT(1)</code>一样，0为<code>false</code>，非零为<code>true</code>。但是在MySQL中，<code>TRUE</code>就是1<code>FALSE</code>就是0：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT IF(2 = TRUE, 'true', 'false');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果是<code>false</code>。</p><h4 id="2-2-实数类型"><a href="#2-2-实数类型" class="headerlink" title="2.2 实数类型"></a>2.2 实数类型</h4><p>MySQL中除了整数还可以储存实数。对于实数，MySQL既支持精确类型（定点），也支持不精确类型（浮点）。</p><p>对于精确实数类型，MySQL中有<code>DECIMAL</code>，也可以叫做<code>DEC</code>和<code>NUMERIC</code>。</p><p><code>DECIMAL</code>类型定义如下：</p><pre class="line-numbers language-mysql"><code class="language-mysql">salary DECIMAL(5,2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中5就是精度2就是小数点后面的位数。精度也就是数字的总位数，这样<code>salary</code>的范围就是<code>-999.99</code>到<code>999.99</code>。</p><p>对于不精确类型，MySQL有<code>FLOAT</code>和<code>DOUBLE</code>类型，其中<code>FLOAT</code>使用4个字节（也有可能使用8个字节），而<code>DOUBLE</code>使用8个字节进行存储。</p><p>对于<code>FLOAT</code>，还可以这样来指定类型：<code>FLOAT(p)</code>，可以用来指定存储空间大小，具体的大小和<code>p</code>有关。</p><p>浮点类型通常在相同精度时比<code>DECIMAL</code>所需空间少，所以应该尽量在需要精确计算时使用<code>DECIMAL</code>。</p><p>下面列出了不同类型所占的空间：</p><table><thead><tr><th>Data Type</th><th>Storage Required</th></tr></thead><tbody><tr><td><code>FLOAT(p)</code></td><td><code>0&lt;=p&lt;=24</code>时4个字节，<code>25&lt;=p&lt;=53</code>时8个字节</td></tr><tr><td><code>FLOAT</code></td><td>4个字节</td></tr><tr><td><code>DOUBLE</code></td><td>8个字节</td></tr></tbody></table><p>对于<code>DECIMAL</code>情况有些复杂，MySQL将数字打包成二进制字符串来存储，每9个数字使用4个字节，并且对于整数部分和小数部分分开计算。计算规则如下：</p><ol><li>每9个数字使用4个字节；</li><li>不够9个数字的通过下面的表格确定；</li><li>将整数部分和小数部分所占空间相加即是整体空间。</li></ol><p>不够9个数字的部分所占空间：</p><table><thead><tr><th>Leftover Digits</th><th>Number of Bytes</th></tr></thead><tbody><tr><td>0</td><td>0</td></tr><tr><td>1-2</td><td>1</td></tr><tr><td>3-4</td><td>2</td></tr><tr><td>5-6</td><td>3</td></tr><tr><td>7-8</td><td>4</td></tr></tbody></table><p>比如，对于123.123，整数部分3个数字不够9个，查表使用2个字节；同理小数部分也使用2个字节，一共4个字节。</p><p>对于12345.1，整数部分使用3个字节，小数部分使用1个字节，一共4个字节。</p><h4 id="2-3-位数据类型"><a href="#2-3-位数据类型" class="headerlink" title="2.3 位数据类型"></a>2.3 位数据类型</h4><p><code>BIT</code>类型可以存储比特位，<code>BIT(M)</code>可以存储<code>M</code>个比特位，其中<code>M</code>可以取1到64之间的任意值。。</p><p>对于<code>BIT</code>类型，不同的存储引擎存储方式不同。MyISAM会把所有的比特位打包存储，所以19个单独的<code>BIT</code>列只需要19位来存储，所以一共3个字节就可以了；但是对于InnoDB来说，会为每个<code>BIT</code>列使用一个足够小的最小整数类型来存储，所以不能节省空间。</p><p>还有一点需要注意的是，MySQL是使用字符串来存储的，而不是ASCII码的”0”或”1”。但是在数字上下文的场景使用时，结果是把位字符串转换成了数字。比如，如果存储一个<code>b&#39;00111001&#39;</code>（二进制值是57）到<code>BIT(8)</code>中并检索使用，得到的内容是字符码为57的字符串，也就是得到了字符”9”，但是在数字上下文中，得到的是57：</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE bittest(a bit(8));INSERT INTO bittest VALUES (b'00111001');SELECT a, a+0 FROM bittest;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+------+------+| a    | a+0  |+------+------+| 9    |   57 |+------+------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个建议就是，尽可能不使用<code>BIT</code>类型。</p><h3 id="3-String类型"><a href="#3-String类型" class="headerlink" title="3. String类型"></a>3. String类型</h3><h4 id="3-1-VARCHAR和CHAR类型"><a href="#3-1-VARCHAR和CHAR类型" class="headerlink" title="3.1 VARCHAR和CHAR类型"></a>3.1 <code>VARCHAR</code>和<code>CHAR</code>类型</h4><p><code>VARCHAR</code>和<code>CHAR</code>是两种主要的类型，虽然相似，但是在好多方面各不相同。而且，两种类型在磁盘和内存中的存储方式也和存储引擎有关，这里的描述主要是InnoDB和MyISAM。</p><p><strong>区别一：<code>VARCHAR</code>是变长的，<code>CHAR</code>是定长的。</strong></p><p><code>VARDCHAR</code>根据存储的内容使用不同的空间，最长长度定义时指定；而<code>CHAR</code>使用定义时指定的空间。如果存储的值超过了指定的空间，两种类型都会截断超过的部分。</p><p><strong>区别二：两种类型所能存储的最长字符串不同。</strong></p><p><code>VARCHAR</code>可以最多存储65535个字符；而<code>CHAR</code>最多能存储255个字符。最长字符都可以在定义时指定。</p><p><strong>区别三：填充方式</strong></p><p>由于<code>CHAR</code>是定长的，如果存储的值不够指定长度，会在末尾填充空格；而<code>VARCHAR</code>不会填充空格。</p><p><strong>区别四：空间占用</strong></p><p><code>CHAR</code>是定长的，所以指定的长度就是真正需要的空间，不过还和使用的字符集有关。如果使用latin1字符集，那么<code>CHAR(4)</code>就使用4个字节存储。</p><p><code>VARCHAR</code>是变长的，所以需要额外记录字符串的长度。对于字符数小于等于255，额外需要一个字节存储长度；字符数超过255，需要两个字节。</p><p><strong>区别五：末尾空格</strong></p><p>在区别三种提到了<code>CHAR</code>会在后面使用空格填充，但是如果数据本身后面就有空格的话，两个类型处理方式就不同了。<code>CHAR</code>当然会保存空格，但是在检索时会把空格去掉；而<code>VARCHAR</code>不会：存入什么，得到什么。</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE vc (v VARCHAR(4), c CHAR(4));INSERT INTO vc VALUES ('ab  ', 'ab  ');SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+---------------------+---------------------+| CONCAT('(', v, ')') | CONCAT('(', c, ')') |+---------------------+---------------------+| (ab  )              | (ab)                |+---------------------+---------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面的表格演示了两者的区别：</p><table><thead><tr><th>Value</th><th><code>CHAR(4)</code></th><th>Storage Required</th><th><code>VARCHAR(4)</code></th><th>Storage Required</th></tr></thead><tbody><tr><td><code>&#39;&#39;</code></td><td><code>&#39;    &#39;</code></td><td>4 bytes</td><td><code>&#39;&#39;</code></td><td>1 byte</td></tr><tr><td><code>&#39;ab&#39;</code></td><td><code>&#39;ab  &#39;</code></td><td>4 bytes</td><td><code>&#39;ab&#39;</code></td><td>3 bytes</td></tr><tr><td><code>abcd</code></td><td><code>&#39;abcd&#39;</code></td><td>4 bytes</td><td><code>&#39;abcd&#39;</code></td><td>5 bytes</td></tr><tr><td><code>abcdefgh</code></td><td><code>&#39;abcd&#39;</code></td><td>4 bytes</td><td><code>&#39;abcd&#39;</code></td><td>5 bytes</td></tr></tbody></table><p><code>VARCHAR</code>可以节省空间，不过由于是变长的，在更新时可能会比原来的长，这就需要额外的操作。如果一个行占用的空间增长，并且在页中没有更多的空间的话，不同的存储引擎处理方式不同。MyISAM会将行拆分成不同的片段存储；InnoDB则需要分裂页来使行可以放进页内。</p><p><code>CHAR</code>适合存储很短的字符串，或者所有值都接近同一个长度，比如MD5值。对于经常变更的数据，<code>CHAR</code>也比<code>VARCHAR</code>好，因为不会产品碎片。</p><h4 id="3-2-VARBINARY和BINARY类型"><a href="#3-2-VARBINARY和BINARY类型" class="headerlink" title="3.2 VARBINARY和BINARY类型"></a>3.2 <code>VARBINARY</code>和<code>BINARY</code>类型</h4><p><code>VARBINARY</code>和<code>BINARY</code>两种类型和<code>VARCHAR</code>和<code>CHAR</code>类似，不同在于，前两者储存的是二进制字符串（二进制字符码），而后两者存储的是常规字符串（字符）。</p><p>这样有一个问题就是，虽然前两者的长度限制和后两者的一样，但是前两者计算的是字节数，而后两者计算的字符数，这在有些单个字符使用多个字节的字符集中会有所不同。</p><p>还有一点需要注意，<code>BINARY</code>会在数据后面填充<code>\0</code>而不是空格，在检索的时候也不会删除后面的<code>\0</code>。</p><p>二进制字符的优势在于比较。MySQL比较<code>BINARY</code>字符串时，每次按一个字节，并且根据该字节的数值比较。这会比字符比较更快。</p><h4 id="3-3-BLOB和TEXT类型"><a href="#3-3-BLOB和TEXT类型" class="headerlink" title="3.3 BLOB和TEXT类型"></a>3.3 <code>BLOB</code>和<code>TEXT</code>类型</h4><p><code>BLOB</code>和<code>TEXT</code>都是为了存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。</p><p>其实它们也有各自的类型族：<code>TINYBLOB</code>、<code>BLOB</code>、<code>MEDIUMBLOB</code>、<code>LONGBLOB</code>和<code>TINYTEXT</code>、<code>TEXT</code>、<code>MEDIUMTEXT</code>和<code>LONGTEXT</code>。</p><p>当<code>BLOG</code>和<code>TEXT</code>过大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1-4个字节来存储一个指针，指向外部存储区域的实际值。</p><p>MySQL对于<code>BLOB</code>和<code>TEXT</code>列进行排序与其它类型不同：只对最前面的<code>max_sort_length</code>字节而不是整个字符串进行排序。</p><p>MySQL不能将<code>BLOB</code>和<code>TEXT</code>列全部长度的字符串进行索引，也不能使用这些索引消除排序。</p><h4 id="3-4-ENUM类型"><a href="#3-4-ENUM类型" class="headerlink" title="3.4 ENUM类型"></a>3.4 <code>ENUM</code>类型</h4><p>有时候可以使用枚举类型代替常用的字符串类型。枚举类型可以把一些不重复的字符串存储成一个预定义的集合。枚举类型使用一个或两个字节来编码枚举值，最多可以用65535个不同的枚举值。</p><p>创建一个枚举值：</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE shirts (    name VARCHAR(40),    size ENUM('x-small', 'small', 'medium', 'large', 'x-large'));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这也是使用枚举类型的一个缺点，当需要增加枚举值时，只能使用<code>ALTER TABLE</code>：</p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE shirts MODIFY COLUMN size ENUM('x-small', 'small', 'medium', 'large', 'x-large', 'xx-large');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>存储枚举值时使用的是数字而不是对应的字符串：</p><pre class="line-numbers language-mysql"><code class="language-mysql">INSERT INTO shirts (name, size) VALUES ('dress shirt','large'), ('t-shirt','medium'),  ('polo shirt','small');SELECT * FROM shirts;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+-------------+--------+| name        | size   |+-------------+--------+| dress shirt | large  || t-shirt     | medium || polo shirt  | small  |+-------------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过在数字上下文中，可以看到真实存储的值：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT size+0 FROM shirts;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-mysql"><code class="language-mysql">+--------+| size+0 |+--------+|      4 ||      3 ||      2 |+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此：<strong>千万不要使用数字作为枚举值</strong>。</p><p>还有一点，枚举字段是根据存储的数字来排序的而不是定义的字符串：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT size FROM shirts ORDER BY size;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+--------+| size   |+--------+| small  || medium || large  |+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-5-SET类型"><a href="#3-5-SET类型" class="headerlink" title="3.5 SET类型"></a>3.5 <code>SET</code>类型</h4><p>一位可以存储一个只有<code>true/false</code>值，如果有很多<code>true/false</code>值的话，可以使用<code>SET</code>类型，它在MySQL中打包存储，可以有效节省空间，最多可以存储64个<code>true/false</code>值，只需要8个字节。</p><p>和<code>ENUM</code>一样，一个主要的缺点是添加新的定义时需要使用<code>ALTER TABLE</code>。而且，也不能在<code>SET</code>上使用索引。</p><p>作为一个替代方案，可以使用一个整数来包装一系列的位，然后再应用中操作这个整数。不过是使用这个方法还是使用<code>SET</code>依据每个人的偏好。</p><h3 id="4-Date-and-Time类型"><a href="#4-Date-and-Time类型" class="headerlink" title="4. Date and Time类型"></a>4. Date and Time类型</h3><p>MySQL中的时间和日期类型有如下几种：<code>DATE</code>、<code>TIME</code>、<code>DATETIME</code>、<code>TIMESTAMP</code>和<code>YEAR</code>。每种类型都有自己对应的零值和取值范围：</p><table><thead><tr><th>Data Type</th><th>“Zero” Value</th><th>Time Range</th></tr></thead><tbody><tr><td><code>Date</code></td><td><code>&#39;0000-00-00&#39;</code></td><td><code>&#39;1000-01-01&#39;</code> 到<code>&#39;9999-12-31&#39;</code></td></tr><tr><td><code>TIME</code></td><td><code>&#39;00:00:00&#39;</code></td><td><code>&#39;-838：59：59&#39;</code>到<code>&#39;838:59:59&#39;</code></td></tr><tr><td><code>DATETIME</code></td><td><code>&#39;0000-00-00 00:00:00&#39;</code></td><td><code>&#39;1000-01-01 00:00:00&#39;</code>到<code>&#39;9999-12-31 23:59:59&#39;</code></td></tr><tr><td><code>TIMESTAMP</code></td><td><code>&#39;0000-00-00 00:00:00&#39;</code></td><td><code>&#39;1970-01-01 00:00:01&#39;</code>到<code>&#39;2038-01-19 03:14:07&#39;</code></td></tr><tr><td><code>YEAR</code></td><td><code>0000</code></td><td><code>&#39;1901&#39;</code>到<code>&#39;2155&#39;</code>或<code>&#39;0&#39;</code>到<code>&#39;99&#39;</code></td></tr></tbody></table><h4 id="4-1-DATE、DATETIME和TIMESTAMP类型"><a href="#4-1-DATE、DATETIME和TIMESTAMP类型" class="headerlink" title="4.1 DATE、DATETIME和TIMESTAMP类型"></a>4.1 <code>DATE</code>、<code>DATETIME</code>和<code>TIMESTAMP</code>类型</h4><p>这三种类型都含有年月日的信息，但是三种类型又有一些不同。</p><p><code>DATE</code>类型只有日期而没有时间；<code>DATETIME</code>和<code>TIMESTAMP</code>除了日期还有具体的时间。</p><p><code>DATETIME</code>和<code>TIMESTAMP</code>的一个区别是两者的范围不同。<code>DATETIME</code>将日期存储为<code>YYYYMMDDHHMMSS</code>格式的整数中，使用8个字节；而<code>TIMESTAMP</code>使用4个字节存储从1970年1月1日以来的秒数，所以范围小了很多。</p><p>另外一个区别就是<code>TIMESTAMP</code>依赖时区而<code>DATETIME</code>不包含时区。MySQL服务器、操作系统以及客户端连接都可以设置时区。</p><p><code>TIMESTAMP</code>也有一些<code>DATETIME</code>没有的属性，比如可以设置插入和更新时<code>TIMESTAMP</code>列的行为。</p><p>在MySQL 5.6之后<code>DATETIME</code>和<code>TIMESTAMP</code>增加了时间的精确度，在原来秒的基础上精确度增加到了微秒级别，不过需要在定义中指定精确度，比如<code>DATETIME(6)</code>，括号中的数字就是时间的精确度，取值范围是0-6。</p><p>如果指定了额外的精确度的话，MySQL需要额外的空间来存储，所需的空间和精度有关：</p><table><thead><tr><th>fsp</th><th>Storage Required</th></tr></thead><tbody><tr><td>0</td><td>0 bytes</td></tr><tr><td>1, 2</td><td>1 byte</td></tr><tr><td>3, 4</td><td>2 bytes</td></tr><tr><td>5, 6</td><td>3 bytes</td></tr></tbody></table><h4 id="4-2-TIME类型"><a href="#4-2-TIME类型" class="headerlink" title="4.2 TIME类型"></a>4.2 <code>TIME</code>类型</h4><p><code>TIME</code>类型的存储范围并不是感觉上的<code>&#39;00:00:00&#39;</code>到<code>&#39;23:59:59&#39;</code>，而是<code>&#39;-838：59：59&#39;</code>到<code>&#39;838:59:59&#39;</code>，这样就可以表示是两个事件之间的时间差了。</p><p>MySQL中<code>TIME</code>的格式是<code>hh:mm:ss</code>，使用3个字节来存储。</p><p>在对<code>TIME</code>列进行赋值时，需要注意的是，<code>11:12</code>的结果是<code>&#39;11:12:00&#39;</code>，而不是<code>00:11:12</code>；<code>&#39;1112&#39;</code>的结果是<code>&#39;00:11:12&#39;</code>；<code>&#39;12&#39;</code>的结果是<code>&#39;00:00:12&#39;</code>。不过建议不要这么做。</p><p>同样，<code>TIME</code>类型在MySQL 5.6 版本之后添加了微秒级的精度，只需要在定义的时候指定精度即可，所需的额外空间就是上面的表格。</p><h4 id="4-3-YEAR类型"><a href="#4-3-YEAR类型" class="headerlink" title="4.3 YEAR类型"></a>4.3 <code>YEAR</code>类型</h4><p><code>YEAR</code>类型是使用1个字节来存储的数据类型，用来表示年份。在MySQL中，有两种：<code>YEAR(4)</code>和<code>YEAR(2)</code>。</p><p><code>YEAR(4)</code>可以表示的范围是<code>&#39;1901&#39;</code>到<code>&#39;2155&#39;</code>；</p><p><code>YEAR(2)</code>可以的取值范围是<code>&#39;0&#39;</code>到<code>&#39;99&#39;</code>，可以表示的范围是<code>&#39;1970&#39;</code>到<code>&#39;2069&#39;</code>。</p><p>由于范围小，尽量不要使用<code>YEAR(2)</code>。</p><h3 id="5-选择优化的数据类型"><a href="#5-选择优化的数据类型" class="headerlink" title="5. 选择优化的数据类型"></a>5. 选择优化的数据类型</h3><p>MySQL支持的数据类型非常多，选择正确的类型对于性能来说也很重要。下面是选择数据类型时的一些原则。</p><ol><li>一般情况下，应该尽量使用可以正确存储数据的最小数据类型；</li><li>使用简单的数据类型。比如，使用MySQL的内建类型来存储时间而不是字符串，使用整型次数IP地址而不是字符串；</li><li>通常情况下最好指定列为<code>NOT NULL</code>，除非真的需要存储<code>NULL</code>值；</li><li>尽量使用相同的数据类型来存储相似或相关的值，尤其是需要在关联条件中使用的列；</li><li>注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存；</li><li>避免使用MySQL已经遗弃的特性，比如指定浮点数的精度，或者整数的显示宽度；</li><li>小心使用<code>ENUM</code>和<code>SET</code>，不要滥用；</li><li>谨慎使用<code>BIT</code>，对于大部分应用，最好避免使用这个类型。</li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> data_type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File to Redis</title>
      <link href="/file-to-redis/"/>
      <url>/file-to-redis/</url>
      
        <content type="html"><![CDATA[<p>问题是这样的，现在需要把一个文件里的所有数据上传到redis的set中，文件里存储的就是ID，每行一个：</p><pre class="line-numbers language-shell"><code class="language-shell">head id.list10000100011000210003100041000510006100071000810009<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了将这一万条记录添加到redis中的某个set中，需要写一个脚本来执行这个操作。</p><p>主要的思路就是构造一个如下命令组成的一堆命令：</p><pre class="line-numbers language-shell"><code class="language-shell">sadd setname 10000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后使用<code>redis-cli</code>将命令通过pipeline的形式发送到服务器。流程如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Redis/file2redis.PNG"><p>下面就是生成命令的shell脚本：</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bashINFILE=$1SETKEY=$2TOFILE=${SETKEY}'.data'echo $TOFILErm $TOFILE >/dev/null 2>&1while IFS= read -r line; do    echo "sadd $SETKEY $line" >> $TOFILEdone < $INFILEunix2dos $TOFILEcat $TOFILE | ./redis-cli --pipe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在脚本的最后，通过下面的命令将所有的redis命令发送到了redis服务器中：</p><pre class="line-numbers language-shell"><code class="language-shell">cat $TOFILE | ./redis-cli --pipe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以在redis中查看是否正确。</p><p>对于将数据导入redis的其它格式中，也是类似的过程，只需要把循环中添加的命令改成需要的形式就可以了。</p><p>Done</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Character Sets and Collations in MySQL</title>
      <link href="/character-sets-and-collations-in-mysql/"/>
      <url>/character-sets-and-collations-in-mysql/</url>
      
        <content type="html"><![CDATA[<p>最近遇到一个关于MySQL字符乱码的问题，比较好解决，但是为了更好地理解MySQL中的字符系统，参考MySQL的文档整理一下关于MySQL中字符集合字符序的问题。</p><h3 id="1-什么是字符集和字符序"><a href="#1-什么是字符集和字符序" class="headerlink" title="1. 什么是字符集和字符序"></a>1. 什么是字符集和字符序</h3><p>MySQL是存储数据的数据库，既然是存储数据的，那么数据就需要一个编码的规则，因为计算机对于所有的数据都是通过二进制编码的方式存储的。字符集（Character Sets），就是字符到二进制编码映射的集合。由于不同的语言所包含的字符不同，所以为了支持不同的语言，MySQL定义了许许多多不同的字符集。</p><p>举一个简单的例子，假如我们有一种语言只有四个字符：<code>A, B, a, b</code>。</p><p>我们规定了这四个字符到二进制编码的规则：</p><table><thead><tr><th>Symbol</th><th>Encoding</th></tr></thead><tbody><tr><td><code>A</code></td><td>0</td></tr><tr><td><code>B</code></td><td>1</td></tr><tr><td><code>a</code></td><td>2</td></tr><tr><td><code>b</code></td><td>3</td></tr></tbody></table><p>在这里，<code>A</code>就是一个字符，而数字0就是字符<code>A</code>的编码，这四个字符和编码组合在一起就是字符集。</p><p>接下来看看什么是字符序（Collations）。</p><p>对于上面的字符集，我们需要有一个比较的规则。比如，我们想比较<code>A</code>和<code>B</code>，当然结果有三种：等于、小于或大于。但我们熟悉的还是<code>A&lt;B</code>。一种简单的方式就是比较他们的编码数字。因为<code>0&lt;1</code>，所以对应的字符<code>A&lt;B</code>。</p><p>这样就构成了一条字符比较的规则。这样的一条规则就可以构成一个字符序。</p><p>进一步，如果我们规定大写字母和对应的小写字母相等呢？这样就又多了一条规则：</p><blockquote><p><code>a</code>=<code>A</code>, <code>b</code>=<code>B</code></p></blockquote><p>这样，两条比较的规则就又构成了一个字符序。</p><p>通过这个简单的例子，我们可以知道：</p><ol><li>字符集就是字符到二进制编码的映射集合；</li><li>字符序是比较字符集的规则集合；</li><li>一个字符集可能有多个字符序。</li></ol><p>在MySQL中，定义了许多字符集合字符序。这些字符集合字符序可以帮助我们处理很多字符相关的问题。</p><h3 id="2-MySQL中的字符集合字符序"><a href="#2-MySQL中的字符集合字符序" class="headerlink" title="2. MySQL中的字符集合字符序"></a>2. MySQL中的字符集合字符序</h3><p>在MySQL中，我们可以使用如下的语句来查看字符集：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SHOW CHARACTER SET;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这会列出所有的字符集。如果想筛选的话，可以加上<code>LIKE</code>条件：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SHOW CHARATER SET LIKE 'utf%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下：</p><pre class="line-numbers language-shell"><code class="language-shell">+---------+------------------+--------------------+--------+| Charset | Description      | Default collation  | Maxlen |+---------+------------------+--------------------+--------+| utf16   | UTF-16 Unicode   | utf16_general_ci   |      4 || utf16le | UTF-16LE Unicode | utf16le_general_ci |      4 || utf32   | UTF-32 Unicode   | utf32_general_ci   |      4 || utf8    | UTF-8 Unicode    | utf8_general_ci    |      3 || utf8mb4 | UTF-8 Unicode    | utf8mb4_0900_ai_ci |      4 |+---------+------------------+--------------------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果返回了字符集的名称、描述、默认字符序以及单个字符最大长度等信息。</p><p>每一个字符集都有一个默认的字符序，有的字符集有多个字符序，可以通过下面的语句查看一个字符集的字符序：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SHOW COLLATION WHERE Charset = 'utf8mb4';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回的结果会列出所有的字符序以及相关的信息，这里就不展示了。</p><p>字符序有下面的特点：</p><ol><li>两个不同的字符集不会有相同的字符序。也就是每个字符集都有自己单独的字符序小弟，大家不会有交集；</li><li>每一个字符集都有一个默认的字符序；</li><li>字符序的名字是以对应的字符集名称为前缀的。</li></ol><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/characterset.PNG"><h3 id="3-在MySQL中使用字符集"><a href="#3-在MySQL中使用字符集" class="headerlink" title="3. 在MySQL中使用字符集"></a>3. 在MySQL中使用字符集</h3><p>MySQL中有很多可以控制字符集的选项，这些选项过于复杂很容易混淆。不过记住一点：</p><blockquote><p>只有基于字符的值才真正的“有”字符集的概念。</p></blockquote><p>对于其他类型的值，字符集只是一个设置，用来指定用哪一种字符进行比较或操作。基于字符的值能存放在某列中、查询的字符中、表达式的计算结果中或者某个用户变量中，等等。</p><p>MySQL中字符集的设置可以分为两类：创建对象时的默认值、在服务器和客户端通信时的设置。</p><h4 id="3-1-创建对象时的默认设置"><a href="#3-1-创建对象时的默认设置" class="headerlink" title="3.1 创建对象时的默认设置"></a>3.1 创建对象时的默认设置</h4><p>在MySQL中，从上到下一共有四层字符集的设置，分别是服务器（Server）、数据库（Database）、表（Table）和列（Column），在每一层都可以指定一个默认的字符集：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/charset_layers.PNG"><p>其中，服务器和数据库的字符集设置有对应的参数：<code>character_set_server</code>和<code>character_set_database</code>，表和列的字符集设置在对应的DDL语句中。</p><p>由于真正存放数据的是列，所以更高层次的字符集设置仅仅是指定一个默认值，如果在创建列时没有知道字符集，就会从下到上寻找设置的字符集。如果指定了一个字符集，那么上面所有层次的设置都没有效果了。</p><p>在MySQL 5.5、5.6和5.7中，默认的字符集是latin1，在最新的MySQL 8中，默认的字符集是utf8。</p><h4 id="3-2-服务器和客户端通信时的设置"><a href="#3-2-服务器和客户端通信时的设置" class="headerlink" title="3.2 服务器和客户端通信时的设置"></a>3.2 服务器和客户端通信时的设置</h4><p>当服务器和客户端进行通信时，可能各自使用不同的字符集。这时，服务器需要进行字符的转换工作。这涉及到MySQL中的三个参数：<code>character_set_client</code>、<code>character_set_connection</code>和<code>character_set_results</code>。</p><p>这三个参数的影响效果如下图所示：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/charset_communacate.PNG"><p>这里服务器进行了两次翻译过程：</p><ol><li>SQL语句从客户端离开时的字符集是<code>character_set_client</code>；</li><li>SQL语句进入服务器后服务器转换成<code>character_set_connection</code>；</li><li>服务器处理完SQL语句后，将结果的字符集设置成了<code>character_set_results</code>。</li></ol><p>根据需要，可以使用<code>SET NAMES</code>或者<code>SET CHARACTER SET</code>语句来改变上面的设置：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SET NAMES 'utf8';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，会将<code>character_set_client</code>、<code>character_set_connection</code>和<code>character_set_results</code>都设置成utf8。</p><p>不过在服务器上使用这个命令只能改变服务器端的设置，客户端程序也需要设置正确的字符集才能避免出现问题。</p><h4 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h4><p>可以通过<code>SHOW VARIABLES LIKE &#39;character%&#39;</code>命令来查看这些参数的值：</p><pre class="line-numbers language-shell"><code class="language-shell">+--------------------------+-----------------------------------------------------------+| Variable_name            | Value                                                     |+--------------------------+-----------------------------------------------------------+| character_set_client     | latin1                                                    || character_set_connection | latin1                                                    || character_set_database   | utf8mb4                                                   || character_set_filesystem | binary                                                    || character_set_results    | latin1                                                    || character_set_server     | utf8mb4                                                   || character_set_system     | utf8                                                      || character_sets_dir       | /usr/local/mysql-8.0.13-macos10.14-x86_64/share/charsets/ |+--------------------------+-----------------------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-字符集的选择"><a href="#4-字符集的选择" class="headerlink" title="4. 字符集的选择"></a>4. 字符集的选择</h3><p>使用不同的字符集会带来更多的CPU操作，可能也会消耗更多的内存和磁盘空间。因此，为了方便，最好先为服务器（或者数据库）设置一个合理的字符集，然后根据不同的情况让某些列选择合适的字符集，</p><p>如果统一使用utf8字符集，整个世界都清净了。这也是很常见的一种做法。不过有的时候并不需要使用utf8，使用utf8之后会增加磁盘空间的消耗。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> charset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What is physics</title>
      <link href="/what-is-physics/"/>
      <url>/what-is-physics/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是阅读《费恩曼物理学讲义 第一卷 新千年版》第1-3章的阅读笔记。</p></blockquote><h3 id="1-从一片沙滩开始"><a href="#1-从一片沙滩开始" class="headerlink" title="1. 从一片沙滩开始"></a>1. 从一片沙滩开始</h3><p>我们生活在一个多姿多彩的世界中。</p><p>想象一下，去年的某一天，我们正在一个美丽的海边沙滩享受着没有工作烦恼的美妙时光。你躺在柔软细密的沙滩上，不远处就是蔚蓝的大海，海水波光粼粼，海风吹拂，你感受到了凉爽，海水在海风的吹拂下翻起阵阵海浪；海水拍打在海中岩石上，激起浪花与泡沫；海水中生活着许许多多不同的生物，也许海绵宝宝和派大星正在不远处的海底捉水母；太阳挂在天上，持续不断发着光；望着这一切，作为观察者的你在想着什么呢？或许是晚上吃啥以及和她那美好的回忆与幸福。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/beach.jpg" alt=""></p><p>除了这些，我们生活的世界还有许许多多的错综复杂以及变化无穷。那么，这些事物到底是什么呢？是什么使得它们如此不同，但在某些方面又表现得如此相同？面对这一切，作为智慧生物，我们的好奇心驱使我们，提出种种问题，把事物联系起来，而将它们的种种表现理解为或许是由较少量的基本事物和相互作用以无穷多的方式组合后所产生的的结果。毕竟，阿瑟·克拉克说，“心智”是宇宙间最珍贵的东西。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/A%20Space%20Odyssey.jpg" alt="2001：太空漫游"></p><p>比如，沙粒和岩石是两回事儿吗？也许沙粒就是小小的岩石？那月亮是否也是岩石呢？如果我们了解了岩石，是不是就了解了沙粒和月亮呢？</p><p>再比如，风是不是和海洋里的水流类似，就是一种空气的流动？不同的运动有什么共同性质呢？</p><p>等等。我们就是希望试图了解我们所生活环境中的所有问题，将乍看起来不同的事物联系起来，减少不同事物的数目，从而能更好地理解它们。</p><h3 id="2-什么是理解"><a href="#2-什么是理解" class="headerlink" title="2. 什么是理解"></a>2. 什么是理解</h3><p>既然我们希望理解所有的事物，那么首先就应该先问问自己，<strong>什么是理解？</strong>毕竟，有目标才能更好达成目标。</p><p>想象一下，整个世界的运作方式是无所不能的神们所下的一盘巨大的琪。下棋有下棋的规则，我们就是这盘棋的观众。作为普通的观众我们不知道神们下棋的规则，只能看神们是如何下棋的，并以此来猜测棋的规则。就像小时候在旁边看父亲下棋一样。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/chess.jpg" alt="" width="50%" height="50%"><p>如果我们看得够多了，我们就能猜出一些规则来。但即使我们能够猜出一些规则，我们也不能很好地理解某一步棋为什么要那么走，这仅仅是因为情况太复杂了，而我们的智力又是有限的。</p><p>如果你会下象棋，就会知道，知道象棋的规则与如何下好是很不同的。</p><p>自然界也是如此，但是自然更加复杂。</p><p>我们要做的，就是尽可能知道更多的规则，知道了这些规则，就可以说“理解”了世界。</p><h3 id="3-如何理解"><a href="#3-如何理解" class="headerlink" title="3. 如何理解"></a>3. 如何理解</h3><p>几百年前，人们就已经想出了一些方法，那就是：观察、推理和实验，这就是通常所说的科学方法。更详细一点，就是下面这样：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/science.JPG" alt="" width="50%" height="50%"><p>虽然通过上面的方法我们可以得到一些规则，但是，这些规则都是对大自然整个真理的近似，因为我们不知道所有的规则，所以只能一步一步去近似，这样我们才能更好地理解。</p><p>对于理解的检验，有一条科学的原则：实验是一切知识的试金石。</p><h3 id="4-怎么知道我们理解的对呢？"><a href="#4-怎么知道我们理解的对呢？" class="headerlink" title="4. 怎么知道我们理解的对呢？"></a>4. 怎么知道我们理解的对呢？</h3><p>之前我们说过，我们不能全面地理解神们下的棋。既然这样，我们怎么知道我们已经知道的规则就是正确的呢？</p><p>一共有三种办法。第一个，我们首先将大自然安排得非常简单，只有几个部分组成。因为简单，我们可以正确地预测会发生什么事。</p><p>比如，对于象棋，我们知道棋盘上有格子和线条的交叉点。通过几次（甚至一次）观察我们就知道，棋子是放在线条交叉点上的而不是格子里（国际象棋是放在格子里）。</p><p>第二个，利用由已知规则推导出来的较一般性法则来检验已知规则本身。</p><p>比如，我们可能发现，“卒”和“兵”只能前进，不能后退，因此我们可以推断，“卒”和“兵”只能在最开始所在的那条直线上。但是随着更多的观察我们发现，有的“卒”和“兵”在越过中间的楚河汉界之后，还能左右移动，但不管怎样，它们还是不能后退而只能前进。这样，我们通过新发生的现象，更好地理解了之前已知的规则。</p><p>第三个比较粗糙，就是用粗略的近似方法来加以辨别。我们可能不知道公园老大爷那么走的原因，但我们可以猜测，那肯定是为了化解对方的一次将军。同样，根据我们对自然的理解，即使我们不能看出所有事物的规则，我们也能更多地理解我们的自然。</p><h3 id="5-什么是物理"><a href="#5-什么是物理" class="headerlink" title="5. 什么是物理"></a>5. 什么是物理</h3><p>说了这么多，终于到了主题：<strong>什么是物理。</strong></p><p>“物理”一词在英文里是“physics”，最先出自于古希腊文“φύσις”，原意是“自然”。在中文里，这词最早可在战国时期佚书《鹖冠子·王𫓧篇》找到，“愿闻其人情物理所以啬万物与天地总与神明体正之道。”在这里，“物理”指的是一切事物之道理。</p><p>上面说了好多自然啊、事物啊、理解啊、规则啊什么的，其实物理就是研究万物运行的道理。</p><h3 id="6-物理学与其他科学的关系"><a href="#6-物理学与其他科学的关系" class="headerlink" title="6. 物理学与其他科学的关系"></a>6. 物理学与其他科学的关系</h3><p>假如人类遭遇了末日，所有的科学知识都丢了，只能把一句话留给后人，那么怎么用最少的字传递最多的知识呢？</p><blockquote><p>所有的物体都是由原子构成的——这些原子是一些小小的粒子，它们一直不停地运动着，当彼此略微离开时相互吸引，当彼此过于挤紧时又相互排斥。</p></blockquote><p>这一句话，包含了关于这个世界的大量信息。</p><p>这也是物理和其他科学的关系的基石。因为所有的物体都是由原子构成的，其他的科学研究的也是各种物体，不管是化学研究的有机物和无机物，生物研究的各种生命体，天文学研究各种天体，以及地质学研究的各种地质问题，归根结底研究的都是“物体”，而所有的物体都是由原子构成的。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/relations.png" alt=""></p><p>这并不是没有了物理学我们就不能开展其他科学研究了。仅仅是研究的不同角度而已。物理不能回答为什么青蛙会跳，但是物理知道青蛙是什么，就是一堆堆不同的分子组成的一个物体，仅此而已。</p><h3 id="7-那么，开始吧"><a href="#7-那么，开始吧" class="headerlink" title="7. 那么，开始吧"></a>7. 那么，开始吧</h3><p>最后，跟着费恩曼的脚步，逐渐理解我们的世界，慢慢品味物理的美酒。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/feynman.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> physics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> physics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go struct to json</title>
      <link href="/go-struct-to-json/"/>
      <url>/go-struct-to-json/</url>
      
        <content type="html"><![CDATA[<p>最近做了一些将go中结构体输出到json的事情，各种花样输出，在这里整理一下。</p><h3 id="问题1：如何将struct转成json？"><a href="#问题1：如何将struct转成json？" class="headerlink" title="问题1：如何将struct转成json？"></a>问题1：如何将struct转成json？</h3><p>这是最简单的一种情况，直接使用<code>encoding/json</code>包中的函数就可以了：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"encoding/json"</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">type</span> Item <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Label <span class="token builtin">string</span>    Value <span class="token builtin">int32</span>    URL   <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    item <span class="token operator">:=</span> Item<span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token string">"http://test.com"</span><span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"Label"</span><span class="token operator">:</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token property">"Value"</span><span class="token operator">:</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token property">"URL"</span><span class="token operator">:</span><span class="token string">"http://test.com"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题2：我想自定义输出json的key怎么弄？"><a href="#问题2：我想自定义输出json的key怎么弄？" class="headerlink" title="问题2：我想自定义输出json的key怎么弄？"></a>问题2：我想自定义输出json的key怎么弄？</h3><p>使用struct的tag即可：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Item <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Label <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>    Value <span class="token builtin">int32</span>  <span class="token string">`json:"value"`</span>    URL   <span class="token builtin">string</span> <span class="token string">`json:"url"`</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token property">"value"</span><span class="token operator">:</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token property">"url"</span><span class="token operator">:</span><span class="token string">"http://test.com"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题3：有的字段不是必须的，如果为空就不输出呢？"><a href="#问题3：有的字段不是必须的，如果为空就不输出呢？" class="headerlink" title="问题3：有的字段不是必须的，如果为空就不输出呢？"></a>问题3：有的字段不是必须的，如果为空就不输出呢？</h3><p>比如URL字段可能为空，如果为空的话就不希望输出了。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    item <span class="token operator">:=</span> Item<span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"label"</span><span class="token operator">:</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token property">"value"</span><span class="token operator">:</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token property">"url"</span><span class="token operator">:</span><span class="token string">""</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用<code>omitempty</code>标签来达到这个目的：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Item <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Label <span class="token builtin">string</span> <span class="token string">`json:"label"`</span>    Value <span class="token builtin">int32</span>  <span class="token string">`json:"value"`</span>    URL   <span class="token builtin">string</span> <span class="token string">`json:"url,omitempty"`</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"label"</span><span class="token operator">:</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token property">"value"</span><span class="token operator">:</span><span class="token number">127</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题4：我想忽略某一个具体的字段"><a href="#问题4：我想忽略某一个具体的字段" class="headerlink" title="问题4：我想忽略某一个具体的字段"></a>问题4：我想忽略某一个具体的字段</h3><p>方法一：可以直接使用这个标签：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name     <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>    Email    <span class="token builtin">string</span> <span class="token string">`json:"email"`</span>    Password <span class="token builtin">string</span> <span class="token string">`json:"-"`</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：如果struct是别人定义的不允许我们修改这个标签，除了我们自定义一个struct外，还可以使用匿名struct：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    user <span class="token operator">:=</span> User<span class="token punctuation">{</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span> <span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>User        Password <span class="token builtin">bool</span> <span class="token string">`json:"password,omitempty"`</span>    <span class="token punctuation">}</span><span class="token punctuation">{</span>        User<span class="token punctuation">:</span> <span class="token operator">&amp;</span>user<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span><span class="token property">"email"</span><span class="token operator">:</span><span class="token string">"1749118121@qq.com"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里使用了嵌套结构体的概念，外面的<code>Password</code>字段覆盖了里面<code>User</code>的<code>Password</code>字段，然后通过问题3里的技巧，达到忽略某个字段的目的。</p><h3 id="问题5：临时添加一个或多个字段"><a href="#问题5：临时添加一个或多个字段" class="headerlink" title="问题5：临时添加一个或多个字段"></a>问题5：临时添加一个或多个字段</h3><p>这个就比较简单了，自定义一个struct即可：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name     <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>    Email    <span class="token builtin">string</span> <span class="token string">`json:"email"`</span>    Password <span class="token builtin">string</span> <span class="token string">`json:"password"`</span><span class="token punctuation">}</span><span class="token keyword">type</span> PublicUser <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token operator">*</span>User    Password <span class="token builtin">bool</span>   <span class="token string">`json:"password,omitempty"`</span>    Token    <span class="token builtin">string</span> <span class="token string">`json:"token"`</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    user <span class="token operator">:=</span> User<span class="token punctuation">{</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span> <span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">}</span>    publicUser <span class="token operator">:=</span> PublicUser<span class="token punctuation">{</span>        User<span class="token punctuation">:</span>  <span class="token operator">&amp;</span>user<span class="token punctuation">,</span>        Token<span class="token punctuation">:</span> <span class="token string">"test_token"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>publicUser<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span><span class="token property">"email"</span><span class="token operator">:</span><span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span><span class="token property">"token"</span><span class="token operator">:</span><span class="token string">"test_token"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题6：将多个struct组合成一个json"><a href="#问题6：将多个struct组合成一个json" class="headerlink" title="问题6：将多个struct组合成一个json"></a>问题6：将多个struct组合成一个json</h3><p>可能一个服务的数据来自不同的接口，需要组合到一个json里，那么同样自定义一个struct就可以了：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name     <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>    Email    <span class="token builtin">string</span> <span class="token string">`json:"email"`</span>    Password <span class="token builtin">string</span> <span class="token string">`json:"password"`</span><span class="token punctuation">}</span><span class="token keyword">type</span> Analytics <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Blogs <span class="token builtin">int32</span> <span class="token string">`json:"blogs"`</span>    Read  <span class="token builtin">int32</span> <span class="token string">`json:"read"`</span><span class="token punctuation">}</span><span class="token keyword">type</span> PublicUser <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token operator">*</span>User    Password <span class="token builtin">bool</span> <span class="token string">`json:"password,omitempty"`</span>    <span class="token operator">*</span>Analytics<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    user <span class="token operator">:=</span> User<span class="token punctuation">{</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span> <span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">}</span>    analytics <span class="token operator">:=</span> Analytics<span class="token punctuation">{</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">}</span>    publicUser <span class="token operator">:=</span> PublicUser<span class="token punctuation">{</span>        User<span class="token punctuation">:</span>      <span class="token operator">&amp;</span>user<span class="token punctuation">,</span>        Analytics<span class="token punctuation">:</span> <span class="token operator">&amp;</span>analytics<span class="token punctuation">,</span>    <span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>publicUser<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span><span class="token property">"email"</span><span class="token operator">:</span><span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span><span class="token property">"blogs"</span><span class="token operator">:</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token property">"read"</span><span class="token operator">:</span><span class="token number">200</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题7：我能自定义一个struct如何转换成json吗？"><a href="#问题7：我能自定义一个struct如何转换成json吗？" class="headerlink" title="问题7：我能自定义一个struct如何转换成json吗？"></a>问题7：我能自定义一个struct如何转换成json吗？</h3><p>比如，我们有这样的结构：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Article <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Title   <span class="token builtin">string</span>    <span class="token string">`json:"title"`</span>    PubTime time<span class="token punctuation">.</span>Time <span class="token string">`json:"pubtime"`</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>直接<code>Marshal</code>后会是这样：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"title"</span><span class="token operator">:</span><span class="token string">"my_title"</span><span class="token punctuation">,</span><span class="token property">"pubtime"</span><span class="token operator">:</span><span class="token string">"2019-12-05T20:52:50.759801+08:00"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果我们想<code>pubtime</code>输出的时间是时间戳，可以自定义输出形式：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>a Article<span class="token punctuation">)</span> <span class="token function">MarshalJSON</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">type</span> Alias Article    <span class="token keyword">return</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token punctuation">{</span>        PubTime <span class="token builtin">int64</span> <span class="token string">`json:"pubtime"`</span>        Article    <span class="token punctuation">}</span><span class="token punctuation">{</span>        PubTime<span class="token punctuation">:</span> a<span class="token punctuation">.</span>PubTime<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        Article<span class="token punctuation">:</span>   a<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而这样是不行的，执行后会报一个<code>fatal error: stack overflow</code>的错误。这是因为，在自定义的<code>MarshalJSON</code>函数里直接调用了<code>Article.MarshalJSON</code>函数，这样就无限调用了，直到报错。</p><p>为了避免出现这个错误，可以定义一个别名（Alias）：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>a Article<span class="token punctuation">)</span> <span class="token function">MarshalJSON</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">type</span> Alias Article    <span class="token keyword">return</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token punctuation">{</span>        PubTime <span class="token builtin">int64</span> <span class="token string">`json:"pubtime"`</span>        Alias    <span class="token punctuation">}</span><span class="token punctuation">{</span>        PubTime<span class="token punctuation">:</span> a<span class="token punctuation">.</span>PubTime<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        Alias<span class="token punctuation">:</span>   <span class="token punctuation">(</span>Alias<span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"pubtime"</span><span class="token operator">:</span><span class="token number">1575638467</span><span class="token punctuation">,</span><span class="token property">"title"</span><span class="token operator">:</span><span class="token string">"my_title"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>完美。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>这篇文章的结束不是这个话题的结束。关于go语言中使用json还有很多话题可以讨论，这里仅仅是将go中的struct转换成json输出，此外，还有将json转换成struct，以及自定义<code>Marshal</code>和<code>Unmarshal</code>函数等话题。</p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/lufy.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Keep Simple</title>
      <link href="/keep-simple/"/>
      <url>/keep-simple/</url>
      
        <content type="html"><![CDATA[<blockquote><p>保持简单，记录生活中的美好。</p></blockquote><h2 id="1-Year-Reading"><a href="#1-Year-Reading" class="headerlink" title="1. Year Reading"></a>1. Year Reading</h2><p>2019年阅读总结：<a href="https://deuterium.fun/year-reading-in-2019/">https://deuterium.fun/year-reading-in-2019/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Keep Curious</title>
      <link href="/keep-curious/"/>
      <url>/keep-curious/</url>
      
        <content type="html"><![CDATA[<blockquote><p>世界多么奇妙，保持好奇，努力探索。这里列出其他学科的学习文章。</p></blockquote><h2 id="1-Physics"><a href="#1-Physics" class="headerlink" title="1. Physics"></a>1. Physics</h2><p>物理是什么（《费恩曼物理学讲义》第一章-第三章）：<a href="https://deuterium.fun/what-is-physics/">https://deuterium.fun/what-is-physics/</a></p><h2 id="2-Economics"><a href="#2-Economics" class="headerlink" title="2. Economics"></a>2. Economics</h2><h2 id="3-Geography"><a href="#3-Geography" class="headerlink" title="3. Geography"></a>3. Geography</h2><h2 id="4-History"><a href="#4-History" class="headerlink" title="4. History"></a>4. History</h2><p>罗马王国和罗马共和国：<a href="https://deuterium.fun/roman-republic/">https://deuterium.fun/roman-republic/</a></p><p>罗马帝国：<a href="https://deuterium.fun/roman-empire/">https://deuterium.fun/roman-empire/</a></p><p>《中国历代政治得失》脑图：<a href="https://deuterium.fun/zhong-guo-li-dai-zheng-zhi-de-shi-bi-ji/">https://deuterium.fun/zhong-guo-li-dai-zheng-zhi-de-shi-bi-ji/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Keep Serious</title>
      <link href="/keep-serious/"/>
      <url>/keep-serious/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我是个程序员，这里列出所有涉及到CS的文章。保持认真，不断前进。</p></blockquote><h2 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1. 数据库"></a>1. 数据库</h2><h3 id="1-1-MySQL"><a href="#1-1-MySQL" class="headerlink" title="1.1 MySQL"></a>1.1 MySQL</h3><p>MySQL中的字符集和字符序：<a href="https://deuterium.fun/character-sets-and-collations-in-mysql/">https://deuterium.fun/character-sets-and-collations-in-mysql/</a></p><p>MySQL中的数据类型介绍：<a href="https://deuterium.fun/data-types-in-mysql/">https://deuterium.fun/data-types-in-mysql/</a></p><p>把一个本地文件导入到MySQL表中：<a href="https://deuterium.fun/files-to-mysql/">https://deuterium.fun/files-to-mysql/</a></p><p>MySQL导入文件使用的<code>LOAD DATA</code>的原理：<a href="https://deuterium.fun/what-happens-when-using-load-data/">https://deuterium.fun/what-happens-when-using-load-data/</a></p><p>关于MySQL中的几种分区方式：<a href="https://deuterium.fun/all-you-need-to-know-about-mysql-partitions-part-1/">https://deuterium.fun/all-you-need-to-know-about-mysql-partitions-part-1/</a></p><p>MySQL分区的各种操作：<a href="https://deuterium.fun/all-you-need-to-know-about-mysql-partitions-part-2/">https://deuterium.fun/all-you-need-to-know-about-mysql-partitions-part-2/</a></p><p>使用pt-osc对MySQL表结构进行修改：<a href="https://deuterium.fun/use-pt-osc-to-alter-mysql-table/">https://deuterium.fun/use-pt-osc-to-alter-mysql-table/</a></p><h3 id="1-2-Redis"><a href="#1-2-Redis" class="headerlink" title="1.2 Redis"></a>1.2 Redis</h3><p>把文件导入Redis中：<a href="https://deuterium.fun/file-to-redis/">https://deuterium.fun/file-to-redis/</a></p><h2 id="2-Programming"><a href="#2-Programming" class="headerlink" title="2. Programming"></a>2. Programming</h2><h3 id="2-1-Go-Web"><a href="#2-1-Go-Web" class="headerlink" title="2.1 Go Web"></a>2.1 Go Web</h3><p>Go Web 1 处理器和多路选择器：<a href="https://deuterium.fun/go-web-part-1-handler-servemux/">https://deuterium.fun/go-web-part-1-handler-servemux/</a></p><p>Go Web 2 请求：<a href="https://deuterium.fun/go-web-part-2-request/">https://deuterium.fun/go-web-part-2-request/</a></p><p>Go Web 3 响应：<a href="https://deuterium.fun/go-web-part-3-response/">https://deuterium.fun/go-web-part-3-response/</a></p><p>Go Web 4 Cookie：<a href="https://deuterium.fun/go-web-part-4-cookie/">https://deuterium.fun/go-web-part-4-cookie/</a></p><h3 id="2-2-Go"><a href="#2-2-Go" class="headerlink" title="2.2 Go"></a>2.2 Go</h3><p>Go中结构体到json的花样输出：<a href="https://deuterium.fun/go-struct-to-json/">https://deuterium.fun/go-struct-to-json/</a></p><h2 id="3-Security"><a href="#3-Security" class="headerlink" title="3. Security"></a>3. Security</h2><h3 id="3-1-TLS"><a href="#3-1-TLS" class="headerlink" title="3.1 TLS"></a>3.1 TLS</h3><p>TLS简单介绍：<a href="https://deuterium.fun/ssl-and-tls-part-1-brief-intro/">https://deuterium.fun/ssl-and-tls-part-1-brief-intro/</a></p><p>TLS背后的密码学知识：<a href="https://deuterium.fun/ssl-and-tls-part-2-cryptography/">https://deuterium.fun/ssl-and-tls-part-2-cryptography/</a></p><p>TLS协议：<a href="https://deuterium.fun/ssl-and-tls-part-3-protocol/">https://deuterium.fun/ssl-and-tls-part-3-protocol/</a></p><h2 id="4-经典阅读"><a href="#4-经典阅读" class="headerlink" title="4. 经典阅读"></a>4. 经典阅读</h2><h3 id="4-1-csapp"><a href="#4-1-csapp" class="headerlink" title="4.1 csapp"></a>4.1 csapp</h3><p>第一章 计算机系统漫游：<a href="https://deuterium.fun/csapp-ch1-a-tour-of-computer-systems/">https://deuterium.fun/csapp-ch1-a-tour-of-computer-systems/</a></p><p>第二章第一节 信息的存储：<a href="https://deuterium.fun/csapp-ch02-part-1-information-storage/">https://deuterium.fun/csapp-ch02-part-1-information-storage/</a></p><p>第二章第二节 整数的表示：<a href="https://deuterium.fun/csapp-ch02-part-2-integer-representations/">https://deuterium.fun/csapp-ch02-part-2-integer-representations/</a></p><p>第二章第三节 整数的运算：<a href="https://deuterium.fun/csapp-ch02-part-3-integer-arithmetic/">https://deuterium.fun/csapp-ch02-part-3-integer-arithmetic/</a></p><p>第二章第四节 浮点数：<a href="https://deuterium.fun/csapp-ch02-part-4-floating-point/">https://deuterium.fun/csapp-ch02-part-4-floating-point/</a></p><p>第二章总结：<a href="https://deuterium.fun/csapp-ch02-part-5-summary/">https://deuterium.fun/csapp-ch02-part-5-summary/</a></p><h3 id="4-2-ddia"><a href="#4-2-ddia" class="headerlink" title="4.2 ddia"></a>4.2 ddia</h3><p>第一二章 数据系统术语、方法，数据模型和查询语言：<a href="https://deuterium.fun/ddia-foundations-of-data-systems-part-1-terminology-approach-data-models-and-query-languages/">https://deuterium.fun/ddia-foundations-of-data-systems-part-1-terminology-approach-data-models-and-query-languages/</a></p><p>第三章 数据存储与检索：<a href="https://deuterium.fun/ddia-foundations-of-data-systems-part-2-storage-and-retrieval/">https://deuterium.fun/ddia-foundations-of-data-systems-part-2-storage-and-retrieval/</a></p><p>第四章 数据编码与演化：<a href="https://deuterium.fun/ddia-foundations-of-data-systems-part-3-encoding-and-evolution/">https://deuterium.fun/ddia-foundations-of-data-systems-part-3-encoding-and-evolution/</a></p><p>第五章 复制：<a href="https://deuterium.fun/ddia-distributed-data-part-1-replication/">https://deuterium.fun/ddia-distributed-data-part-1-replication/</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
