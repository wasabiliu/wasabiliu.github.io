<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go Web (Part 4): Cookie</title>
      <link href="/2020/01/08/go-web-part-4-cookie/"/>
      <url>/2020/01/08/go-web-part-4-cookie/</url>
      
        <content type="html"><![CDATA[<p>HTTP是一个无状态的协议。</p><p>这意味着服务器不会记录客户的状态。但是有时候服务器需要知道客户端的状态，这个时候就可以使用Cookie了。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb11.png"><h3 id="1-Cookie-in-Golang"><a href="#1-Cookie-in-Golang" class="headerlink" title="1. Cookie in Golang"></a>1. Cookie in Golang</h3><p>在Go中，定义了Cookie的结构：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Cookie <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name  <span class="token builtin">string</span>    Value <span class="token builtin">string</span>    Path       <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// optional</span>    Domain     <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// optional</span>    Expires    time<span class="token punctuation">.</span>Time <span class="token comment" spellcheck="true">// optional</span>    RawExpires <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// for reading cookies only</span>    <span class="token comment" spellcheck="true">// MaxAge=0 means no 'Max-Age' attribute specified.</span>    <span class="token comment" spellcheck="true">// MaxAge&lt;0 means delete cookie now, equivalently 'Max-Age: 0'</span>    <span class="token comment" spellcheck="true">// MaxAge>0 means Max-Age attribute present and given in seconds</span>    MaxAge   <span class="token builtin">int</span>    Secure   <span class="token builtin">bool</span>    HttpOnly <span class="token builtin">bool</span>    SameSite SameSite    Raw      <span class="token builtin">string</span>    Unparsed <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token comment" spellcheck="true">// Raw text of unparsed attribute-value pairs</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实Cookie就是一个key-value对，用来存储一些简单的信息。也就是上面的字段中，<code>Name</code>和<code>Value</code>是必须的，其余的都是可选的。</p><p><code>Expires</code>和<code>MaxAge</code>都可以用来设置Cookie的有效期。不同在于：</p><ol><li><code>Expires</code>指定了Cookie过期的具体时间，比如一个Cookie会在2020-02-02 02:02:02过期；</li><li><code>MaxAge</code>指定了一个Cookie在被浏览器创建后可以存在的时间，单位是秒；</li><li>几乎所有的浏览器都支持<code>Expires</code>，但是IE6、IE7和IE8不支持<code>MaxAge</code>。</li></ol><p>使用这两种方式不是Go的原因，而是浏览器的支持情况决定的。</p><h3 id="2-设置Cookie"><a href="#2-设置Cookie" class="headerlink" title="2. 设置Cookie"></a>2. 设置Cookie</h3><p>服务器设置Cookie本质上就是将一个字符串写入response中的”Set-Cookie” Header中。而这个写入的字符串，是对Cookie结构的一个序列化结果（就是<code>Cookie.String()</code>方法）。</p><pre class="line-numbers language-go"><code class="language-go">c <span class="token operator">:=</span> http<span class="token punctuation">.</span>Cookie<span class="token punctuation">{</span>    Name<span class="token punctuation">:</span>  <span class="token string">"cookie"</span><span class="token punctuation">,</span>    Value<span class="token punctuation">:</span> <span class="token string">"go web"</span><span class="token punctuation">,</span><span class="token punctuation">}</span>w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Set-Cookie"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打开浏览器可以看到下面的结果：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/cookie_result.png"><p>也可以使用<code>http.SetCookie()</code>方法：</p><pre class="line-numbers language-go"><code class="language-go">c <span class="token operator">:=</span> http<span class="token punctuation">.</span>Cookie<span class="token punctuation">{</span>    Name<span class="token punctuation">:</span>  <span class="token string">"cookie"</span><span class="token punctuation">,</span>    Value<span class="token punctuation">:</span> <span class="token string">"go web"</span><span class="token punctuation">,</span><span class="token punctuation">}</span>http<span class="token punctuation">.</span><span class="token function">SetCookie</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果也是一样，不过要注意，这里使用的是Cookie的指针。</p><h3 id="3-读取Cookie"><a href="#3-读取Cookie" class="headerlink" title="3. 读取Cookie"></a>3. 读取Cookie</h3><p>服务器写入Cookie的Header是<code>Set-Cookie</code>，浏览器向服务器传递Cookie的Header是<code>Cookie</code>，可以通过这个Header来读取浏览器的Cookie：</p><pre class="line-numbers language-go"><code class="language-go">h <span class="token operator">:=</span> r<span class="token punctuation">.</span>Header<span class="token punctuation">[</span><span class="token string">"Cookie"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样获取到的是所有的Cookie切片。为了获取所有的Cookie，还可以使用下面的方法：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Cookies parses and returns the HTTP cookies sent with the request.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">Cookies</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Cookie <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">readCookies</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Header<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面两个方法获得的是所有的Cookie，还可以获取指定的Cookie：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Cookie returns the named cookie provided in the request or</span><span class="token comment" spellcheck="true">// ErrNoCookie if not found.</span><span class="token comment" spellcheck="true">// If multiple cookies match the given name, only one cookie will</span><span class="token comment" spellcheck="true">// be returned.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">Cookie</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Cookie<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> c <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token function">readCookies</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Header<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> c<span class="token punctuation">,</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> ErrNoCookie<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过这会在Cookie不存在的时候返回一个错误。具体使用如下：</p><pre class="line-numbers language-go"><code class="language-go">c<span class="token punctuation">,</span> err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">Cookie</span><span class="token punctuation">(</span><span class="token string">"cookie"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"no such cookie"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-删除一个Cookie"><a href="#4-删除一个Cookie" class="headerlink" title="4. 删除一个Cookie"></a>4. 删除一个Cookie</h3><p>Go里没有删除Cookie的方法，不过可以通过设置一个Cookie有效期来间接删除一个Cookie。</p><p>可以将一个Cookie的<code>Expires</code>设置为一个过去的时间，或者<code>MaxAge</code>设置为负数，就可以删除一个Cookie了：</p><pre class="line-numbers language-go"><code class="language-go">c <span class="token operator">:=</span> http<span class="token punctuation">.</span>Cookie<span class="token punctuation">{</span>    Name<span class="token punctuation">:</span> <span class="token string">"old_cookie"</span><span class="token punctuation">,</span>    MaxAge<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>    Expires<span class="token punctuation">:</span> time<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span>http<span class="token punctuation">.</span><span class="token function">SetCookie</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这篇文章简单介绍了一下在Go中如果使用Cookie，包括添加、读取以及删除。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb12.png"><p>To Be Continued…</p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Web (Part 3): response</title>
      <link href="/2020/01/02/go-web-part-3-response/"/>
      <url>/2020/01/02/go-web-part-3-response/</url>
      
        <content type="html"><![CDATA[<p>有请求就要有响应，一来一回。这篇文章来看看response的细节。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb9.png"><h3 id="1-从处理器Handler开始"><a href="#1-从处理器Handler开始" class="headerlink" title="1. 从处理器Handler开始"></a>1. 从处理器Handler开始</h3><p>对于Request，在前一篇文章中已经知道了整个的流程。Go会构造一个<code>Request</code>结构体，将接收到的请求中的信息解析到这个结构体中。对于一些信息（比如三个Form）需要手动调用一些函数来填充。这样在之后的处理过程中就可以通过这个<code>Request</code>结构来获取具体的请求信息了。</p><p>那么对于Response，是不是也是这个过程呢？创建一个Response结构，将数据保存在这个结构中，然后返回给客户端？</p><p>不是的，服务端返回响应的时候，使用的是<code>ResponseWriter</code>接口。这一点可以从处理器Handler的定义来看：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>两个参数分别对应响应和请求。</p><p><code>net/http</code>包内部使用<code>response</code>结构来处理响应，由于是非导出类型，不能直接操作，所以通过这个接口，来操作具体的响应。</p><p>而在通过<code>ResponseWriter</code>接口操作<code>response</code>时，传递的也是指向<code>response</code>结构的指针，这也解释了为什么处理器Handler的两个参数一个是值一个是引用，因为底层实际上都是引用。</p><h3 id="2-使用ResponseWriter进行写入"><a href="#2-使用ResponseWriter进行写入" class="headerlink" title="2. 使用ResponseWriter进行写入"></a>2. 使用ResponseWriter进行写入</h3><p>在具体看看Go是怎么处理response的之前，先看看怎么使用<code>ResponseWriter</code>进行写入。</p><p><code>ResponseWriter</code>接口有三个方法：</p><ul><li><code>Write</code>：将指定的数据写入对应的链接作为响应结果；</li><li><code>WriteHeader</code>：用来写入一个HTTP响应码（比如200 OK）；</li><li><code>Header</code>：返回Header，可以用来设置值。</li></ul><p>而<code>response</code>结构实现了这几个方法。</p><h4 id="2-1-Sending-Header"><a href="#2-1-Sending-Header" class="headerlink" title="2.1 Sending Header"></a>2.1 Sending Header</h4><p>可以直接通过<code>WriteHeader()</code>方法来写入HTTP响应码：</p><pre class="line-numbers language-go"><code class="language-go">w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Server"</span><span class="token punctuation">,</span> <span class="token string">"A Test Server"</span><span class="token punctuation">)</span>w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里首先通过<code>Header()</code>方法返回Header然后设置一个值，接下来通过<code>WriteHeader()</code>方法设置HTTP响应码为200。</p><p>通过curl可以看到下面的结果：</p><pre class="line-numbers language-shell"><code class="language-shell">HTTP/1.1 200 OKServer: A Test ServerDate: Thu, 02 Jan 2020 08:18:24 GMTContent-Length: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其实，对于HTTP响应码200来说，不用显示写入，默认就会写入这个响应码。对于<code>WriteHeader</code>方法来说，最常见的应用是写入HTTP的错误码。</p><p>比如，下面的代码实现了一次HTTP重定向：</p><pre class="line-numbers language-go"><code class="language-go">w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Location"</span><span class="token punctuation">,</span> <span class="token string">"http://google.com"</span><span class="token punctuation">)</span>w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span><span class="token number">302</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这时启动浏览器之后就会自动跳到Google的页面了。</p><h4 id="2-2-Rendering-Plain-Text"><a href="#2-2-Rendering-Plain-Text" class="headerlink" title="2.2 Rendering Plain Text"></a>2.2 Rendering Plain Text</h4><p>在之前的文章中，都是通过<code>fmt.Fprintf(w, &quot;hello&quot;)</code>这种方式写入响应的。原理都是一样，也可以使用<code>Write()</code>方法来写入结果：</p><pre class="line-numbers language-go"><code class="language-go">w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"I'm a Test Server"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不同在于，这里的参数是一个<code>[]byte</code>。结果：</p><pre class="line-numbers language-shell"><code class="language-shell">HTTP/1.1 200 OKDate: Thu, 02 Jan 2020 08:27:49 GMTContent-Length: 17Content-Type: text/plain; charset=utf-8I'm a Test Server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出：</p><ul><li>对于200响应码不用手动写入；</li><li><code>Content-Length</code>字段标识了响应的长度。</li></ul><h4 id="2-3-Rendering-JSON"><a href="#2-3-Rendering-JSON" class="headerlink" title="2.3 Rendering JSON"></a>2.3 Rendering JSON</h4><p>上面写入的响应是一个纯文本。同样可以对响应写入JSON格式的数据：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>        Name <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>        Age  <span class="token builtin">int</span>    <span class="token string">`json:"age"`</span>    <span class="token punctuation">}</span>    data<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>User<span class="token punctuation">{</span><span class="token string">"Valineliu"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json"</span><span class="token punctuation">)</span>    w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意需要通过<code>Header()</code>方法将内容类型设置成<code>application/json</code>，不然就是纯文本了。结果：</p><pre class="line-numbers language-shell"><code class="language-shell">HTTP/1.1 200 OKContent-Type: application/jsonDate: Thu, 02 Jan 2020 08:32:49 GMTContent-Length: 29{"name":"Valineliu","age":25}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然除了JSON格式外，还可以写入XML等格式。</p><h4 id="2-4-Serving-a-File"><a href="#2-4-Serving-a-File" class="headerlink" title="2.4 Serving a File"></a>2.4 Serving a File</h4><p>还可以发送一个文件：</p><pre class="line-numbers language-go"><code class="language-go">http<span class="token punctuation">.</span><span class="token function">ServeFile</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token string">"luffy.jpg"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过这个函数就可以了。打开浏览器就可以看到结果。使用curl结果：</p><pre class="line-numbers language-shell"><code class="language-shell">HTTP/1.1 200 OKAccept-Ranges: bytesContent-Length: 54146Content-Type: image/jpegLast-Modified: Wed, 06 Nov 2019 01:50:35 GMTDate: Thu, 02 Jan 2020 08:39:48 GMT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-看看具体发生了什么"><a href="#3-看看具体发生了什么" class="headerlink" title="3. 看看具体发生了什么"></a>3. 看看具体发生了什么</h3><p>除了上面的那些类型的内容外，还可以返回一个HTML模板，这里就不详细说了。</p><p>接下来看看<code>net/http</code>包是怎么通过<code>ResponseHeader</code>操作<code>response</code>的。</p><p><code>response</code>定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> response <span class="token keyword">struct</span> <span class="token punctuation">{</span>    conn             <span class="token operator">*</span>conn    req              <span class="token operator">*</span>Request <span class="token comment" spellcheck="true">// request for this response</span>    reqBody          io<span class="token punctuation">.</span>ReadCloser    w  <span class="token operator">*</span>bufio<span class="token punctuation">.</span>Writer    <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里只是一部分的字段，原来这个<code>response</code>结构竟然还有请求的字段。</p><p>当链接收到一个请求后，会调用<code>server()</code>方法进行处理，简略的过程如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Serve a new connection.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">serve</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>    w<span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">readRequest</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>    <span class="token operator">...</span>    req <span class="token operator">:=</span> w<span class="token punctuation">.</span>req    <span class="token operator">...</span>    serverHandler<span class="token punctuation">{</span>c<span class="token punctuation">.</span>server<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> w<span class="token punctuation">.</span>req<span class="token punctuation">)</span>    <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先通过<code>readRequest()</code>方法获得<code>response</code>，这个时候里面的<code>Resquest</code>已经构造好了。之后就可以使用<code>w</code>和<code>w.req</code>作为参数调用<code>ServeHTTP</code>了。</p><p>而在<code>readRequest()</code>方法中：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Read next request from connection.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">readRequest</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>    req<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">readRequest</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>bufr<span class="token punctuation">,</span> keepHostHeader<span class="token punctuation">)</span>    <span class="token operator">...</span>    w <span class="token operator">=</span> <span class="token operator">&amp;</span>response<span class="token punctuation">{</span>        conn<span class="token punctuation">:</span>          c<span class="token punctuation">,</span>        cancelCtx<span class="token punctuation">:</span>     cancelCtx<span class="token punctuation">,</span>        req<span class="token punctuation">:</span>           req<span class="token punctuation">,</span>        reqBody<span class="token punctuation">:</span>       req<span class="token punctuation">.</span>Body<span class="token punctuation">,</span>        handlerHeader<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span>Header<span class="token punctuation">)</span><span class="token punctuation">,</span>        contentLength<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>        closeNotifyCh<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// We populate these ahead of time so we're not</span>        <span class="token comment" spellcheck="true">// reading from req.Header after their Handler starts</span>        <span class="token comment" spellcheck="true">// and maybe mutates it (Issue 14940)</span>        wants10KeepAlive<span class="token punctuation">:</span> req<span class="token punctuation">.</span><span class="token function">wantsHttp10KeepAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        wantsClose<span class="token punctuation">:</span>       req<span class="token punctuation">.</span><span class="token function">wantsClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> isH2Upgrade <span class="token punctuation">{</span>        w<span class="token punctuation">.</span>closeAfterReply <span class="token operator">=</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span>    w<span class="token punctuation">.</span>cw<span class="token punctuation">.</span>res <span class="token operator">=</span> w    w<span class="token punctuation">.</span>w <span class="token operator">=</span> <span class="token function">newBufioWriterSize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">.</span>cw<span class="token punctuation">,</span> bufferBeforeChunkingSize<span class="token punctuation">)</span>    <span class="token keyword">return</span> w<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这个<code>response</code>的整个构造过程。这样，后序的处理就可以通过<code>ResponseWriter</code>接口来处理了。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb10.png"><p>To Be Continued…</p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Year Reading in 2019</title>
      <link href="/2019/12/27/year-reading-in-2019/"/>
      <url>/2019/12/27/year-reading-in-2019/</url>
      
        <content type="html"><![CDATA[<p>又是一年岁暮时。</p><p>最近才意识到，便随着2019年的过去，一个时代也过去了。</p><p>年初定的超过2017年的读书计划，接近但是没有完成（2017年120本，2019年113本，2018年太惨了28本）。</p><p>一个华丽的柱状图：</p><p><img src="https://img9.doubanio.com/view/note/l/public/p68718394.jpg" alt="奥古斯都月太惨了"></p><p>距离2019年结束还有五天，剩下的时间最多只能看一本了。</p><p>对于今年还算满意，按分类统计：</p><p><img src="https://img9.doubanio.com/view/note/l/public/p68718396.jpg" alt="我还是爱看故事哇"></p><h2 id="读阿婆，看人性"><a href="#读阿婆，看人性" class="headerlink" title="读阿婆，看人性"></a>读阿婆，看人性</h2><blockquote><p>人性在哪里都一样。</p></blockquote><p>年初的时候，计算用半年的时间看完阿婆的所有小说，一共八十多本。</p><p>结果我失败了（只看了30多本）。</p><p>失败的原因不是我不能坚持下来，是因为大名鼎鼎的阿婆也有好多一般甚至不咋地的书。</p><p>但这不能磨灭我对阿婆的爱！</p><p>阿婆的小说深入人性，绝大多数谋杀都是为了自己的私欲（也有个别的不是比如东方快车）。场景布局大多在不大的空间中，比如庄园、轮船或火车等。一开始就疑云密布，稍不注意就会被误导，结局又往往大出所料。</p><p>其中，我觉得精彩的有：</p><img src="http://img3.doubanio.com/view/subject/l/public/s26849345.jpg" style="zoom:20%"><p><a href="https://book.douban.com/subject/24859822/" target="_blank" rel="noopener">无人生还</a></p><p>★★★★★8.6</p><p>人在面临死亡的时候很难冷静下来，从而作出错误的决定。勿以恶小。</p><img src="http://img1.doubanio.com/view/subject/l/public/s1765799.jpg" style="zoom:37%"><p><a href="https://book.douban.com/subject/1827374/" target="_blank" rel="noopener">东方快车谋杀案</a></p><p>★★★★★9.0</p><p>心理描写过于精彩。</p><img src="http://img1.doubanio.com/view/subject/l/public/s27027698.jpg" style="zoom:22%"><p><a href="https://book.douban.com/subject/25697546/" target="_blank" rel="noopener">尼罗河上的惨案</a></p><p>★★★★★8.6</p><p>许多伟大的爱情都是悲剧。重要的不是过去，而是未来。</p><img src="http://img1.doubanio.com/view/subject/l/public/s26716169.jpg" style="zoom:23%"><p><a href="https://book.douban.com/subject/24737009/" target="_blank" rel="noopener">ABC谋杀案</a></p><p>★★★★☆8.3</p><p>一系列谋杀是为了掩盖另一个谋杀。</p><img src="http://img9.doubanio.com/view/subject/l/public/s26841474.jpg" style="zoom:23%"><p><a href="https://book.douban.com/subject/24852594/" target="_blank" rel="noopener">底牌</a></p><p>★★★★☆8.0</p><p>波洛从人性与性格方面入手以及分析真的是太精彩了。还有，犯罪不能纵容，不然会越来越严重。</p><img src="http://img3.doubanio.com/view/subject/l/public/s27988902.jpg" style="zoom:23%"><p><a href="https://book.douban.com/subject/26292535/" target="_blank" rel="noopener">帷幕</a></p><p>★★★★★8.9</p><p>一生都在制止谋杀的人在最后亲自谋杀了一个人渣。有时候，法律也是很无力。</p><h2 id="认真，不麻烦别人"><a href="#认真，不麻烦别人" class="headerlink" title="认真，不麻烦别人"></a>认真，不麻烦别人</h2><blockquote><p>我喜欢认真的人，与此同时最害怕那些把自己的欲望放在第一位、给别人添了麻烦也毫不在乎的人。哪怕他们再遵纪守法，不顾他人感受并且不以为然这一点仍让我觉得可怕，不想和他们做朋友。我总在想，这个世界全靠认真的人才得以运转。</p></blockquote><p>有那么四个人，他们是“十恶不赦”的银行劫匪，但又是四个最可爱的人。他们处处为他人着想，又努力维持正义。</p><p>伊坂幸太郎说他喜欢认真不给别人带来麻烦的人。我觉得，不麻烦别人是最大的美德了吧。</p><p>这是我喜欢伊坂幸太郎小说的一个原因。它给我带来快乐，让我思考，最后成为指导以后做事的准则。</p><p>当然，还有那暖暖的句子啊。</p><blockquote><p>面对一头剃了毛的羊，上天都会让吹到它身上的风变得温柔。</p></blockquote><img src="http://img1.doubanio.com/view/subject/l/public/s33490929.jpg" style="zoom:25%"><p><a href="https://book.douban.com/subject/30157645/" target="_blank" rel="noopener">阳光劫匪日常与袭击</a></p><p>★★★★☆8.2</p><img src="http://img9.doubanio.com/view/subject/l/public/s29787404.jpg" style="zoom:47%"><p><a href="https://book.douban.com/subject/27609210/" target="_blank" rel="noopener">阳光劫匪倒转地球</a></p><p>★★★★☆8.2</p><img src="http://img1.doubanio.com/view/subject/l/public/s33490927.jpg" style="zoom:25%"><p><a href="https://book.douban.com/subject/30203733/" target="_blank" rel="noopener">阳光劫匪友情测试</a></p><p>★★★★☆8.2</p><h2 id="世界很残酷，但还是活着吧"><a href="#世界很残酷，但还是活着吧" class="headerlink" title="世界很残酷，但还是活着吧"></a>世界很残酷，但还是活着吧</h2><p>上班后一年就磨灭了上学时对工作的种种美好的幻想。</p><p>这个世界，真的太残酷了。</p><p>996，ICU，还有那神奇的251天。</p><p>不过，还是要保持乐观哇，活着，就有希望。</p><img src="http://img3.doubanio.com/view/subject/l/public/s29053580.jpg" style="zoom:80%"><p><a href="https://book.douban.com/subject/4913064/" target="_blank" rel="noopener">活着</a></p><p>★★★★★9.4</p><p>死亡永远不是最可怕的，最可怕的是死亡带走身边所有重要的人，独留自己一个。再读《活着》，悲伤double。</p><img src="http://img3.doubanio.com/view/subject/l/public/s24575140.jpg" style="zoom:80%"><p><a href="https://book.douban.com/subject/4760224/" target="_blank" rel="noopener">许三观卖血记</a></p><p>★★★★★9.0</p><p>小人物艰难生存。我们都是小人物。</p><img src="http://img9.doubanio.com/view/subject/l/public/s29864884.jpg" style="zoom:25%"><p><a href="https://book.douban.com/subject/30259153/" target="_blank" rel="noopener">第七天</a></p><p>★★★★☆7.6</p><p>小人物的种种不幸，就像活生生发生在身边。 如果真的有那个地方，那我们是不是可以死后见想见的人，说想说的话，尽情弥补生前的各种悔恨。 不过，那是死无葬身之地。 人间不值得，人间又值得。珍惜吧。</p><img src="http://img1.doubanio.com/view/subject/l/public/s33463759.jpg" style="zoom:50%"><p><a href="https://book.douban.com/subject/34434309/" target="_blank" rel="noopener">82年生的金智英</a></p><p>★★★★☆7.9</p><p>一篇表面是小说本质是韩国现代女性生存现状的报告。作为男生看了也会对这种种的不平等深感震惊与羞愧。我我我，也有责任。</p><img src="http://img9.doubanio.com/view/subject/l/public/s29952694.jpg" style="zoom:25%"><p><a href="https://book.douban.com/subject/30374817/" target="_blank" rel="noopener">小偷家族</a></p><p>★★★★★8.6</p><p>小偷家族没有偷来什么贵重的东西，但是却偷来了最珍贵的亲情，那些在亲人那里得不到的亲情。又是小人物的艰难生存。</p><h2 id="保持好奇，不停学习"><a href="#保持好奇，不停学习" class="headerlink" title="保持好奇，不停学习"></a>保持好奇，不停学习</h2><blockquote><p>心智是宇宙间最宝贵的东西。</p></blockquote><p>克拉克在《太空漫游中》这么说道。我直到现在，才看了大名鼎鼎的《太空漫游》系列。</p><p>这是什么神仙想象！</p><p>与之类似的，是《猎魔人》。</p><blockquote><p>选取一个有趣的时间段，特别是大动荡时期：战争、宗教冲突、政治压迫、革命等等，把你的主角丢进这个女巫的坩埚，让他在里面寻找出路，让他做出抉择，让他因错误的选择而饱受磨难，让他接受洗礼，让他成熟，让他找到或是失去他的真爱、良知、理想和人性。</p></blockquote><p>《猎魔人》作者安德烈·斯帕克沃斯基这样描述历史奇幻小说的创作方法。</p><p>不管是科幻还是奇幻，都需要大量的知识来支撑庞大的背景设定。出于现实而又高于现实，丰富的想象力与创造力必不可少。</p><p>阅读这样的作品，多多少少能提高一点点创造力吧。</p><p>这个世界很奇妙，很有趣，也很复杂。</p><p>但我好想一点点弄懂啊，了解缤纷世界背后的故事。</p><p>只能不断学习。</p><p>阅读《费恩曼物理学讲义》，析万物之理。</p><p>阅读《经济学原理》，明白生活背后的道理。</p><p>看《地理学与生活》，重拾小时候看地图的乐趣。</p><p>不过这三本我都没看完，，，sad。</p><img src="http://img3.doubanio.com/view/subject/l/public/s32323941.jpg" style="zoom:25%"><p><a href="https://book.douban.com/subject/30481003/" target="_blank" rel="noopener">“太空漫游”四部曲</a></p><p>★★★★★9.0</p><img src="http://img3.doubanio.com/view/subject/l/public/s27987690.jpg" style="zoom:40%"><p><a href="https://book.douban.com/subject/26267087/" target="_blank" rel="noopener">猎魔人1：白狼崛起</a></p><p>★★★★★8.6</p><h2 id="其实还有很多"><a href="#其实还有很多" class="headerlink" title="其实还有很多"></a>其实还有很多</h2><p>除了上面那些，2019年也读了很多别的书。比如托尔斯泰的两部大部头《战争与和平》《安娜·卡列尼娜》，2020年，计划多读这样的名著。</p><p>今年，也开始记录计算机专业书籍了。基础知识需要牢固，希望2020年继续巩固自己的知识网络。</p><p>自己之前一直不屑的howto类书籍，今年也开始看了而且真香，明年继续，形成自己的方法论，这比埋头苦干更重要。</p><h2 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h2><p>最后，附上阅读清单。</p><h3 id="一月"><a href="#一月" class="headerlink" title="一月"></a>一月</h3><ol><li><p>《人性记录》阿加莎</p></li><li><p>《云中命案》阿加莎</p></li><li><p>《万圣节前夜的谋杀》阿加莎</p></li><li><p>《大象的证词》阿加莎</p></li><li><p>《寓所谜案》阿加莎</p></li><li><p>《七面钟之谜》阿加莎</p></li><li><p>《悬崖山庄奇案》阿加莎</p></li><li><p>《藏书室女尸之谜》阿加莎</p></li><li><p>《底牌》阿加莎</p></li><li><p>《天涯过客》阿加莎</p></li><li><p>《长夜》阿加莎</p></li><li><p>《怪屋》阿加莎</p></li><li><p>《魔手》阿加莎</p></li><li><p>《古墓之谜》阿加莎</p></li><li><p>《沉默的证人》阿加莎</p></li></ol><h3 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h3><ol start="16"><li><p>《高尔夫球场命案》阿加莎</p></li><li><p>《流浪地球》刘慈欣</p></li><li><p>《桑苏西来客》阿加莎</p></li><li><p>《阳光下的罪恶》阿加莎</p></li><li><p>《谋杀启事》阿加莎</p></li><li><p>《空幻之屋》阿加莎</p></li><li><p>《命案目睹记》阿加莎</p></li><li><p>《葬礼之后》阿加莎</p></li><li><p>《MySQL必知必会》Ben Forta</p></li><li><p>《鸽群中的猫》阿加莎</p></li></ol><h3 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h3><ol start="26"><li><p>《他们来到巴格达》阿加莎</p></li><li><p>《祖先》易中天</p></li><li><p>《国家》易中天</p></li><li><p>《帷幕》阿加莎</p></li><li><p>《奠基者》易中天</p></li><li><p>《青春志》易中天</p></li><li><p>《从春秋到战国》易中天</p></li><li><p>《百家争鸣》易中天</p></li><li><p>《秦并天下》易中天</p></li><li><p>《汉武的帝国》易中天</p></li><li><p>《阳光劫匪友情测试》伊坂幸太郎</p></li></ol><h3 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h3><ol start="37"><li><p>《作死的兔子大全集》安迪 莱利</p></li><li><p>《两汉两罗马》易中天</p></li><li><p>《阳光劫匪倒转地球》伊坂幸太郎</p></li><li><p>《三国纪》易中天</p></li><li><p>《魏晋风度》易中天</p></li><li><p>《南朝，北朝》易中天</p></li><li><p>《隋唐定局》易中天</p></li></ol><h3 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h3><ol start="44"><li><p>《禅宗兴起》易中天</p></li><li><p>《女皇武则天》易中天</p></li><li><p>《安史之乱》易中天</p></li><li><p>《大宋革新》易中天</p></li><li><p>《王安石变法》易中天</p></li><li><p>《风流南宋》易中天</p></li><li><p>《铁血蒙元》易中天</p></li><li><p>《朱明王朝》易中天</p></li><li><p>《阳光劫匪日常与袭击》伊坂幸太郎</p></li></ol><h3 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h3><ol start="53"><li><p>《H庄园的午餐》阿加莎</p></li><li><p>《金色梦乡》伊坂幸太郎</p></li><li><p>《棋王》阿城</p></li><li><p>《许三观卖血记》余华</p></li><li><p>《兄弟上》余华</p></li></ol><h3 id="七月"><a href="#七月" class="headerlink" title="七月"></a>七月</h3><ol start="58"><li><p>《兄弟下》余华</p></li><li><p>《在细雨中呼喊》余华</p></li><li><p>《第七天》余华</p></li><li><p>《大明王朝的七张面孔》张宏杰</p></li><li><p>《黄昏里的男孩》余华</p></li><li><p>《小狗钱钱》博多 费舍尔</p></li><li><p>《战栗》余华</p></li><li><p>《没有一条道路是重复的》余华</p></li></ol><h3 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h3><ol start="66"><li><p>《野性的呼唤》杰克 伦敦</p></li><li><p>《小狗钱钱2》博多 费舍尔</p></li><li><p>《战争与和平》托尔斯泰</p></li></ol><h3 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h3><ol start="69"><li><p>《海边理发店》荻原浩</p></li><li><p>《七堂极简物理课》卡洛 罗韦利</p></li><li><p>《代码整洁之道：程序员的职业素养》罗伯特 马丁</p></li><li><p>《安娜·卡列尼娜》托尔斯泰</p></li><li><p>《活着》余华</p></li><li><p>《给青年的十二封信》朱光潜</p></li><li><p>《牧羊少年的奇幻之旅》保罗 柯艾略</p></li><li><p>《Go语言实战》</p></li><li><p>《半小时漫画中国史1》陈磊</p></li><li><p>《半小时漫画中国史2》陈磊</p></li><li><p>《半小时漫画中国史3》陈磊</p></li><li><p>《半小时漫画世界史》陈磊</p></li><li><p>《哈佛极简中国史》阿尔伯特 克雷格</p></li></ol><h3 id="十月"><a href="#十月" class="headerlink" title="十月"></a>十月</h3><ol start="82"><li><p>《博物馆里的极简中国史》张经纬</p></li><li><p>《两个故宫的离合》夜岛刚</p></li><li><p>《Redis 4.x Cookbook 》</p></li><li><p>《借镜杀人》阿加莎</p></li><li><p>《时间之书》余世存 老树</p></li><li><p>《我在故宫修文物》</p></li><li><p>《这里是中国》</p></li><li><p>《红墙黄瓦》张克群</p></li><li><p>《半小时漫画唐诗》陈磊</p></li><li><p>《半小时漫画唐诗2》陈磊</p></li><li><p>《万古江河》许倬云</p></li><li><p>《这样读书就够了》赵周</p></li><li><p>《半小时漫画经济学》陈磊</p></li><li><p>《半小时漫画经济学2》陈磊</p></li></ol><h3 id="十一月"><a href="#十一月" class="headerlink" title="十一月"></a>十一月</h3><ol start="96"><li><p>《四魔头》阿加莎</p></li><li><p>《地理的故事》房龙</p></li><li><p>《何以中国》许宏</p></li><li><p>《日本人为何选择了战争》加藤阳子</p></li><li><p>《思维导图》胡雅茹</p></li><li><p>《万物发明指南》瑞安 诺思</p></li><li><p>《2001：太空漫游》克拉克</p></li><li><p>《如何高效学习》斯科特 杨</p></li><li><p>《2010：太空漫游》克拉克</p></li></ol><h3 id="十二月"><a href="#十二月" class="headerlink" title="十二月"></a>十二月</h3><ol start="105"><li><p>《2061：太空漫游》克拉克</p></li><li><p>《3001：太空漫游》克拉克</p></li><li><p>《82年生的金智英》赵南柱</p></li><li><p>《山茶文具店》小川糸</p></li><li><p>《少帅》张爱玲</p></li><li><p>《Go Web编程》</p></li><li><p>《猎魔人1：白狼崛起》斯帕克沃斯基</p></li><li><p>《小偷家族》是枝裕和</p></li><li><p>《猎魔人2：宿命之剑》斯帕克沃斯基</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Web (Part 2): Request</title>
      <link href="/2019/12/24/go-web-part-2-request/"/>
      <url>/2019/12/24/go-web-part-2-request/</url>
      
        <content type="html"><![CDATA[<p>在了解了使用<code>net/http</code>构建go web服务之后，这篇文章深入了解一下在Go中如何处理一个请求。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb7.png"><h3 id="1-请求包含什么"><a href="#1-请求包含什么" class="headerlink" title="1. 请求包含什么"></a>1. 请求包含什么</h3><p>HTTP Message有Request和Response两种。这里详细看看Request Message，一个请求消息的格式如下：</p><pre class="line-numbers language-shell"><code class="language-shell">method request-URL versionheadersentity-body<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Go中的<code>net/http</code>包提供了一个用于表示HTTP请求消息的结构<code>Reqeust</code>。<code>Request</code>将上面请求消息的内容经过分析后存储在不同的字段中，还包括一系列有用的方法。主要的字段有：</p><ul><li>URL</li><li>Header</li><li>Body</li><li>Form, PostForm, MultipartForm</li></ul><p>除了这些字段，还可以使用<code>Request</code>的一些方法处理请求中的cookie等。</p><h3 id="2-URL"><a href="#2-URL" class="headerlink" title="2. URL"></a>2. URL</h3><p><code>Request</code>中的<code>URL</code>字段可以存储请求中URL的信息，在<code>Reqeuest</code>中的<code>URL</code>字段是一个指向<code>net/url</code>包中<code>URL</code>结构的指针，<code>URL</code>结构主要字段如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> URL <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Scheme     <span class="token builtin">string</span>    User       <span class="token operator">*</span>Userinfo <span class="token comment" spellcheck="true">// username and password information</span>    Host       <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// host or host:port</span>    Path       <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// path (relative paths may omit leading slash)</span>    RawPath    <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// encoded path hint (see EscapedPath method)</span>    RawQuery   <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// encoded query values, without '?'</span>    Fragment   <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// fragment for references, without '#'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>URL的一般格式是这样的：</p><pre class="line-numbers language-shell"><code class="language-shell">scheme://[userinfo@]host/path[?query][#fragment]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中[]中的是可选的信息。</p><p>在<code>net/url</code>包中有解析URL的函数<code>Parse()</code>和<code>ParseRequestURI()</code>，两者都是将传进来的URL解析成一个<code>URL</code>结构并返回这个<code>URL</code>的指针。</p><p>比如这个URL：<a href="https://book.douban.com/people/valineliu/collect?start=30&amp;sort=time&amp;rating=all&amp;filter=all&amp;mode=list#here" target="_blank" rel="noopener">https://book.douban.com/people/valineliu/collect?start=30&amp;sort=time&amp;rating=all&amp;filter=all&amp;mode=list#here</a></p><p>解析之后的结果如下：</p><table><thead><tr><th>Field</th><th>Value</th></tr></thead><tbody><tr><td><code>Scheme</code></td><td>https</td></tr><tr><td><code>Host</code></td><td>book.douban.com</td></tr><tr><td><code>Path</code></td><td>/people/valineliu/collect</td></tr><tr><td><code>RawQuery</code></td><td>start=0&amp;sort=time&amp;rating=all&amp;filter=all&amp;mode=list</td></tr><tr><td><code>Fragment</code></td><td>here</td></tr></tbody></table><p><code>Parse()</code>和<code>ParseRequestURI()</code>不解析<code>RawPath</code>字段，需要调用<code>URL.EscapedPath()</code>函数来获得这个字段值。</p><p><code>RawQuery</code>字段包含了没有解析的查询参数，可以通过对这个参数的解析获得URL中的查询参数，不过可以直接使用<code>Request</code>结构中的<code>Form</code>字段来获取，后面再详细介绍。</p><p>还有一个需要注意的问题就是，如果请求是通过浏览器发送的话，程序就得不到<code>Fragment</code>字段，因为浏览器会截断<code>Fragment</code>，与<code>net/http</code>库无关。</p><h3 id="3-Header"><a href="#3-Header" class="headerlink" title="3. Header"></a>3. Header</h3><p>HTTP请求和响应消息都有一个Header结构，在go中，<code>net/http</code>包中有一个<code>Header</code>结构来存储Header结构。</p><p><code>Header</code>本质上就是一个<code>map</code>，定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Header <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不过值是一个<code>[]string</code>，也就是说，对一个key可以有多个值。</p><p><code>Header</code>有四个基本方法，可以方便地对内容进行操作，分别是<code>Add</code>, <code>Del</code>, <code>Set</code>, <code>Get</code>。其中<code>Set</code>方法会对已有的值进行覆盖。</p><p>除了<code>Get</code>方法外，还可以直接访问<code>Header</code>中某个key的值：</p><pre class="line-numbers language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Header<span class="token punctuation">[</span><span class="token string">"Accept-Encoding"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就像访问一个<code>map</code>一样。这种方式和<code>Get</code>的区别在于，直接访问得到的是一个字符串切片，而使用<code>Get</code>方法得到的是所有的值用逗号分割的字符串：</p><pre class="line-numbers language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Header<span class="token punctuation">[</span><span class="token string">"Accept-Encoding"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"Accept-Encoding"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">[gzip, deflate, br]gzip, deflate, br<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-Body"><a href="#4-Body" class="headerlink" title="4. Body"></a>4. Body</h3><p><code>Request</code>中的<code>Body</code>不仅是请求的Body，也是响应的Body，这里不展开描述。</p><p><code>Body</code>是一个<code>io.ReaderCloser</code>接口，意味着可以调用<code>Read</code>和<code>Close</code>两个方法。下面的例子描述了如何读取请求中的Body：</p><pre class="line-numbers language-go"><code class="language-go">length <span class="token operator">:=</span> r<span class="token punctuation">.</span>ContentLengthbody <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span>r<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>Request</code>中有一个<code>ContentLength</code>字段，这个字段记录了Body的长度，可以通过这个字段指定长度来读取Body中的内容。</p><p>GET请求没有Body，所以需要一个POST请求，可以使用curl：</p><pre class="line-numbers language-shell"><code class="language-shell">curl -id "start=30&sort=time&rating=all&filter=all&mode=list" localhost:8080/world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就可以得到Body了：</p><pre class="line-numbers language-shell"><code class="language-shell">start=30&sort=time&rating=all&filter=all&mode=list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-Form-PostForm-amp-MultipartForm"><a href="#5-Form-PostForm-amp-MultipartForm" class="headerlink" title="5. Form, PostForm &amp; MultipartForm"></a>5. Form, PostForm &amp; MultipartForm</h3><p>前面几个字段在请求达到服务器的时候就通过一定的流程解析出来了，而<code>Request</code>中的这几个关于Form的字段不是自动解析的，需要手动调用各自对应的函数来解析。</p><h4 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h4><p>这几个字段的定义如下：</p><pre class="line-numbers language-go"><code class="language-go">Form url<span class="token punctuation">.</span>ValuesPostForm url<span class="token punctuation">.</span>ValuesMultipartForm <span class="token operator">*</span>multipart<span class="token punctuation">.</span>Form<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中<code>Form</code>和<code>PostForm</code>类型一样：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Values <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也就是一个<code>map</code>，key是字符串，而值是一个字符串切片。即，对于一个key来说，可以有多个值。</p><p><code>MultipartForm</code>的类型不一样：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Form <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Value <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>    File  <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>FileHeader<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>多了一个<code>File</code>字段，这是因为<code>MultipartForm</code>还需要存储文件。</p><p>请求中的参数可以在URL中，也就是这种格式：<code>/people/valineliu/collect?start=30&amp;sort=time</code>，也可以在Body中，比如：<code>curl -id &quot;start=40&quot; localhost:8080/world</code>。同时请求消息中Body中的数据可以通过不同的格式编码发送给服务器。其中常用的有<code>application/x-www-form-urlencoded</code>和<code>multipart/form-data</code>。前一种格式可以将Body中的参数按照URL中参数的格式编码，而后者会将数据编码成一条MIME报文。</p><p>这就导致，三种Form字段在不同的编码方式下能够获得的数据也是不一样的。</p><h4 id="5-2-Form-amp-PostForm"><a href="#5-2-Form-amp-PostForm" class="headerlink" title="5.2 Form &amp; PostForm"></a>5.2 Form &amp; PostForm</h4><p>为了获得<code>Form</code>和<code>PostForm</code>字段，需要调用<code>ParseForm</code>方法：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">ParseForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> err <span class="token builtin">error</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>PostForm <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> r<span class="token punctuation">.</span>Method <span class="token operator">==</span> <span class="token string">"POST"</span> <span class="token operator">||</span> r<span class="token punctuation">.</span>Method <span class="token operator">==</span> <span class="token string">"PUT"</span> <span class="token operator">||</span> r<span class="token punctuation">.</span>Method <span class="token operator">==</span> <span class="token string">"PATCH"</span> <span class="token punctuation">{</span>            r<span class="token punctuation">.</span>PostForm<span class="token punctuation">,</span> err <span class="token operator">=</span> <span class="token function">parsePostForm</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> r<span class="token punctuation">.</span>PostForm <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            r<span class="token punctuation">.</span>PostForm <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span>Values<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>Form <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>PostForm<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>            r<span class="token punctuation">.</span>Form <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span>Values<span class="token punctuation">)</span>            <span class="token function">copyValues</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Form<span class="token punctuation">,</span> r<span class="token punctuation">.</span>PostForm<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">var</span> newValues url<span class="token punctuation">.</span>Values        <span class="token keyword">if</span> r<span class="token punctuation">.</span>URL <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> e <span class="token builtin">error</span>            newValues<span class="token punctuation">,</span> e <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">ParseQuery</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>RawQuery<span class="token punctuation">)</span>            <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                err <span class="token operator">=</span> e            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> newValues <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            newValues <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span>Values<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> r<span class="token punctuation">.</span>Form <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            r<span class="token punctuation">.</span>Form <span class="token operator">=</span> newValues        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">copyValues</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Form<span class="token punctuation">,</span> newValues<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> err<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数是幂等的，也就是多次调用效果一样。从这个解析过程可以发现：</p><ul><li>函数首先解析<code>PostForm</code>字段，然后解析<code>Form</code>字段；</li><li>而在<code>parsePostForm()</code>函数中，只对Body中<code>application/x-www-form-urlencoded</code>编码的参数解析，其余编码格式下<code>PostForm</code>字段为空；</li><li><code>Form</code>中包含<code>PostForm</code>中的信息，而且<code>PostForm</code>中的信息优先级高；</li><li>URL中的参数只会到被解析到<code>Form</code>字段中。</li></ul><p>下面的例子演示了上面的分析：</p><pre class="line-numbers language-go"><code class="language-go">r<span class="token punctuation">.</span><span class="token function">ParseForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span>Form<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span>PostForm<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用curl模拟一个请求：</p><pre class="line-numbers language-shell"><code class="language-shell">curl -id "start=30&mode=list" "localhost:8080/world?start=40&sort=time"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">map[mode:[list] sort:[time] start:[30 40]]map[mode:[list] start:[30]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一个<code>map</code>是<code>Form</code>，第二个是<code>PostForm</code>，从结果可以看到两者的区别。</p><h4 id="5-3-MultipartForm"><a href="#5-3-MultipartForm" class="headerlink" title="5.3 MultipartForm"></a>5.3 MultipartForm</h4><p>对于<code>MultipartForm</code>，需要调用<code>ParseMultipartForm</code>方法，这个方法会在需要的时候（也就是<code>Form</code>和<code>PostForm</code>为<code>nil</code>的时候）调用<code>ParseForm</code>方法先来解析<code>Form</code>和<code>PostForm</code>两个字段：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">ParseMultipartForm</span><span class="token punctuation">(</span>maxMemory <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>MultipartForm <span class="token operator">==</span> multipartByReader <span class="token punctuation">{</span>        <span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"http: multipart handled by MultipartReader"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>Form <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">ParseForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> err        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>MultipartForm <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span>    mr<span class="token punctuation">,</span> err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">multipartReader</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> err    <span class="token punctuation">}</span>    f<span class="token punctuation">,</span> err <span class="token operator">:=</span> mr<span class="token punctuation">.</span><span class="token function">ReadForm</span><span class="token punctuation">(</span>maxMemory<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> err    <span class="token punctuation">}</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>PostForm <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        r<span class="token punctuation">.</span>PostForm <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span>Values<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> f<span class="token punctuation">.</span>Value <span class="token punctuation">{</span>        r<span class="token punctuation">.</span>Form<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Form<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token operator">...</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// r.PostForm should also be populated. See Issue 9305.</span>        r<span class="token punctuation">.</span>PostForm<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>PostForm<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    r<span class="token punctuation">.</span>MultipartForm <span class="token operator">=</span> f    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时需要一个最大读取字节数的参数。</p><p>从这个解析过程可以看到：</p><ul><li>如果<code>Form</code>和<code>PostForm</code>为<code>nil</code>的话，这个函数就先调用<code>ParseForm</code>来进行解析；</li><li>不过如果编码格式是<code>multipart/form-data</code>的话，<code>Form</code>中就只会有URL中的参数，而<code>PostForm</code>中啥也没有（暂时）；</li><li><code>ParseMultipartForm</code>方法会解析Body中<code>multipart/form-data</code>格式的数据到<code>MultipartForm</code>字段中；</li><li>最后还会将Body中的参数添加到<code>Form</code>和<code>PostForm</code>中。</li></ul><p>例子：</p><pre class="line-numbers language-go"><code class="language-go">r<span class="token punctuation">.</span><span class="token function">ParseMultipartForm</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span>Form<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span>PostForm<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span>MultipartForm<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用curl模拟一个请求：</p><pre class="line-numbers language-shell"><code class="language-shell">curl -F "start=30" -F "mode=list" -F upload=@hello "localhost:8080/world?start=40&sort=time"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中前两个-F生成两个<code>multipart/form-data</code>格式的参数，而后一个-F上传一个文件。结果：</p><pre class="line-numbers language-shell"><code class="language-shell">map[mode:[list] sort:[time] start:[40 30]]map[mode:[list] start:[30]]&{map[mode:[list] start:[30]] map[upload:[0xc0000fa140]]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>前两个<code>map</code>还是和之前的一样，最后一个就是<code>MultipartForm</code>，这是两个<code>map</code>，一个是Body中的参数，一个是上传的文件。</p><p>关于<code>Form</code>和之前有一个不同，就是<code>start</code>值的顺序。之前使用<code>ParseForm</code>解析的时候30在前而现在40在前。从两个函数的代码中我们可以看到这个结果的原因。</p><h4 id="5-4-Another-Way"><a href="#5-4-Another-Way" class="headerlink" title="5.4 Another Way"></a>5.4 Another Way</h4><p>除了上面调用<code>ParseForm</code>和<code>ParseMultipartForm</code>函数外，还可以通过其它的方法获取值：<code>FormValue()</code>和<code>PostFormValue()</code>。两个方法的定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">FormValue</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>Form <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        r<span class="token punctuation">.</span><span class="token function">ParseMultipartForm</span><span class="token punctuation">(</span>defaultMaxMemory<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> vs <span class="token operator">:=</span> r<span class="token punctuation">.</span>Form<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">len</span><span class="token punctuation">(</span>vs<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> vs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">PostFormValue</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>PostForm <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        r<span class="token punctuation">.</span><span class="token function">ParseMultipartForm</span><span class="token punctuation">(</span>defaultMaxMemory<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> vs <span class="token operator">:=</span> r<span class="token punctuation">.</span>PostForm<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">len</span><span class="token punctuation">(</span>vs<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> vs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两个函数都会在必要的时候调用<code>ParseMultipartForm</code>函数来进行解析。和前面的方法不同在于，这两个方法返回的是对应key的第一个value值，而不是一个字符串切片。</p><p>例子：</p><pre class="line-numbers language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span><span class="token function">FormValue</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span><span class="token function">PostFormValue</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">4030<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个结果很奇怪是吧，所以对于既在URL中也在Body中的参数，在获取的时候需要小心一些。最好的办法就是参数只出现在一个地方，要么URL中，要么Body中。</p><p>其实常用的编码还有<code>application/json</code>，也就是读取的Body数据可以解析成一个Json结构，这也很常见，不过不在这里细说了。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb8.png"><p>To Be Continued…</p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Web (Part 1): Handler &amp; ServeMux</title>
      <link href="/2019/12/20/go-web-part-1-handler-servemux/"/>
      <url>/2019/12/20/go-web-part-1-handler-servemux/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Begin"><a href="#1-Begin" class="headerlink" title="1. Begin"></a>1. Begin</h3><p>使用Go语言的标准库<code>net/http</code>可以快速构建一个简单的web服务。这篇文章从零开始构建一个简单的web服务器，并主要聚焦于处理器Handler和多路复用器ServeMux。</p><p>在开始之前，MindMap里一无所有：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb1.png"><h3 id="2-The-Simplest-Server"><a href="#2-The-Simplest-Server" class="headerlink" title="2. The Simplest Server"></a>2. The Simplest Server</h3><p>使用<code>net/http</code>包中的<code>ListenAndServe()</code>函数可以快速构建一个最简单的服务器：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>go run</code>命令执行程序，然后在本地浏览器打开<a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> ，得到<code>404 page not found</code>的错误。</p><p>这就是一个最简单的服务器，什么也不做，但确实是一个服务器。</p><p>现在MindMap里多了点东西：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb2.png"><h3 id="3-发生了什么"><a href="#3-发生了什么" class="headerlink" title="3. 发生了什么"></a>3. 发生了什么</h3><p>调用<code>http.ListenAndServe()</code>函数就可以启动一个服务器，那么发生了什么呢？</p><p>查看源码可知这个函数的实现：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span>addr <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    server <span class="token operator">:=</span> <span class="token operator">&amp;</span>Server<span class="token punctuation">{</span>Addr<span class="token punctuation">:</span> addr<span class="token punctuation">,</span> Handler<span class="token punctuation">:</span> handler<span class="token punctuation">}</span>    <span class="token keyword">return</span> server<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>原来是通过构造一个<code>Server</code>并调用这个<code>Server</code>的<code>ListenAndServe()</code>函数实现的。</p><p>那也就是说，我们可以自己构造一个<code>Server</code>，然后启动服务器：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    s <span class="token operator">:=</span> http<span class="token punctuation">.</span>Server<span class="token punctuation">{</span>        Addr<span class="token punctuation">:</span>    <span class="token string">"127.0.0.1:8080"</span><span class="token punctuation">,</span>        Handler<span class="token punctuation">:</span> <span class="token boolean">nil</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    s<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动之后结果一样（如果端口被占用可以换一个端口）。</p><p>使用<code>http.ListenAndServe()</code>函数可以使用两个参数（<code>Addr</code>服务器地址和<code>Handler</code>处理器）就可以启动一个简单的服务。如果需要更加复杂的设置，需要使用<code>Server</code>结构。<code>Server</code>定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// A Server defines parameters for running an HTTP server.</span><span class="token comment" spellcheck="true">// The zero value for Server is a valid configuration.</span><span class="token keyword">type</span> Server <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Addr    <span class="token builtin">string</span>  <span class="token comment" spellcheck="true">// TCP address to listen on, ":http" if empty</span>    Handler Handler <span class="token comment" spellcheck="true">// handler to invoke, http.DefaultServeMux if nil</span>    TLSConfig <span class="token operator">*</span>tls<span class="token punctuation">.</span>Config    ReadTimeout time<span class="token punctuation">.</span>Duration    ReadHeaderTimeout time<span class="token punctuation">.</span>Duration    WriteTimeout time<span class="token punctuation">.</span>Duration    IdleTimeout time<span class="token punctuation">.</span>Duration    MaxHeaderBytes <span class="token builtin">int</span>    TLSNextProto <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>Server<span class="token punctuation">,</span> <span class="token operator">*</span>tls<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> Handler<span class="token punctuation">)</span>    ConnState <span class="token keyword">func</span><span class="token punctuation">(</span>net<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> ConnState<span class="token punctuation">)</span>    ErrorLog <span class="token operator">*</span>log<span class="token punctuation">.</span>Logger    BaseContext <span class="token keyword">func</span><span class="token punctuation">(</span>net<span class="token punctuation">.</span>Listener<span class="token punctuation">)</span> context<span class="token punctuation">.</span>Context    ConnContext <span class="token keyword">func</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> c net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> context<span class="token punctuation">.</span>Context<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，MindMap中又多了点东西，也知道了一些关联：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb3.png"><h3 id="3-处理器Handler"><a href="#3-处理器Handler" class="headerlink" title="3. 处理器Handler"></a>3. 处理器Handler</h3><p>由于<code>Handler</code>为空，所以这个服务器什么也不做只是返回404。为了让服务器做事情，需要添加处理器Handler：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> MyHandler <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mh <span class="token operator">*</span>MyHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    s <span class="token operator">:=</span> http<span class="token punctuation">.</span>Server<span class="token punctuation">{</span>        Addr<span class="token punctuation">:</span>    <span class="token string">"127.0.0.1:8080"</span><span class="token punctuation">,</span>        Handler<span class="token punctuation">:</span> <span class="token operator">&amp;</span>MyHandler<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    s<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果就是得到了一个<code>Hello World</code>。</p><p>这里定义了一个简单的处理器<code>MyHandler</code>，然后添加到定义的<code>Server</code>中。</p><p>所以为了让服务器有事情做，需要定义<code>Handler</code>告诉它做什么。一个<code>Handler</code>其实是一个接口：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Handler <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>任何结构只要有一个签名是这样的函数，都可以作为<code>Server</code>的处理器；同样，任何接受这两个参数的函数，也可以当做一个处理器。</p><p>不过这么做有个明显的缺陷就是，服务器不会通过URL来将请求路由到不同的处理器。为了能根据URL处理不同的请求，我们需要多个处理器。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb4.png"><h3 id="4-多个Handler"><a href="#4-多个Handler" class="headerlink" title="4. 多个Handler"></a>4. 多个Handler</h3><p>直接对<code>Server</code>指定<code>Handler</code>只能添加一个处理器，为了支持多个处理器，需要别的做法：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> HelloHandler <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>hh <span class="token operator">*</span>HelloHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">type</span> WorldHandler <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>wh <span class="token operator">*</span>WorldHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    s <span class="token operator">:=</span> http<span class="token punctuation">.</span>Server<span class="token punctuation">{</span>        Addr<span class="token punctuation">:</span> <span class="token string">"127.0.0.1:8080"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>HelloHandler<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/world"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>WorldHandler<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    s<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里定义了两个<code>Handler</code>，然后通过<code>http.Handle()</code>函数注册这两个<code>Handler</code>而不是直接对<code>Server</code>指定，这样就可以使用两个处理器了。在浏览器中分别访问<a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a> 和 <a href="http://localhost:8080/world" target="_blank" rel="noopener">http://localhost:8080/world</a> 可以得到不同的结果。</p><p>来看看<code>http.Handle()</code>函数做了什么：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Handle registers the handler for the given pattern</span><span class="token comment" spellcheck="true">// in the DefaultServeMux.</span><span class="token comment" spellcheck="true">// The documentation for ServeMux explains how patterns are matched.</span><span class="token keyword">func</span> <span class="token function">Handle</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token punctuation">{</span> DefaultServeMux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> handler<span class="token punctuation">)</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>原来是把具体的<code>Handler</code>注册到了一个叫做<code>DefaultServeMux</code>的变量里，在详细看看具体做了什么之前，先看看处理器函数<code>HandlerFunc</code>。</p><h3 id="5-处理器函数HandlerFunc"><a href="#5-处理器函数HandlerFunc" class="headerlink" title="5. 处理器函数HandlerFunc"></a>5. 处理器函数HandlerFunc</h3><p>除了使用Handler结构外，还可以使用具有相同参数的函数，只不过需要使用<code>http.HandleFunc()</code>函数：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">world</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    s <span class="token operator">:=</span> http<span class="token punctuation">.</span>Server<span class="token punctuation">{</span>        Addr<span class="token punctuation">:</span> <span class="token string">"127.0.0.1:8080"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span> hello<span class="token punctuation">)</span>    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/world"</span><span class="token punctuation">,</span> world<span class="token punctuation">)</span>    s<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果和使用<code>http.Handle()</code>一样。处理器函数能够完成和处理器一样的功能，代码也更简洁一些。可以在实际使用中根据不同场景使用不同的方式。比如，如果代码中已经有处理的接口，只需要添加一个<code>ServeHTTP</code>函数就可以把这个接口转换成处理器了。</p><p>来看看<code>http.HandleFunc()</code>做了什么：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// HandleFunc registers the handler function for the given pattern</span><span class="token comment" spellcheck="true">// in the DefaultServeMux.</span><span class="token comment" spellcheck="true">// The documentation for ServeMux explains how patterns are matched.</span><span class="token keyword">func</span> <span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    DefaultServeMux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>又是<code>DefaultServeMux</code>，接下来详细看看这个是什么，以及它是怎么和<code>Server</code>关联起来的。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb5.png"><h3 id="6-多路复用器ServeMux和DefaultServeMux"><a href="#6-多路复用器ServeMux和DefaultServeMux" class="headerlink" title="6. 多路复用器ServeMux和DefaultServeMux"></a>6. 多路复用器ServeMux和DefaultServeMux</h3><p>不管使用<code>http.Handle()</code>注册处理器<code>Handler</code>还是使用<code>http.HandleFunc()</code>注册处理器函数<code>HandlerFunc</code>，内部都涉及到了一个变量<code>DefaultServeMux</code>，这个是默认的多路复用器，即<code>ServeMux</code>的一个实例：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// DefaultServeMux is the default ServeMux used by Serve.</span><span class="token keyword">var</span> DefaultServeMux <span class="token operator">=</span> <span class="token operator">&amp;</span>defaultServeMux<span class="token keyword">var</span> defaultServeMux ServeMux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>多路复用器的作用就是根据URL将不同的请求路由到不同的处理器上进行处理：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/servemux.PNG"><p><code>ServeMux</code>结构里有一个<code>map</code>，用来保存路由和处理器的映射：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> ServeMux <span class="token keyword">struct</span> <span class="token punctuation">{</span>    mu    sync<span class="token punctuation">.</span>RWMutex    m     <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>muxEntry    es    <span class="token punctuation">[</span><span class="token punctuation">]</span>muxEntry <span class="token comment" spellcheck="true">// slice of entries sorted from longest to shortest.</span>    hosts <span class="token builtin">bool</span>       <span class="token comment" spellcheck="true">// whether any patterns contain hostnames</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而<code>ServeMux</code>的<code>Handle()</code>和<code>HandleFunc()</code>函数就是将处理器注册到这个<code>map</code>里的。</p><p>不过<code>HandleFunc()</code>怎么把一个函数变成一个处理器呢？</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// HandleFunc registers the handler function for the given pattern.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> handler <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"http: nil handler"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    mux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> <span class="token function">HandlerFunc</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原来使用了一个名叫<code>HandlerFunc</code>的结构（注意和<code>http.HandleFunc</code>的区别）完成了转换。<code>HandlerFunc</code>定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// The HandlerFunc type is an adapter to allow the use of</span><span class="token comment" spellcheck="true">// ordinary functions as HTTP handlers. If f is a function</span><span class="token comment" spellcheck="true">// with the appropriate signature, HandlerFunc(f) is a</span><span class="token comment" spellcheck="true">// Handler that calls f.</span><span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// ServeHTTP calls f(w, r).</span><span class="token keyword">func</span> <span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们就理解了不管是<code>http.Handle()</code>还是<code>http.HandleFunc()</code>最终都归结于<code>ServeMux.Handle()</code>。如果不指定<code>ServeMux</code>的话，就使用默认的<code>DefaultServeMux</code>。</p><p>还需要注意一点就是，<code>ServeMux</code>本身也实现了<code>ServeHTTP()</code>函数，也是可以作为处理器的，这就是<code>DefaultServeMux</code>可以作为处理器的原因。</p><h3 id="7-ServeMux是如何路由的"><a href="#7-ServeMux是如何路由的" class="headerlink" title="7. ServeMux是如何路由的"></a>7. ServeMux是如何路由的</h3><p>我们已经大致了解了<code>ServeMux</code>是根据内部维护的一个<code>map</code>来找到具体的处理器的。这里来看看具体的实现细节，对于理解整个流程很有帮助。</p><p>回到最开始，不管是使用<code>http.ListenAndServe()</code>还是<code>Server.ListenAndServe()</code>，都是需要先<code>Listen</code>然后<code>Serve</code>，主要的过程就是创建一个TCP链接然后监听请求，最终就是到<code>serve()</code>函数里，主要代码如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">serve</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>    serverHandler<span class="token punctuation">{</span>c<span class="token punctuation">.</span>server<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> w<span class="token punctuation">.</span>req<span class="token punctuation">)</span>    <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用了一个叫做<code>serverHandler</code>的代理：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> serverHandler <span class="token keyword">struct</span> <span class="token punctuation">{</span>    srv <span class="token operator">*</span>Server<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>sh serverHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>rw ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    handler <span class="token operator">:=</span> sh<span class="token punctuation">.</span>srv<span class="token punctuation">.</span>Handler    <span class="token keyword">if</span> handler <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        handler <span class="token operator">=</span> DefaultServeMux    <span class="token punctuation">}</span>    <span class="token keyword">if</span> req<span class="token punctuation">.</span>RequestURI <span class="token operator">==</span> <span class="token string">"*"</span> <span class="token operator">&amp;&amp;</span> req<span class="token punctuation">.</span>Method <span class="token operator">==</span> <span class="token string">"OPTIONS"</span> <span class="token punctuation">{</span>        handler <span class="token operator">=</span> globalOptionsHandler<span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span>    handler<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>rw<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这里可以看到<code>DefaultServeMux</code>就是默认的多路复用器。所以如果给<code>Server</code>指定了一个<code>Handler</code>，那么就会调用这个<code>Handler</code>的<code>ServeHTTP()</code>函数；如果没有指定的话，就调用<code>DefaultServeMux</code>的<code>ServeHTTP()</code>函数，毕竟我们在前面已经知道<code>DefaultServeMux</code>就是<code>ServeMux</code>的一个实例，而<code>ServeMux</code>实现了<code>ServeHTTP()</code>函数：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// ServeHTTP dispatches the request to the handler whose</span><span class="token comment" spellcheck="true">// pattern most closely matches the request URL.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>RequestURI <span class="token operator">==</span> <span class="token string">"*"</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> r<span class="token punctuation">.</span><span class="token function">ProtoAtLeast</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Connection"</span><span class="token punctuation">,</span> <span class="token string">"close"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>StatusBadRequest<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    h<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">Handler</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>    h<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数所做的就是根据请求找到对应的<code>Handler</code>，然后让这个处理器完成具体的工作。下面就是<code>ServeMux.Handler()</code>函数的主要部分<code>ServeMux.handler()</code>：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// handler is the main implementation of Handler.</span><span class="token comment" spellcheck="true">// The path is known to be in canonical form, except for CONNECT methods.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">handler</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> path <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>h Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// Host-specific pattern takes precedence over generic ones</span>    <span class="token keyword">if</span> mux<span class="token punctuation">.</span>hosts <span class="token punctuation">{</span>        h<span class="token punctuation">,</span> pattern <span class="token operator">=</span> mux<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>host <span class="token operator">+</span> path<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        h<span class="token punctuation">,</span> pattern <span class="token operator">=</span> mux<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        h<span class="token punctuation">,</span> pattern <span class="token operator">=</span> <span class="token function">NotFoundHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">""</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>里面调用了<code>ServeMux.match()</code>函数，其实就是根据URL到<code>map</code>去找具体的<code>Handler</code>：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Find a handler on a handler map given a path string.</span><span class="token comment" spellcheck="true">// Most-specific (longest) pattern wins.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">match</span><span class="token punctuation">(</span>path <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>h Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Check for exact match first.</span>    v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> mux<span class="token punctuation">.</span>m<span class="token punctuation">[</span>path<span class="token punctuation">]</span>    <span class="token keyword">if</span> ok <span class="token punctuation">{</span>        <span class="token keyword">return</span> v<span class="token punctuation">.</span>h<span class="token punctuation">,</span> v<span class="token punctuation">.</span>pattern    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Check for longest valid match.  mux.es contains all patterns</span>    <span class="token comment" spellcheck="true">// that end in / sorted from longest to shortest.</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> e <span class="token operator">:=</span> <span class="token keyword">range</span> mux<span class="token punctuation">.</span>es <span class="token punctuation">{</span>        <span class="token keyword">if</span> strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> e<span class="token punctuation">.</span>pattern<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> e<span class="token punctuation">.</span>h<span class="token punctuation">,</span> e<span class="token punctuation">.</span>pattern        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，精确匹配，找到了就返回。如果没有找到，就根据一定的规则来找，最后如果还没有找到，那么返回404。</p><p>在后面的那个循环中，来找最长匹配的URL。<code>mux.es</code>是一个切片，这里存储的都是在注册<code>Handler</code>时模式以<code>/</code>结尾的：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">Handle</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>    <span class="token keyword">if</span> pattern<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'/'</span> <span class="token punctuation">{</span>        mux<span class="token punctuation">.</span>es <span class="token operator">=</span> <span class="token function">appendSorted</span><span class="token punctuation">(</span>mux<span class="token punctuation">.</span>es<span class="token punctuation">,</span> e<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就清楚了，路由过程如下：</p><ol><li>精确匹配，找到就返回；</li><li>如果没有精确匹配到，就到所有注册<code>Handler</code>时模式以<code>/</code>结尾的模式中寻找，原则是最长匹配；</li><li>还没有找到的话，就404。</li></ol><p>举个例子，比如注册时将<code>hello</code>这个处理器注册到了<code>/hello/</code>下，那么对于<code>/hello/wrong</code>这个请求如果精确匹配没找到的话就可以匹配<code>/hello/</code>，因为这个模式以<code>/</code>结尾；如果注册<code>hello</code>处理器的时候模式是<code>/hello</code>的话，那就不会把<code>/hello/wrong</code>路由到<code>/hello</code>对应的处理器上来了。</p><p><code>ServeMux</code>有一个缺点就是无法使用变量来实现URL模式匹配，比如<code>/post/123</code>这种，可以使用第三方库来避开这个限制。</p><p>这篇文章梳理了一下<code>net/http</code>包中下面的几个概念：</p><ul><li><code>http.ListenAndServe()</code></li><li><code>Server.ListenAndServe()</code></li><li><code>http.Handle()</code></li><li><code>Handler</code></li><li><code>http.HandleFunc()</code></li><li><code>HandlerFunc</code></li><li><code>DefaultServeMux</code></li></ul><p>而在我们的MindMap中，形成了下面的结构：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb6.png"><p>To Be Continued…</p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What Happens When Using LOAD DATA</title>
      <link href="/2019/12/18/what-happens-when-using-load-data/"/>
      <url>/2019/12/18/what-happens-when-using-load-data/</url>
      
        <content type="html"><![CDATA[<p>在之前的文章<a href="http://deuterium.fun/2019/12/17/files-to-mysql/">Files to MySQL</a>中简单介绍了mysqlimport和<code>LOAD DATA</code>的使用，也知道了mysqlimport其实就是使用了<code>LOAD DATA</code>语句。在这篇文章中详细介绍一下<code>LOAD DATA</code>这个语句，来看看当使用这个语句导入数据时到底发生了什么以及一些需要注意的地方。</p><h3 id="1-从Manual开始"><a href="#1-从Manual开始" class="headerlink" title="1. 从Manual开始"></a>1. 从Manual开始</h3><p>在<a href="https://dev.mysql.com/doc/refman/8.0/en/load-data.html" target="_blank" rel="noopener">MySQL手册</a>中详细介绍了<code>LOAD DATA</code>这个语句。下面是这个语句的格式：</p><pre class="line-numbers language-mysql"><code class="language-mysql">LOAD DATA    [LOW_PRIORITY | CONCURRENT] [LOCAL]    INFILE 'file_name'    [REPLACE | IGNORE]    INTO TABLE tbl_name    [PARTITION (partition_name [, partition_name] ...)]    [CHARACTER SET charset_name]    [{FIELDS | COLUMNS}        [TERMINATED BY 'string']        [[OPTIONALLY] ENCLOSED BY 'char']        [ESCAPED BY 'char']    ]    [LINES        [STARTING BY 'string']        [TERMINATED BY 'string']    ]    [IGNORE number {LINES | ROWS}]    [(col_name_or_user_var        [, col_name_or_user_var] ...)]    [SET col_name={expr | DEFAULT},        [, col_name={expr | DEFAULT}] ...]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数还是挺多的，可以在手册里看到详细的介绍。不管怎么样，可以使用这个语句来导入数据了。</p><h3 id="2-文件放在哪"><a href="#2-文件放在哪" class="headerlink" title="2. 文件放在哪"></a>2. 文件放在哪</h3><p>像之前一样，创建一个测试表和测试文件：one_piece表和one_piece.txt文件。</p><p>然后，这个文件放在哪呢？</p><p>毕竟现在涉及到两台机器：mysql client机器和server机器。</p><p>在手册上写着：</p><blockquote><p>If <code>LOCAL</code> is specified, the file is read by the client program on the client host and sent to the server.</p></blockquote><p>就是说MySQL根据<code>LOCAL</code>这个参数来标识在哪里去找这个文件。如果指定了<code>LOCAL</code>就在客户端上找，否则就在服务器上找。</p><h3 id="3-在server上"><a href="#3-在server上" class="headerlink" title="3. 在server上"></a>3. 在server上</h3><p>首先现在服务器上尝试。先看看MySQL存放数据的地方：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT @@datadir;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+------------------------+| @@datadir              |+------------------------+| /usr/local/mysql/data/ |+------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在我的机器上，目录是这个。</p><p>然后把文件放在这个目录下的test目录下，这个test就是对应的数据库。</p><p>然后导入数据：</p><pre class="line-numbers language-mysql"><code class="language-mysql">LOAD DATA INFILE 'one_piece.txt' INTO TABLE one_piece FIELDS TERMINATED BY '\t' IGNORE 1 LINES (no,name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>好的，那看看<code>secure_file_priv</code>是什么：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT @@secure_file_priv;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+--------------------+| @@secure_file_priv |+--------------------+| NULL               |+--------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果是NULL，这意味着不允许MySQL从文件系统里读取文件，当然是为了安全。</p><p>可以在启动mysql服务的时候设置这个值来允许mysql读取文件：</p><pre class="line-numbers language-shell"><code class="language-shell">/usr/local/mysql/bin/mysqld --user=_mysql --basedir=/usr/local/mysql \--datadir=/usr/local/mysql/data \--plugin-dir=/usr/local/mysql/lib/plugin \--log-error=/usr/local/mysql/data/mysqld.local.err \--pid-file=/usr/local/mysql/data/mysqld.local.pid \--secure-file-priv=/usr/local/mysql/data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样查看<code>secure_file_priv</code>就是设置的值了：</p><pre class="line-numbers language-shell"><code class="language-shell">+------------------------+| @@secure_file_priv     |+------------------------+| /usr/local/mysql/data/ |+------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后导入数据就可以了：</p><pre class="line-numbers language-shell"><code class="language-shell">Query OK, 10 rows affected (0.08 sec)Records: 10  Deleted: 0  Skipped: 0  Warnings: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>MySQL的默认设置是不允许这么操作的，这也可以理解。上面这么操作主要是为了演示从服务器里导入数据的过程，实际不建议这么操作，都是在客户端导入文件到MySQL服务器。</p><h3 id="4-在client上"><a href="#4-在client上" class="headerlink" title="4. 在client上"></a>4. 在client上</h3><p>由于一些原因我们不能在MySQL服务器上导入文件，这个时候需要在客户端上来导入文件了，这也是<code>LOCAL</code>选项的含义。从客户端导入数据到MySQL服务器的过程中涉及到一些步骤，如下图：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/load_data.png"><p>简单来说涉及到下面的几个步骤：</p><ol><li>客户端发送<code>COM_QUERY</code>到服务端来执行命令，在这个例子中就是<code>LOAD DATA LOCAL INFILE xxx</code>；</li><li>服务端发送一个特殊的响应<code>OxFB</code>和文件名给客户端，来告诉客户端发送的文件名；</li><li>客户端开始将文件内容发送给服务端；</li><li>客户端发送完文件内容后，发送一个空包来通知服务端文件发文完毕；</li><li>服务端开始执行命令，执行完毕后返回一个结果（OK或者错误）。</li></ol><p>可是为什么服务端要把发送的文件名给客户端呢？客户端不知道应该发送哪个文件吗？</p><p>是这样的，SQL语句分析起来比较麻烦，所以MySQL把SQL的解析都放在了服务端，服务端解析完了告诉客户端，这样客户端就不需要解析复杂的SQL语句了。</p><p>好的，开始使用<code>LOCAL</code>导入数据：</p><pre class="line-numbers language-mysql"><code class="language-mysql">LOAD DATA INFILE 'one_piece.txt' LOCALINTO TABLE one_piece FIELDS TERMINATED BY '\t' IGNORE 1 LINES (no,name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">ERROR 1148 (42000): The used command is not allowed with this MySQL version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>失败了，不过这个错误信息不好看到底是什么错误。其实这个错误是有关安全的一些设置。</p><h3 id="5-为了安全"><a href="#5-为了安全" class="headerlink" title="5. 为了安全"></a>5. 为了安全</h3><p>在手册上，有关于<code>LOAD DATA</code>的一些<a href="https://dev.mysql.com/doc/refman/8.0/en/load-data-local.html" target="_blank" rel="noopener">安全设置</a>：</p><blockquote><p>The <code>local_infile</code> system variable controls server-side <code>LOCAL</code> capability. Depending on the <code>local_infile</code> setting, the server refuses or permits local data loading by clients that have <code>LOCAL</code> enabled on the client side. By default, <code>local_infile</code> is disabled.</p></blockquote><p>这个是MySQL 8.0版本的说明，<code>local_infile</code>默认是不开启的，在之前的版本中都是默认开启的：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT @@local_infile;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+----------------+| @@local_infile |+----------------+|              0 |+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>了解了，设置<code>local_infile=1</code>试试：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SET GLOBAL local_infile=1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后重试导入数据。结果：</p><pre class="line-numbers language-shell"><code class="language-shell">ERROR 1148 (42000): The used command is not allowed with this MySQL version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>怎么还错了呢？</p><p>在上面客户端和服务端数据交换的过程中可以知道，这个过程涉及到客户端和服务端两个机器，上面的设置只是设置了服务端允许客户端发送文件，但是客户端也需要允许服务端来读取这个文件：</p><blockquote><p>For the <strong>mysql</strong> client, local data loading is disabled by default. To disable or enable it explicitly, use the <code>--local-infile=0</code> or <code>--local-infile[=1\]</code> option.</p></blockquote><p>也就是说，对于mysql客户端，启动的时候需要设置一下<code>--local-infile</code>：</p><pre class="line-numbers language-shell"><code class="language-shell">mysql -u root -p --local_infile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后再试一次。结果：</p><pre class="line-numbers language-shell"><code class="language-shell">Query OK, 10 rows affected (0.05 sec)Records: 10  Deleted: 0  Skipped: 0  Warnings: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>终于成功了。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Files to MySQL</title>
      <link href="/2019/12/17/files-to-mysql/"/>
      <url>/2019/12/17/files-to-mysql/</url>
      
        <content type="html"><![CDATA[<p><strong>问题</strong>：把一个本地的文件（比如.txt或.csv文件）导入到指定的一张MySQL表中。可以使用mysqlimport或者<code>LOAD DATA</code>命令来完成。这篇文章仅仅是简单介绍一下mysqlimport和<code>LOAD DATA</code>的简单用法。关于<code>LOAD DATA</code>的详细说明，参考<a href="http://deuterium.fun/2019/12/18/what-happens-when-using-load-data/">What Happens When Using LOAD DATA</a>。</p><h3 id="1-Prework：创建测试表和文件"><a href="#1-Prework：创建测试表和文件" class="headerlink" title="1. Prework：创建测试表和文件"></a>1. Prework：创建测试表和文件</h3><p>首先创建一个测试表：</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE one_piece (    `no`    INT,    `name`    VARCHAR(15));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后创建一个测试文件：</p><pre class="line-numbers language-shell"><code class="language-shell">cat one_piece.txtno      name100     luffy200     zoro300     nami400     usopp500     sanji600     chopper700     robin800     franky900     brook1000    jinbe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-使用mysqlimport导入文件"><a href="#2-使用mysqlimport导入文件" class="headerlink" title="2. 使用mysqlimport导入文件"></a>2. 使用mysqlimport导入文件</h3><p>使用下面的命令可以将上面创建的one_piece.txt的内容导入表中：</p><pre class="line-numbers language-shell"><code class="language-shell">mysqlimport --ignore-lines=1 \--fields-terminated-by='\t' \--local \-h host \-P port \-u username \-p db_name \/path/to/one_piece.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行后会让输入密码，之后就执行成功了。</p><p>可以查看一下：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM one_piece;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+------+---------+| no   | name    |+------+---------+|  100 | luffy   ||  200 | zoro    ||  300 | nami    ||  400 | usopp   ||  500 | sanji   ||  600 | chopper ||  700 | robin   ||  800 | franky  ||  900 | brook   || 1000 | jinbe   |+------+---------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，导入的文件名需要和对应的表名一样，比如上面的one_piece.txt和对应的表名one_piece。不然会找不到表名。</p><h3 id="3-导入多个文件到多张表中"><a href="#3-导入多个文件到多张表中" class="headerlink" title="3. 导入多个文件到多张表中"></a>3. 导入多个文件到多张表中</h3><p>使用上面的命令我们可以将多个文件导入多张表中：</p><pre class="line-numbers language-shell"><code class="language-shell">mysqlimport --ignore-lines=1 \--fields-terminated-by='\t' \--local \-h host \-P port \-u username \-p db_name \/path/to/one_piece.txt/path/to/steins_gate.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-使用LOAD-DATA导入文件"><a href="#4-使用LOAD-DATA导入文件" class="headerlink" title="4. 使用LOAD DATA导入文件"></a>4. 使用<code>LOAD DATA</code>导入文件</h3><p>mysqlimport其实是对<code>LOAD DATA</code>的一层封装，这样我们就可以使用<code>LOAD DATA</code>导入文件：</p><pre class="line-numbers language-mysql"><code class="language-mysql">LOAD DATA LOCAL INFILE '/path/to/one_piece.txt' INTO TABLE one_piece FIELDS TERMINATED BY '\t' LINES TERMINATED BY '\n' IGNORE 1 LINES (no,name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果是一样的。</p><h3 id="4-mysqlimport常用选项"><a href="#4-mysqlimport常用选项" class="headerlink" title="4. mysqlimport常用选项"></a>4. mysqlimport常用选项</h3><p>mysqlimport的参数比较多，接下来看看一些常用的参数：</p><p><code>--ignore-lines</code>：用来标识忽略的行数，比如如果文件有表头的话，可以忽略这一行；</p><p><code>--fields-terminated-by</code>：用来标识字段分隔符，常用的有<code>\t</code>和<code>,</code>；</p><p><code>--local</code>：表示读取本地文件，如果不加的话就会出错；</p><p><code>--delete</code>：在导入之前先删除所有的数据；</p><p><code>-h</code>和<code>-P</code>：表示MySQL服务器的地址，不加的话就是本地的MySQL服务器；</p><p><code>-p</code>：使用密码；</p><p>后面的<code>test</code>就是对应的数据库名。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Types in MySQL</title>
      <link href="/2019/12/16/data-types-in-mysql/"/>
      <url>/2019/12/16/data-types-in-mysql/</url>
      
        <content type="html"><![CDATA[<h3 id="1-开始"><a href="#1-开始" class="headerlink" title="1. 开始"></a>1. 开始</h3><p>为了能更好地理解与使用MySQL，根据MySQL文档花点时间整理了一下MySQL的数据类型。MySQL中一共有五大类数据类型，如下图：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/mysql_datatypes.PNG"><p>这篇文章只对其中的数字类型、字符串类型和时间类型进行总结。</p><p>在这些数据类型的使用中，有几个需要提前知道的地方：</p><ol><li>在整数中，<em><code>M</code></em>代表最大的展示宽度；而在浮点数和定点数中，<em><code>M</code></em>代表可以存储的总位数（也就是精度,precision）；对于字符串类型，<em><code>M</code></em>代表所能存储的最长字符数。不同类型的<em><code>M</code></em>也是不一样的；</li><li><em><code>D</code></em>适用于浮点数和定点数，表示小数点后面的位数。<em><code>D</code></em>最大值是30，但是不能大于<em><code>M-2</code></em>；</li><li><em><code>fsp</code></em>适用于时间类型，表示小于秒的精度。这个值在0和6之间，也就是说MySQL的时间可以精确到微秒级；</li><li>类型定义中的<code>[</code>和<code>]</code>表示可选项。</li></ol><p>不管什么数据类型，计算机的存储都是一样的，不同在于对于底层存储数据的解释不同。</p><p>接下来，详细看看各种数据类型是怎么存储的，以及MySQL是怎么解释的。</p><h3 id="2-Numeric类型"><a href="#2-Numeric类型" class="headerlink" title="2. Numeric类型"></a>2. Numeric类型</h3><p>数字类型还可以细分成如下的几种类型：整数、实数和位数据类型。</p><p>数字类型支持有符号和无符号属性，分别是<code>UNSIGNED</code>和<code>SIGNED</code>。其中<code>SIGNED</code>可以不写在类型定义中，默认就是有符号的。</p><h4 id="2-1-Integer类型"><a href="#2-1-Integer类型" class="headerlink" title="2.1 Integer类型"></a>2.1 Integer类型</h4><p>整数类型根据所占空间大小可以分为五种：<code>TINYINT</code>, <code>SMALLINT</code>, <code>MEDIUMINT</code>, <code>INT</code>, <code>BIGINT</code>。其中<code>INT</code>也是<code>INTEGER</code>。</p><p>按照有无符号又可以分为两种：<code>SIGNED</code>和<code>UNSIGNED</code>，其中默认是有符号的，只需要在指定无符号时使用<code>UNSIGNED</code>。</p><p>整数类型基本情况如下表：</p><table><thead><tr><th>Type</th><th>Bytes</th><th>Min Signed</th><th>Max Signed</th><th>Min Unsigned</th><th>Max Unsigned</th></tr></thead><tbody><tr><td><code>TINYINT</code></td><td>1</td><td>-128</td><td>127</td><td>0</td><td>255</td></tr><tr><td><code>SMALLINT</code></td><td>2</td><td>-32768</td><td>32767</td><td>0</td><td>65535</td></tr><tr><td><code>MEDIUMINT</code></td><td>3</td><td>-8388608</td><td>8388607</td><td>0</td><td>16777215</td></tr><tr><td><code>INT</code></td><td>4</td><td>-2147483648</td><td>2147483647</td><td>0</td><td>4294967295</td></tr><tr><td><code>BIGINT</code></td><td>8</td><td>-2^63</td><td>2^63-1</td><td>0</td><td>2^64-1</td></tr></tbody></table><p>有符号与无符号类型使用相同的存储空间，也具有相同的性能，可以根据需要来选择。不过如果选择了无符号类型，当插入的数据是负数时，会保存为0，需要注意。</p><p>对于整数的<em><code>M</code></em>，比如<code>INT(11)</code>，对于大多数应用这是没有意义的，因为这不会限制值的合法范围，只是规定了MySQL的一些交互工具（比如MySQL命令行客户端）用来显示字符的个数。对于存储和计算来说，<code>INT(1)</code>和<code>INT(11)</code>是相同的。</p><p>还有一个类型，<code>BOOL</code>(也可以是<code>BOOLEAN</code>)，这个类型和<code>TINYINT(1)</code>一样，0为<code>false</code>，非零为<code>true</code>。但是在MySQL中，<code>TRUE</code>就是1<code>FALSE</code>就是0：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT IF(2 = TRUE, 'true', 'false');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果是<code>false</code>。</p><h4 id="2-2-实数类型"><a href="#2-2-实数类型" class="headerlink" title="2.2 实数类型"></a>2.2 实数类型</h4><p>MySQL中除了整数还可以储存实数。对于实数，MySQL既支持精确类型（定点），也支持不精确类型（浮点）。</p><p>对于精确实数类型，MySQL中有<code>DECIMAL</code>，也可以叫做<code>DEC</code>和<code>NUMERIC</code>。</p><p><code>DECIMAL</code>类型定义如下：</p><pre class="line-numbers language-mysql"><code class="language-mysql">salary DECIMAL(5,2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中5就是精度2就是小数点后面的位数。精度也就是数字的总位数，这样<code>salary</code>的范围就是<code>-999.99</code>到<code>999.99</code>。</p><p>对于不精确类型，MySQL有<code>FLOAT</code>和<code>DOUBLE</code>类型，其中<code>FLOAT</code>使用4个字节（也有可能使用8个字节），而<code>DOUBLE</code>使用8个字节进行存储。</p><p>对于<code>FLOAT</code>，还可以这样来指定类型：<code>FLOAT(p)</code>，可以用来指定存储空间大小，具体的大小和<code>p</code>有关。</p><p>浮点类型通常在相同精度时比<code>DECIMAL</code>所需空间少，所以应该尽量在需要精确计算时使用<code>DECIMAL</code>。</p><p>下面列出了不同类型所占的空间：</p><table><thead><tr><th>Data Type</th><th>Storage Required</th></tr></thead><tbody><tr><td><code>FLOAT(p)</code></td><td><code>0&lt;=p&lt;=24</code>时4个字节，<code>25&lt;=p&lt;=53</code>时8个字节</td></tr><tr><td><code>FLOAT</code></td><td>4个字节</td></tr><tr><td><code>DOUBLE</code></td><td>8个字节</td></tr></tbody></table><p>对于<code>DECIMAL</code>情况有些复杂，MySQL将数字打包成二进制字符串来存储，每9个数字使用4个字节，并且对于整数部分和小数部分分开计算。计算规则如下：</p><ol><li>每9个数字使用4个字节；</li><li>不够9个数字的通过下面的表格确定；</li><li>将整数部分和小数部分所占空间相加即是整体空间。</li></ol><p>不够9个数字的部分所占空间：</p><table><thead><tr><th>Leftover Digits</th><th>Number of Bytes</th></tr></thead><tbody><tr><td>0</td><td>0</td></tr><tr><td>1-2</td><td>1</td></tr><tr><td>3-4</td><td>2</td></tr><tr><td>5-6</td><td>3</td></tr><tr><td>7-8</td><td>4</td></tr></tbody></table><p>比如，对于123.123，整数部分3个数字不够9个，查表使用2个字节；同理小数部分也使用2个字节，一共4个字节。</p><p>对于12345.1，整数部分使用3个字节，小数部分使用1个字节，一共4个字节。</p><h4 id="2-3-位数据类型"><a href="#2-3-位数据类型" class="headerlink" title="2.3 位数据类型"></a>2.3 位数据类型</h4><p><code>BIT</code>类型可以存储比特位，<code>BIT(M)</code>可以存储<code>M</code>个比特位，其中<code>M</code>可以取1到64之间的任意值。。</p><p>对于<code>BIT</code>类型，不同的存储引擎存储方式不同。MyISAM会把所有的比特位打包存储，所以19个单独的<code>BIT</code>列只需要19位来存储，所以一共3个字节就可以了；但是对于InnoDB来说，会为每个<code>BIT</code>列使用一个足够小的最小整数类型来存储，所以不能节省空间。</p><p>还有一点需要注意的是，MySQL是使用字符串来存储的，而不是ASCII码的”0”或”1”。但是在数字上下文的场景使用时，结果是把位字符串转换成了数字。比如，如果存储一个<code>b&#39;00111001&#39;</code>（二进制值是57）到<code>BIT(8)</code>中并检索使用，得到的内容是字符码为57的字符串，也就是得到了字符”9”，但是在数字上下文中，得到的是57：</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE bittest(a bit(8));INSERT INTO bittest VALUES (b'00111001');SELECT a, a+0 FROM bittest;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+------+------+| a    | a+0  |+------+------+| 9    |   57 |+------+------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个建议就是，尽可能不使用<code>BIT</code>类型。</p><h3 id="3-String类型"><a href="#3-String类型" class="headerlink" title="3. String类型"></a>3. String类型</h3><h4 id="3-1-VARCHAR和CHAR类型"><a href="#3-1-VARCHAR和CHAR类型" class="headerlink" title="3.1 VARCHAR和CHAR类型"></a>3.1 <code>VARCHAR</code>和<code>CHAR</code>类型</h4><p><code>VARCHAR</code>和<code>CHAR</code>是两种主要的类型，虽然相似，但是在好多方面各不相同。而且，两种类型在磁盘和内存中的存储方式也和存储引擎有关，这里的描述主要是InnoDB和MyISAM。</p><p><strong>区别一：<code>VARCHAR</code>是变长的，<code>CHAR</code>是定长的。</strong></p><p><code>VARDCHAR</code>根据存储的内容使用不同的空间，最长长度定义时指定；而<code>CHAR</code>使用定义时指定的空间。如果存储的值超过了指定的空间，两种类型都会截断超过的部分。</p><p><strong>区别二：两种类型所能存储的最长字符串不同。</strong></p><p><code>VARCHAR</code>可以最多存储65535个字符；而<code>CHAR</code>最多能存储255个字符。最长字符都可以在定义时指定。</p><p><strong>区别三：填充方式</strong></p><p>由于<code>CHAR</code>是定长的，如果存储的值不够指定长度，会在末尾填充空格；而<code>VARCHAR</code>不会填充空格。</p><p><strong>区别四：空间占用</strong></p><p><code>CHAR</code>是定长的，所以指定的长度就是真正需要的空间，不过还和使用的字符集有关。如果使用latin1字符集，那么<code>CHAR(4)</code>就使用4个字节存储。</p><p><code>VARCHAR</code>是变长的，所以需要额外记录字符串的长度。对于字符数小于等于255，额外需要一个字节存储长度；字符数超过255，需要两个字节。</p><p><strong>区别五：末尾空格</strong></p><p>在区别三种提到了<code>CHAR</code>会在后面使用空格填充，但是如果数据本身后面就有空格的话，两个类型处理方式就不同了。<code>CHAR</code>当然会保存空格，但是在检索时会把空格去掉；而<code>VARCHAR</code>不会：存入什么，得到什么。</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE vc (v VARCHAR(4), c CHAR(4));INSERT INTO vc VALUES ('ab  ', 'ab  ');SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+---------------------+---------------------+| CONCAT('(', v, ')') | CONCAT('(', c, ')') |+---------------------+---------------------+| (ab  )              | (ab)                |+---------------------+---------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面的表格演示了两者的区别：</p><table><thead><tr><th>Value</th><th><code>CHAR(4)</code></th><th>Storage Required</th><th><code>VARCHAR(4)</code></th><th>Storage Required</th></tr></thead><tbody><tr><td><code>&#39;&#39;</code></td><td><code>&#39;    &#39;</code></td><td>4 bytes</td><td><code>&#39;&#39;</code></td><td>1 byte</td></tr><tr><td><code>&#39;ab&#39;</code></td><td><code>&#39;ab  &#39;</code></td><td>4 bytes</td><td><code>&#39;ab&#39;</code></td><td>3 bytes</td></tr><tr><td><code>abcd</code></td><td><code>&#39;abcd&#39;</code></td><td>4 bytes</td><td><code>&#39;abcd&#39;</code></td><td>5 bytes</td></tr><tr><td><code>abcdefgh</code></td><td><code>&#39;abcd&#39;</code></td><td>4 bytes</td><td><code>&#39;abcd&#39;</code></td><td>5 bytes</td></tr></tbody></table><p><code>VARCHAR</code>可以节省空间，不过由于是变长的，在更新时可能会比原来的长，这就需要额外的操作。如果一个行占用的空间增长，并且在页中没有更多的空间的话，不同的存储引擎处理方式不同。MyISAM会将行拆分成不同的片段存储；InnoDB则需要分裂页来使行可以放进页内。</p><p><code>CHAR</code>适合存储很短的字符串，或者所有值都接近同一个长度，比如MD5值。对于经常变更的数据，<code>CHAR</code>也比<code>VARCHAR</code>好，因为不会产品碎片。</p><h4 id="3-2-VARBINARY和BINARY类型"><a href="#3-2-VARBINARY和BINARY类型" class="headerlink" title="3.2 VARBINARY和BINARY类型"></a>3.2 <code>VARBINARY</code>和<code>BINARY</code>类型</h4><p><code>VARBINARY</code>和<code>BINARY</code>两种类型和<code>VARCHAR</code>和<code>CHAR</code>类似，不同在于，前两者储存的是二进制字符串（二进制字符码），而后两者存储的是常规字符串（字符）。</p><p>这样有一个问题就是，虽然前两者的长度限制和后两者的一样，但是前两者计算的是字节数，而后两者计算的字符数，这在有些单个字符使用多个字节的字符集中会有所不同。</p><p>还有一点需要注意，<code>BINARY</code>会在数据后面填充<code>\0</code>而不是空格，在检索的时候也不会删除后面的<code>\0</code>。</p><p>二进制字符的优势在于比较。MySQL比较<code>BINARY</code>字符串时，每次按一个字节，并且根据该字节的数值比较。这会比字符比较更快。</p><h4 id="3-3-BLOB和TEXT类型"><a href="#3-3-BLOB和TEXT类型" class="headerlink" title="3.3 BLOB和TEXT类型"></a>3.3 <code>BLOB</code>和<code>TEXT</code>类型</h4><p><code>BLOB</code>和<code>TEXT</code>都是为了存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。</p><p>其实它们也有各自的类型族：<code>TINYBLOB</code>、<code>BLOB</code>、<code>MEDIUMBLOB</code>、<code>LONGBLOB</code>和<code>TINYTEXT</code>、<code>TEXT</code>、<code>MEDIUMTEXT</code>和<code>LONGTEXT</code>。</p><p>当<code>BLOG</code>和<code>TEXT</code>过大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1-4个字节来存储一个指针，指向外部存储区域的实际值。</p><p>MySQL对于<code>BLOB</code>和<code>TEXT</code>列进行排序与其它类型不同：只对最前面的<code>max_sort_length</code>字节而不是整个字符串进行排序。</p><p>MySQL不能将<code>BLOB</code>和<code>TEXT</code>列全部长度的字符串进行索引，也不能使用这些索引消除排序。</p><h4 id="3-4-ENUM类型"><a href="#3-4-ENUM类型" class="headerlink" title="3.4 ENUM类型"></a>3.4 <code>ENUM</code>类型</h4><p>有时候可以使用枚举类型代替常用的字符串类型。枚举类型可以把一些不重复的字符串存储成一个预定义的集合。枚举类型使用一个或两个字节来编码枚举值，最多可以用65535个不同的枚举值。</p><p>创建一个枚举值：</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE shirts (    name VARCHAR(40),    size ENUM('x-small', 'small', 'medium', 'large', 'x-large'));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这也是使用枚举类型的一个缺点，当需要增加枚举值时，只能使用<code>ALTER TABLE</code>：</p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE shirts MODIFY COLUMN size ENUM('x-small', 'small', 'medium', 'large', 'x-large', 'xx-large');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>存储枚举值时使用的是数字而不是对应的字符串：</p><pre class="line-numbers language-mysql"><code class="language-mysql">INSERT INTO shirts (name, size) VALUES ('dress shirt','large'), ('t-shirt','medium'),  ('polo shirt','small');SELECT * FROM shirts;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+-------------+--------+| name        | size   |+-------------+--------+| dress shirt | large  || t-shirt     | medium || polo shirt  | small  |+-------------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过在数字上下文中，可以看到真实存储的值：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT size+0 FROM shirts;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-mysql"><code class="language-mysql">+--------+| size+0 |+--------+|      4 ||      3 ||      2 |+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此：<strong>千万不要使用数字作为枚举值</strong>。</p><p>还有一点，枚举字段是根据存储的数字来排序的而不是定义的字符串：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT size FROM shirts ORDER BY size;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+--------+| size   |+--------+| small  || medium || large  |+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-5-SET类型"><a href="#3-5-SET类型" class="headerlink" title="3.5 SET类型"></a>3.5 <code>SET</code>类型</h4><p>一位可以存储一个只有<code>true/false</code>值，如果有很多<code>true/false</code>值的话，可以使用<code>SET</code>类型，它在MySQL中打包存储，可以有效节省空间，最多可以存储64个<code>true/false</code>值，只需要8个字节。</p><p>和<code>ENUM</code>一样，一个主要的缺点是添加新的定义时需要使用<code>ALTER TABLE</code>。而且，也不能在<code>SET</code>上使用索引。</p><p>作为一个替代方案，可以使用一个整数来包装一系列的位，然后再应用中操作这个整数。不过是使用这个方法还是使用<code>SET</code>依据每个人的偏好。</p><h3 id="4-Date-and-Time类型"><a href="#4-Date-and-Time类型" class="headerlink" title="4. Date and Time类型"></a>4. Date and Time类型</h3><p>MySQL中的时间和日期类型有如下几种：<code>DATE</code>、<code>TIME</code>、<code>DATETIME</code>、<code>TIMESTAMP</code>和<code>YEAR</code>。每种类型都有自己对应的零值和取值范围：</p><table><thead><tr><th>Data Type</th><th>“Zero” Value</th><th>Time Range</th></tr></thead><tbody><tr><td><code>Date</code></td><td><code>&#39;0000-00-00&#39;</code></td><td><code>&#39;1000-01-01&#39;</code> 到<code>&#39;9999-12-31&#39;</code></td></tr><tr><td><code>TIME</code></td><td><code>&#39;00:00:00&#39;</code></td><td><code>&#39;-838：59：59&#39;</code>到<code>&#39;838:59:59&#39;</code></td></tr><tr><td><code>DATETIME</code></td><td><code>&#39;0000-00-00 00:00:00&#39;</code></td><td><code>&#39;1000-01-01 00:00:00&#39;</code>到<code>&#39;9999-12-31 23:59:59&#39;</code></td></tr><tr><td><code>TIMESTAMP</code></td><td><code>&#39;0000-00-00 00:00:00&#39;</code></td><td><code>&#39;1970-01-01 00:00:01&#39;</code>到<code>&#39;2038-01-19 03:14:07&#39;</code></td></tr><tr><td><code>YEAR</code></td><td><code>0000</code></td><td><code>&#39;1901&#39;</code>到<code>&#39;2155&#39;</code>或<code>&#39;0&#39;</code>到<code>&#39;99&#39;</code></td></tr></tbody></table><h4 id="4-1-DATE、DATETIME和TIMESTAMP类型"><a href="#4-1-DATE、DATETIME和TIMESTAMP类型" class="headerlink" title="4.1 DATE、DATETIME和TIMESTAMP类型"></a>4.1 <code>DATE</code>、<code>DATETIME</code>和<code>TIMESTAMP</code>类型</h4><p>这三种类型都含有年月日的信息，但是三种类型又有一些不同。</p><p><code>DATE</code>类型只有日期而没有时间；<code>DATETIME</code>和<code>TIMESTAMP</code>除了日期还有具体的时间。</p><p><code>DATETIME</code>和<code>TIMESTAMP</code>的一个区别是两者的范围不同。<code>DATETIME</code>将日期存储为<code>YYYYMMDDHHMMSS</code>格式的整数中，使用8个字节；而<code>TIMESTAMP</code>使用4个字节存储从1970年1月1日以来的秒数，所以范围小了很多。</p><p>另外一个区别就是<code>TIMESTAMP</code>依赖时区而<code>DATETIME</code>不包含时区。MySQL服务器、操作系统以及客户端连接都可以设置时区。</p><p><code>TIMESTAMP</code>也有一些<code>DATETIME</code>没有的属性，比如可以设置插入和更新时<code>TIMESTAMP</code>列的行为。</p><p>在MySQL 5.6之后<code>DATETIME</code>和<code>TIMESTAMP</code>增加了时间的精确度，在原来秒的基础上精确度增加到了微秒级别，不过需要在定义中指定精确度，比如<code>DATETIME(6)</code>，括号中的数字就是时间的精确度，取值范围是0-6。</p><p>如果指定了额外的精确度的话，MySQL需要额外的空间来存储，所需的空间和精度有关：</p><table><thead><tr><th>fsp</th><th>Storage Required</th></tr></thead><tbody><tr><td>0</td><td>0 bytes</td></tr><tr><td>1, 2</td><td>1 byte</td></tr><tr><td>3, 4</td><td>2 bytes</td></tr><tr><td>5, 6</td><td>3 bytes</td></tr></tbody></table><h4 id="4-2-TIME类型"><a href="#4-2-TIME类型" class="headerlink" title="4.2 TIME类型"></a>4.2 <code>TIME</code>类型</h4><p><code>TIME</code>类型的存储范围并不是感觉上的<code>&#39;00:00:00&#39;</code>到<code>&#39;23:59:59&#39;</code>，而是<code>&#39;-838：59：59&#39;</code>到<code>&#39;838:59:59&#39;</code>，这样就可以表示是两个事件之间的时间差了。</p><p>MySQL中<code>TIME</code>的格式是<code>hh:mm:ss</code>，使用3个字节来存储。</p><p>在对<code>TIME</code>列进行赋值时，需要注意的是，<code>11:12</code>的结果是<code>&#39;11:12:00&#39;</code>，而不是<code>00:11:12</code>；<code>&#39;1112&#39;</code>的结果是<code>&#39;00:11:12&#39;</code>；<code>&#39;12&#39;</code>的结果是<code>&#39;00:00:12&#39;</code>。不过建议不要这么做。</p><p>同样，<code>TIME</code>类型在MySQL 5.6 版本之后添加了微秒级的精度，只需要在定义的时候指定精度即可，所需的额外空间就是上面的表格。</p><h4 id="4-3-YEAR类型"><a href="#4-3-YEAR类型" class="headerlink" title="4.3 YEAR类型"></a>4.3 <code>YEAR</code>类型</h4><p><code>YEAR</code>类型是使用1个字节来存储的数据类型，用来表示年份。在MySQL中，有两种：<code>YEAR(4)</code>和<code>YEAR(2)</code>。</p><p><code>YEAR(4)</code>可以表示的范围是<code>&#39;1901&#39;</code>到<code>&#39;2155&#39;</code>；</p><p><code>YEAR(2)</code>可以的取值范围是<code>&#39;0&#39;</code>到<code>&#39;99&#39;</code>，可以表示的范围是<code>&#39;1970&#39;</code>到<code>&#39;2069&#39;</code>。</p><p>由于范围小，尽量不要使用<code>YEAR(2)</code>。</p><h3 id="5-选择优化的数据类型"><a href="#5-选择优化的数据类型" class="headerlink" title="5. 选择优化的数据类型"></a>5. 选择优化的数据类型</h3><p>MySQL支持的数据类型非常多，选择正确的类型对于性能来说也很重要。下面是选择数据类型时的一些原则。</p><ol><li>一般情况下，应该尽量使用可以正确存储数据的最小数据类型；</li><li>使用简单的数据类型。比如，使用MySQL的内建类型来存储时间而不是字符串，使用整型次数IP地址而不是字符串；</li><li>通常情况下最好指定列为<code>NOT NULL</code>，除非真的需要存储<code>NULL</code>值；</li><li>尽量使用相同的数据类型来存储相似或相关的值，尤其是需要在关联条件中使用的列；</li><li>注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存；</li><li>避免使用MySQL已经遗弃的特性，比如指定浮点数的精度，或者整数的显示宽度；</li><li>小心使用<code>ENUM</code>和<code>SET</code>，不要滥用；</li><li>谨慎使用<code>BIT</code>，对于大部分应用，最好避免使用这个类型。</li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> data_type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File to Redis</title>
      <link href="/2019/12/10/file-to-redis/"/>
      <url>/2019/12/10/file-to-redis/</url>
      
        <content type="html"><![CDATA[<p>问题是这样的，现在需要把一个文件里的所有数据上传到redis的set中，文件里存储的就是ID，每行一个：</p><pre class="line-numbers language-shell"><code class="language-shell">head id.list10000100011000210003100041000510006100071000810009<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了将这一万条记录添加到redis中的某个set中，需要写一个脚本来执行这个操作。</p><p>主要的思路就是构造一个如下命令组成的一堆命令：</p><pre class="line-numbers language-shell"><code class="language-shell">sadd setname 10000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后使用<code>redis-cli</code>将命令通过pipeline的形式发送到服务器。流程如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Redis/file2redis.PNG"><p>下面就是生成命令的shell脚本：</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bashINFILE=$1SETKEY=$2TOFILE=${SETKEY}'.data'echo $TOFILErm $TOFILE >/dev/null 2>&1while IFS= read -r line; do    echo "sadd $SETKEY $line" >> $TOFILEdone < $INFILEunix2dos $TOFILEcat $TOFILE | ./redis-cli --pipe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在脚本的最后，通过下面的命令将所有的redis命令发送到了redis服务器中：</p><pre class="line-numbers language-shell"><code class="language-shell">cat $TOFILE | ./redis-cli --pipe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以在redis中查看是否正确。</p><p>对于将数据导入redis的其它格式中，也是类似的过程，只需要把循环中添加的命令改成需要的形式就可以了。</p><p>Done</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Character Sets and Collations in MySQL</title>
      <link href="/2019/12/08/character-sets-and-collations-in-mysql/"/>
      <url>/2019/12/08/character-sets-and-collations-in-mysql/</url>
      
        <content type="html"><![CDATA[<p>最近遇到一个关于MySQL字符乱码的问题，比较好解决，但是为了更好地理解MySQL中的字符系统，参考MySQL的文档整理一下关于MySQL中字符集合字符序的问题。</p><h3 id="1-什么是字符集和字符序"><a href="#1-什么是字符集和字符序" class="headerlink" title="1. 什么是字符集和字符序"></a>1. 什么是字符集和字符序</h3><p>MySQL是存储数据的数据库，既然是存储数据的，那么数据就需要一个编码的规则，因为计算机对于所有的数据都是通过二进制编码的方式存储的。字符集（Character Sets），就是字符到二进制编码映射的集合。由于不同的语言所包含的字符不同，所以为了支持不同的语言，MySQL定义了许许多多不同的字符集。</p><p>举一个简单的例子，假如我们有一种语言只有四个字符：<code>A, B, a, b</code>。</p><p>我们规定了这四个字符到二进制编码的规则：</p><table><thead><tr><th>Symbol</th><th>Encoding</th></tr></thead><tbody><tr><td><code>A</code></td><td>0</td></tr><tr><td><code>B</code></td><td>1</td></tr><tr><td><code>a</code></td><td>2</td></tr><tr><td><code>b</code></td><td>3</td></tr></tbody></table><p>在这里，<code>A</code>就是一个字符，而数字0就是字符<code>A</code>的编码，这四个字符和编码组合在一起就是字符集。</p><p>接下来看看什么是字符序（Collations）。</p><p>对于上面的字符集，我们需要有一个比较的规则。比如，我们想比较<code>A</code>和<code>B</code>，当然结果有三种：等于、小于或大于。但我们熟悉的还是<code>A&lt;B</code>。一种简单的方式就是比较他们的编码数字。因为<code>0&lt;1</code>，所以对应的字符<code>A&lt;B</code>。</p><p>这样就构成了一条字符比较的规则。这样的一条规则就可以构成一个字符序。</p><p>进一步，如果我们规定大写字母和对应的小写字母相等呢？这样就又多了一条规则：</p><blockquote><p><code>a</code>=<code>A</code>, <code>b</code>=<code>B</code></p></blockquote><p>这样，两条比较的规则就又构成了一个字符序。</p><p>通过这个简单的例子，我们可以知道：</p><ol><li>字符集就是字符到二进制编码的映射集合；</li><li>字符序是比较字符集的规则集合；</li><li>一个字符集可能有多个字符序。</li></ol><p>在MySQL中，定义了许多字符集合字符序。这些字符集合字符序可以帮助我们处理很多字符相关的问题。</p><h3 id="2-MySQL中的字符集合字符序"><a href="#2-MySQL中的字符集合字符序" class="headerlink" title="2. MySQL中的字符集合字符序"></a>2. MySQL中的字符集合字符序</h3><p>在MySQL中，我们可以使用如下的语句来查看字符集：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SHOW CHARACTER SET;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这会列出所有的字符集。如果想筛选的话，可以加上<code>LIKE</code>条件：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SHOW CHARATER SET LIKE 'utf%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下：</p><pre class="line-numbers language-shell"><code class="language-shell">+---------+------------------+--------------------+--------+| Charset | Description      | Default collation  | Maxlen |+---------+------------------+--------------------+--------+| utf16   | UTF-16 Unicode   | utf16_general_ci   |      4 || utf16le | UTF-16LE Unicode | utf16le_general_ci |      4 || utf32   | UTF-32 Unicode   | utf32_general_ci   |      4 || utf8    | UTF-8 Unicode    | utf8_general_ci    |      3 || utf8mb4 | UTF-8 Unicode    | utf8mb4_0900_ai_ci |      4 |+---------+------------------+--------------------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果返回了字符集的名称、描述、默认字符序以及单个字符最大长度等信息。</p><p>每一个字符集都有一个默认的字符序，有的字符集有多个字符序，可以通过下面的语句查看一个字符集的字符序：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SHOW COLLATION WHERE Charset = 'utf8mb4';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回的结果会列出所有的字符序以及相关的信息，这里就不展示了。</p><p>字符序有下面的特点：</p><ol><li>两个不同的字符集不会有相同的字符序。也就是每个字符集都有自己单独的字符序小弟，大家不会有交集；</li><li>每一个字符集都有一个默认的字符序；</li><li>字符序的名字是以对应的字符集名称为前缀的。</li></ol><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/characterset.PNG"><h3 id="3-在MySQL中使用字符集"><a href="#3-在MySQL中使用字符集" class="headerlink" title="3. 在MySQL中使用字符集"></a>3. 在MySQL中使用字符集</h3><p>MySQL中有很多可以控制字符集的选项，这些选项过于复杂很容易混淆。不过记住一点：</p><blockquote><p>只有基于字符的值才真正的“有”字符集的概念。</p></blockquote><p>对于其他类型的值，字符集只是一个设置，用来指定用哪一种字符进行比较或操作。基于字符的值能存放在某列中、查询的字符中、表达式的计算结果中或者某个用户变量中，等等。</p><p>MySQL中字符集的设置可以分为两类：创建对象时的默认值、在服务器和客户端通信时的设置。</p><h4 id="3-1-创建对象时的默认设置"><a href="#3-1-创建对象时的默认设置" class="headerlink" title="3.1 创建对象时的默认设置"></a>3.1 创建对象时的默认设置</h4><p>在MySQL中，从上到下一共有四层字符集的设置，分别是服务器（Server）、数据库（Database）、表（Table）和列（Column），在每一层都可以指定一个默认的字符集：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/charset_layers.PNG"><p>其中，服务器和数据库的字符集设置有对应的参数：<code>character_set_server</code>和<code>character_set_database</code>，表和列的字符集设置在对应的DDL语句中。</p><p>由于真正存放数据的是列，所以更高层次的字符集设置仅仅是指定一个默认值，如果在创建列时没有知道字符集，就会从下到上寻找设置的字符集。如果指定了一个字符集，那么上面所有层次的设置都没有效果了。</p><p>在MySQL 5.5、5.6和5.7中，默认的字符集是latin1，在最新的MySQL 8中，默认的字符集是utf8。</p><h4 id="3-2-服务器和客户端通信时的设置"><a href="#3-2-服务器和客户端通信时的设置" class="headerlink" title="3.2 服务器和客户端通信时的设置"></a>3.2 服务器和客户端通信时的设置</h4><p>当服务器和客户端进行通信时，可能各自使用不同的字符集。这时，服务器需要进行字符的转换工作。这涉及到MySQL中的三个参数：<code>character_set_client</code>、<code>character_set_connection</code>和<code>character_set_results</code>。</p><p>这三个参数的影响效果如下图所示：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/charset_communacate.PNG"><p>这里服务器进行了两次翻译过程：</p><ol><li>SQL语句从客户端离开时的字符集是<code>character_set_client</code>；</li><li>SQL语句进入服务器后服务器转换成<code>character_set_connection</code>；</li><li>服务器处理完SQL语句后，将结果的字符集设置成了<code>character_set_results</code>。</li></ol><p>根据需要，可以使用<code>SET NAMES</code>或者<code>SET CHARACTER SET</code>语句来改变上面的设置：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SET NAMES 'utf8';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，会将<code>character_set_client</code>、<code>character_set_connection</code>和<code>character_set_results</code>都设置成utf8。</p><p>不过在服务器上使用这个命令只能改变服务器端的设置，客户端程序也需要设置正确的字符集才能避免出现问题。</p><h4 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h4><p>可以通过<code>SHOW VARIABLES LIKE &#39;character%&#39;</code>命令来查看这些参数的值：</p><pre class="line-numbers language-shell"><code class="language-shell">+--------------------------+-----------------------------------------------------------+| Variable_name            | Value                                                     |+--------------------------+-----------------------------------------------------------+| character_set_client     | latin1                                                    || character_set_connection | latin1                                                    || character_set_database   | utf8mb4                                                   || character_set_filesystem | binary                                                    || character_set_results    | latin1                                                    || character_set_server     | utf8mb4                                                   || character_set_system     | utf8                                                      || character_sets_dir       | /usr/local/mysql-8.0.13-macos10.14-x86_64/share/charsets/ |+--------------------------+-----------------------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-字符集的选择"><a href="#4-字符集的选择" class="headerlink" title="4. 字符集的选择"></a>4. 字符集的选择</h3><p>使用不同的字符集会带来更多的CPU操作，可能也会消耗更多的内存和磁盘空间。因此，为了方便，最好先为服务器（或者数据库）设置一个合理的字符集，然后根据不同的情况让某些列选择合适的字符集，</p><p>如果统一使用utf8字符集，整个世界都清净了。这也是很常见的一种做法。不过有的时候并不需要使用utf8，使用utf8之后会增加磁盘空间的消耗。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> charset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What is physics</title>
      <link href="/2019/12/07/what-is-physics/"/>
      <url>/2019/12/07/what-is-physics/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是阅读《费恩曼物理学讲义 第一卷 新千年版》第1-3章的阅读笔记。</p></blockquote><h3 id="1-从一片沙滩开始"><a href="#1-从一片沙滩开始" class="headerlink" title="1. 从一片沙滩开始"></a>1. 从一片沙滩开始</h3><p>我们生活在一个多姿多彩的世界中。</p><p>想象一下，去年的某一天，我们正在一个美丽的海边沙滩享受着没有工作烦恼的美妙时光。你躺在柔软细密的沙滩上，不远处就是蔚蓝的大海，海水波光粼粼，海风吹拂，你感受到了凉爽，海水在海风的吹拂下翻起阵阵海浪；海水拍打在海中岩石上，激起浪花与泡沫；海水中生活着许许多多不同的生物，也许海绵宝宝和派大星正在不远处的海底捉水母；太阳挂在天上，持续不断发着光；望着这一切，作为观察者的你在想着什么呢？或许是晚上吃啥以及和她那美好的回忆与幸福。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/beach.jpg" alt=""></p><p>除了这些，我们生活的世界还有许许多多的错综复杂以及变化无穷。那么，这些事物到底是什么呢？是什么使得它们如此不同，但在某些方面又表现得如此相同？面对这一切，作为智慧生物，我们的好奇心驱使我们，提出种种问题，把事物联系起来，而将它们的种种表现理解为或许是由较少量的基本事物和相互作用以无穷多的方式组合后所产生的的结果。毕竟，阿瑟·克拉克说，“心智”是宇宙间最珍贵的东西。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/A%20Space%20Odyssey.jpg" alt="2001：太空漫游"></p><p>比如，沙粒和岩石是两回事儿吗？也许沙粒就是小小的岩石？那月亮是否也是岩石呢？如果我们了解了岩石，是不是就了解了沙粒和月亮呢？</p><p>再比如，风是不是和海洋里的水流类似，就是一种空气的流动？不同的运动有什么共同性质呢？</p><p>等等。我们就是希望试图了解我们所生活环境中的所有问题，将乍看起来不同的事物联系起来，减少不同事物的数目，从而能更好地理解它们。</p><h3 id="2-什么是理解"><a href="#2-什么是理解" class="headerlink" title="2. 什么是理解"></a>2. 什么是理解</h3><p>既然我们希望理解所有的事物，那么首先就应该先问问自己，<strong>什么是理解？</strong>毕竟，有目标才能更好达成目标。</p><p>想象一下，整个世界的运作方式是无所不能的神们所下的一盘巨大的琪。下棋有下棋的规则，我们就是这盘棋的观众。作为普通的观众我们不知道神们下棋的规则，只能看神们是如何下棋的，并以此来猜测棋的规则。就像小时候在旁边看父亲下棋一样。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/chess.jpg" alt="" width="50%" height="50%"><p>如果我们看得够多了，我们就能猜出一些规则来。但即使我们能够猜出一些规则，我们也不能很好地理解某一步棋为什么要那么走，这仅仅是因为情况太复杂了，而我们的智力又是有限的。</p><p>如果你会下象棋，就会知道，知道象棋的规则与如何下好是很不同的。</p><p>自然界也是如此，但是自然更加复杂。</p><p>我们要做的，就是尽可能知道更多的规则，知道了这些规则，就可以说“理解”了世界。</p><h3 id="3-如何理解"><a href="#3-如何理解" class="headerlink" title="3. 如何理解"></a>3. 如何理解</h3><p>几百年前，人们就已经想出了一些方法，那就是：观察、推理和实验，这就是通常所说的科学方法。更详细一点，就是下面这样：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/science.JPG" alt="" width="50%" height="50%"><p>虽然通过上面的方法我们可以得到一些规则，但是，这些规则都是对大自然整个真理的近似，因为我们不知道所有的规则，所以只能一步一步去近似，这样我们才能更好地理解。</p><p>对于理解的检验，有一条科学的原则：实验是一切知识的试金石。</p><h3 id="4-怎么知道我们理解的对呢？"><a href="#4-怎么知道我们理解的对呢？" class="headerlink" title="4. 怎么知道我们理解的对呢？"></a>4. 怎么知道我们理解的对呢？</h3><p>之前我们说过，我们不能全面地理解神们下的棋。既然这样，我们怎么知道我们已经知道的规则就是正确的呢？</p><p>一共有三种办法。第一个，我们首先将大自然安排得非常简单，只有几个部分组成。因为简单，我们可以正确地预测会发生什么事。</p><p>比如，对于象棋，我们知道棋盘上有格子和线条的交叉点。通过几次（甚至一次）观察我们就知道，棋子是放在线条交叉点上的而不是格子里（国际象棋是放在格子里）。</p><p>第二个，利用由已知规则推导出来的较一般性法则来检验已知规则本身。</p><p>比如，我们可能发现，“卒”和“兵”只能前进，不能后退，因此我们可以推断，“卒”和“兵”只能在最开始所在的那条直线上。但是随着更多的观察我们发现，有的“卒”和“兵”在越过中间的楚河汉界之后，还能左右移动，但不管怎样，它们还是不能后退而只能前进。这样，我们通过新发生的现象，更好地理解了之前已知的规则。</p><p>第三个比较粗糙，就是用粗略的近似方法来加以辨别。我们可能不知道公园老大爷那么走的原因，但我们可以猜测，那肯定是为了化解对方的一次将军。同样，根据我们对自然的理解，即使我们不能看出所有事物的规则，我们也能更多地理解我们的自然。</p><h3 id="5-什么是物理"><a href="#5-什么是物理" class="headerlink" title="5. 什么是物理"></a>5. 什么是物理</h3><p>说了这么多，终于到了主题：<strong>什么是物理。</strong></p><p>“物理”一词在英文里是“physics”，最先出自于古希腊文“φύσις”，原意是“自然”。在中文里，这词最早可在战国时期佚书《鹖冠子·王𫓧篇》找到，“愿闻其人情物理所以啬万物与天地总与神明体正之道。”在这里，“物理”指的是一切事物之道理。</p><p>上面说了好多自然啊、事物啊、理解啊、规则啊什么的，其实物理就是研究万物运行的道理。</p><h3 id="6-物理学与其他科学的关系"><a href="#6-物理学与其他科学的关系" class="headerlink" title="6. 物理学与其他科学的关系"></a>6. 物理学与其他科学的关系</h3><p>假如人类遭遇了末日，所有的科学知识都丢了，只能把一句话留给后人，那么怎么用最少的字传递最多的知识呢？</p><blockquote><p>所有的物体都是由原子构成的——这些原子是一些小小的粒子，它们一直不停地运动着，当彼此略微离开时相互吸引，当彼此过于挤紧时又相互排斥。</p></blockquote><p>这一句话，包含了关于这个世界的大量信息。</p><p>这也是物理和其他科学的关系的基石。因为所有的物体都是由原子构成的，其他的科学研究的也是各种物体，不管是化学研究的有机物和无机物，生物研究的各种生命体，天文学研究各种天体，以及地质学研究的各种地质问题，归根结底研究的都是“物体”，而所有的物体都是由原子构成的。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/relations.png" alt=""></p><p>这并不是没有了物理学我们就不能开展其他科学研究了。仅仅是研究的不同角度而已。物理不能回答为什么青蛙会跳，但是物理知道青蛙是什么，就是一堆堆不同的分子组成的一个物体，仅此而已。</p><h3 id="7-那么，开始吧"><a href="#7-那么，开始吧" class="headerlink" title="7. 那么，开始吧"></a>7. 那么，开始吧</h3><p>最后，跟着费恩曼的脚步，逐渐理解我们的世界，慢慢品味物理的美酒。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/feynman.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> physics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> physics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go struct to json</title>
      <link href="/2019/12/05/go-struct-to-json/"/>
      <url>/2019/12/05/go-struct-to-json/</url>
      
        <content type="html"><![CDATA[<p>最近做了一些将go中结构体输出到json的事情，各种花样输出，在这里整理一下。</p><h3 id="问题1：如何将struct转成json？"><a href="#问题1：如何将struct转成json？" class="headerlink" title="问题1：如何将struct转成json？"></a>问题1：如何将struct转成json？</h3><p>这是最简单的一种情况，直接使用<code>encoding/json</code>包中的函数就可以了：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"encoding/json"</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">type</span> Item <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Label <span class="token builtin">string</span>    Value <span class="token builtin">int32</span>    URL   <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    item <span class="token operator">:=</span> Item<span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token string">"http://test.com"</span><span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"Label"</span><span class="token operator">:</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token property">"Value"</span><span class="token operator">:</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token property">"URL"</span><span class="token operator">:</span><span class="token string">"http://test.com"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题2：我想自定义输出json的key怎么弄？"><a href="#问题2：我想自定义输出json的key怎么弄？" class="headerlink" title="问题2：我想自定义输出json的key怎么弄？"></a>问题2：我想自定义输出json的key怎么弄？</h3><p>使用struct的tag即可：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Item <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Label <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>    Value <span class="token builtin">int32</span>  <span class="token string">`json:"value"`</span>    URL   <span class="token builtin">string</span> <span class="token string">`json:"url"`</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token property">"value"</span><span class="token operator">:</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token property">"url"</span><span class="token operator">:</span><span class="token string">"http://test.com"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题3：有的字段不是必须的，如果为空就不输出呢？"><a href="#问题3：有的字段不是必须的，如果为空就不输出呢？" class="headerlink" title="问题3：有的字段不是必须的，如果为空就不输出呢？"></a>问题3：有的字段不是必须的，如果为空就不输出呢？</h3><p>比如URL字段可能为空，如果为空的话就不希望输出了。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    item <span class="token operator">:=</span> Item<span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"label"</span><span class="token operator">:</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token property">"value"</span><span class="token operator">:</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token property">"url"</span><span class="token operator">:</span><span class="token string">""</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用<code>omitempty</code>标签来达到这个目的：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Item <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Label <span class="token builtin">string</span> <span class="token string">`json:"label"`</span>    Value <span class="token builtin">int32</span>  <span class="token string">`json:"value"`</span>    URL   <span class="token builtin">string</span> <span class="token string">`json:"url,omitempty"`</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"label"</span><span class="token operator">:</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token property">"value"</span><span class="token operator">:</span><span class="token number">127</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题4：我想忽略某一个具体的字段"><a href="#问题4：我想忽略某一个具体的字段" class="headerlink" title="问题4：我想忽略某一个具体的字段"></a>问题4：我想忽略某一个具体的字段</h3><p>方法一：可以直接使用这个标签：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name     <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>    Email    <span class="token builtin">string</span> <span class="token string">`json:"email"`</span>    Password <span class="token builtin">string</span> <span class="token string">`json:"-"`</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：如果struct是别人定义的不允许我们修改这个标签，除了我们自定义一个struct外，还可以使用匿名struct：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    user <span class="token operator">:=</span> User<span class="token punctuation">{</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span> <span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>User        Password <span class="token builtin">bool</span> <span class="token string">`json:"password,omitempty"`</span>    <span class="token punctuation">}</span><span class="token punctuation">{</span>        User<span class="token punctuation">:</span> <span class="token operator">&amp;</span>user<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span><span class="token property">"email"</span><span class="token operator">:</span><span class="token string">"1749118121@qq.com"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里使用了嵌套结构体的概念，外面的<code>Password</code>字段覆盖了里面<code>User</code>的<code>Password</code>字段，然后通过问题3里的技巧，达到忽略某个字段的目的。</p><h3 id="问题5：临时添加一个或多个字段"><a href="#问题5：临时添加一个或多个字段" class="headerlink" title="问题5：临时添加一个或多个字段"></a>问题5：临时添加一个或多个字段</h3><p>这个就比较简单了，自定义一个struct即可：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name     <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>    Email    <span class="token builtin">string</span> <span class="token string">`json:"email"`</span>    Password <span class="token builtin">string</span> <span class="token string">`json:"password"`</span><span class="token punctuation">}</span><span class="token keyword">type</span> PublicUser <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token operator">*</span>User    Password <span class="token builtin">bool</span>   <span class="token string">`json:"password,omitempty"`</span>    Token    <span class="token builtin">string</span> <span class="token string">`json:"token"`</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    user <span class="token operator">:=</span> User<span class="token punctuation">{</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span> <span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">}</span>    publicUser <span class="token operator">:=</span> PublicUser<span class="token punctuation">{</span>        User<span class="token punctuation">:</span>  <span class="token operator">&amp;</span>user<span class="token punctuation">,</span>        Token<span class="token punctuation">:</span> <span class="token string">"test_token"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>publicUser<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span><span class="token property">"email"</span><span class="token operator">:</span><span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span><span class="token property">"token"</span><span class="token operator">:</span><span class="token string">"test_token"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题6：将多个struct组合成一个json"><a href="#问题6：将多个struct组合成一个json" class="headerlink" title="问题6：将多个struct组合成一个json"></a>问题6：将多个struct组合成一个json</h3><p>可能一个服务的数据来自不同的接口，需要组合到一个json里，那么同样自定义一个struct就可以了：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name     <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>    Email    <span class="token builtin">string</span> <span class="token string">`json:"email"`</span>    Password <span class="token builtin">string</span> <span class="token string">`json:"password"`</span><span class="token punctuation">}</span><span class="token keyword">type</span> Analytics <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Blogs <span class="token builtin">int32</span> <span class="token string">`json:"blogs"`</span>    Read  <span class="token builtin">int32</span> <span class="token string">`json:"read"`</span><span class="token punctuation">}</span><span class="token keyword">type</span> PublicUser <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token operator">*</span>User    Password <span class="token builtin">bool</span> <span class="token string">`json:"password,omitempty"`</span>    <span class="token operator">*</span>Analytics<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    user <span class="token operator">:=</span> User<span class="token punctuation">{</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span> <span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">}</span>    analytics <span class="token operator">:=</span> Analytics<span class="token punctuation">{</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">}</span>    publicUser <span class="token operator">:=</span> PublicUser<span class="token punctuation">{</span>        User<span class="token punctuation">:</span>      <span class="token operator">&amp;</span>user<span class="token punctuation">,</span>        Analytics<span class="token punctuation">:</span> <span class="token operator">&amp;</span>analytics<span class="token punctuation">,</span>    <span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>publicUser<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span><span class="token property">"email"</span><span class="token operator">:</span><span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span><span class="token property">"blogs"</span><span class="token operator">:</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token property">"read"</span><span class="token operator">:</span><span class="token number">200</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题7：我能自定义一个struct如何转换成json吗？"><a href="#问题7：我能自定义一个struct如何转换成json吗？" class="headerlink" title="问题7：我能自定义一个struct如何转换成json吗？"></a>问题7：我能自定义一个struct如何转换成json吗？</h3><p>比如，我们有这样的结构：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Article <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Title   <span class="token builtin">string</span>    <span class="token string">`json:"title"`</span>    PubTime time<span class="token punctuation">.</span>Time <span class="token string">`json:"pubtime"`</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>直接<code>Marshal</code>后会是这样：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"title"</span><span class="token operator">:</span><span class="token string">"my_title"</span><span class="token punctuation">,</span><span class="token property">"pubtime"</span><span class="token operator">:</span><span class="token string">"2019-12-05T20:52:50.759801+08:00"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果我们想<code>pubtime</code>输出的时间是时间戳，可以自定义输出形式：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>a Article<span class="token punctuation">)</span> <span class="token function">MarshalJSON</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">type</span> Alias Article    <span class="token keyword">return</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token punctuation">{</span>        PubTime <span class="token builtin">int64</span> <span class="token string">`json:"pubtime"`</span>        Article    <span class="token punctuation">}</span><span class="token punctuation">{</span>        PubTime<span class="token punctuation">:</span> a<span class="token punctuation">.</span>PubTime<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        Article<span class="token punctuation">:</span>   a<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而这样是不行的，执行后会报一个<code>fatal error: stack overflow</code>的错误。这是因为，在自定义的<code>MarshalJSON</code>函数里直接调用了<code>Article.MarshalJSON</code>函数，这样就无限调用了，直到报错。</p><p>为了避免出现这个错误，可以定义一个别名（Alias）：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>a Article<span class="token punctuation">)</span> <span class="token function">MarshalJSON</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">type</span> Alias Article    <span class="token keyword">return</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token punctuation">{</span>        PubTime <span class="token builtin">int64</span> <span class="token string">`json:"pubtime"`</span>        Alias    <span class="token punctuation">}</span><span class="token punctuation">{</span>        PubTime<span class="token punctuation">:</span> a<span class="token punctuation">.</span>PubTime<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        Alias<span class="token punctuation">:</span>   <span class="token punctuation">(</span>Alias<span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"pubtime"</span><span class="token operator">:</span><span class="token number">1575638467</span><span class="token punctuation">,</span><span class="token property">"title"</span><span class="token operator">:</span><span class="token string">"my_title"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>完美。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>这篇文章的结束不是这个话题的结束。关于go语言中使用json还有很多话题可以讨论，这里仅仅是将go中的struct转换成json输出，此外，还有将json转换成struct，以及自定义<code>Marshal</code>和<code>Unmarshal</code>函数等话题。</p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/12/04/hello-world/"/>
      <url>/2019/12/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/lufy.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
