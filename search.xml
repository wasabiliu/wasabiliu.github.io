<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Files to MySQL</title>
      <link href="/2019/12/17/files-to-mysql/"/>
      <url>/2019/12/17/files-to-mysql/</url>
      
        <content type="html"><![CDATA[<p><strong>问题</strong>：把一个本地的文件（比如.txt或.csv文件）导入到指定的一张MySQL表中。可以使用mysqlimport或者<code>LOAD DATA</code>命令来完成。这篇文章仅仅是简单介绍一下mysqlimport和<code>LOAD DATA</code>的简单用法。</p><h3 id="1-Prework：创建测试表和文件"><a href="#1-Prework：创建测试表和文件" class="headerlink" title="1. Prework：创建测试表和文件"></a>1. Prework：创建测试表和文件</h3><p>首先创建一个测试表：</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE one_piece (    `no`    INT,    `name`    VARCHAR(15));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后创建一个测试文件：</p><pre class="line-numbers language-shell"><code class="language-shell">cat one_piece.txtno      name100     luffy200     zoro300     nami400     usopp500     sanji600     chopper700     robin800     franky900     brook1000    jinbe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-使用mysqlimport导入文件"><a href="#2-使用mysqlimport导入文件" class="headerlink" title="2. 使用mysqlimport导入文件"></a>2. 使用mysqlimport导入文件</h3><p>使用下面的命令可以将上面创建的one_piece.txt的内容导入表中：</p><pre class="line-numbers language-shell"><code class="language-shell">mysqlimport --ignore-lines=1 \--fields-terminated-by='\t' \--local \-h 10.55.142.100 \-P3596 \-u db_szdev \-p test \/path/to/one_piece.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行后会让输入密码，之后就执行成功了。</p><p>可以查看一下：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM one_piece;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+------+---------+| no   | name    |+------+---------+|  100 | luffy   ||  200 | zoro    ||  300 | nami    ||  400 | usopp   ||  500 | sanji   ||  600 | chopper ||  700 | robin   ||  800 | franky  ||  900 | brook   || 1000 | jinbe   |+------+---------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，导入的文件名需要和对应的表名一样，比如上面的one_piece.txt和对应的表名one_piece。不然会找不到表名。</p><h3 id="3-导入多个文件到多张表中"><a href="#3-导入多个文件到多张表中" class="headerlink" title="3. 导入多个文件到多张表中"></a>3. 导入多个文件到多张表中</h3><p>使用上面的命令我们可以将多个文件导入多张表中：</p><pre class="line-numbers language-shell"><code class="language-shell">mysqlimport --ignore-lines=1 \--fields-terminated-by='\t' \--local \-h 10.55.142.100 \-P3596 \-u db_szdev \-p test \/path/to/one_piece.txt/path/to/steins_gate.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-使用LOAD-DATA导入文件"><a href="#4-使用LOAD-DATA导入文件" class="headerlink" title="4. 使用LOAD DATA导入文件"></a>4. 使用<code>LOAD DATA</code>导入文件</h3><p>mysqlimport其实是对<code>LOAD DATA</code>的一层封装，这样我们就可以使用<code>LOAD DATA</code>导入文件：</p><pre class="line-numbers language-mysql"><code class="language-mysql">LOAD DATA LOCAL INFILE '/path/to/one_piece.txt' INTO TABLE one_piece FIELDS TERMINATED BY '\t' LINES TERMINATED BY '\n' IGNORE 1 LINES (no,name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果是一样的。</p><h3 id="4-mysqlimport常用选项"><a href="#4-mysqlimport常用选项" class="headerlink" title="4. mysqlimport常用选项"></a>4. mysqlimport常用选项</h3><p>mysqlimport的参数比较多，接下来看看一些常用的参数：</p><p><code>--ignore-lines</code>：用来标识忽略的行数，比如如果文件有表头的话，可以忽略这一行；</p><p><code>--fields-terminated-by</code>：用来标识字段分隔符，常用的有<code>\t</code>和<code>,</code>；</p><p><code>--local</code>：表示读取本地文件，如果不加的话就会出错；</p><p><code>-h</code>和<code>-P</code>：表示MySQL服务器的地址，不加的话就是本地的MySQL服务器；</p><p><code>-p</code>：使用密码；</p><p>后面的<code>test</code>就是对应的数据库名。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Types in MySQL</title>
      <link href="/2019/12/16/data-types-in-mysql/"/>
      <url>/2019/12/16/data-types-in-mysql/</url>
      
        <content type="html"><![CDATA[<h3 id="1-开始"><a href="#1-开始" class="headerlink" title="1. 开始"></a>1. 开始</h3><p>为了能更好地理解与使用MySQL，根据MySQL文档花点时间整理了一下MySQL的数据类型。MySQL中一共有五大类数据类型，如下图：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/mysql_datatypes.PNG"><p>这篇文章只对其中的数字类型、字符串类型和时间类型进行总结。</p><p>在这些数据类型的使用中，有几个需要提前知道的地方：</p><ol><li>在整数中，<em><code>M</code></em>代表最大的展示宽度；而在浮点数和定点数中，<em><code>M</code></em>代表可以存储的总位数（也就是精度,precision）；对于字符串类型，<em><code>M</code></em>代表所能存储的最长字符数。不同类型的<em><code>M</code></em>也是不一样的；</li><li><em><code>D</code></em>适用于浮点数和定点数，表示小数点后面的位数。<em><code>D</code></em>最大值是30，但是不能大于<em><code>M-2</code></em>；</li><li><em><code>fsp</code></em>适用于时间类型，表示小于秒的精度。这个值在0和6之间，也就是说MySQL的时间可以精确到微秒级；</li><li>类型定义中的<code>[</code>和<code>]</code>表示可选项。</li></ol><p>不管什么数据类型，计算机的存储都是一样的，不同在于对于底层存储数据的解释不同。</p><p>接下来，详细看看各种数据类型是怎么存储的，以及MySQL是怎么解释的。</p><h3 id="2-Numeric类型"><a href="#2-Numeric类型" class="headerlink" title="2. Numeric类型"></a>2. Numeric类型</h3><p>数字类型还可以细分成如下的几种类型：整数、实数和位数据类型。</p><p>数字类型支持有符号和无符号属性，分别是<code>UNSIGNED</code>和<code>SIGNED</code>。其中<code>SIGNED</code>可以不写在类型定义中，默认就是有符号的。</p><h4 id="2-1-Integer类型"><a href="#2-1-Integer类型" class="headerlink" title="2.1 Integer类型"></a>2.1 Integer类型</h4><p>整数类型根据所占空间大小可以分为五种：<code>TINYINT</code>, <code>SMALLINT</code>, <code>MEDIUMINT</code>, <code>INT</code>, <code>BIGINT</code>。其中<code>INT</code>也是<code>INTEGER</code>。</p><p>按照有无符号又可以分为两种：<code>SIGNED</code>和<code>UNSIGNED</code>，其中默认是有符号的，只需要在指定无符号时使用<code>UNSIGNED</code>。</p><p>整数类型基本情况如下表：</p><table><thead><tr><th>Type</th><th>Bytes</th><th>Min Signed</th><th>Max Signed</th><th>Min Unsigned</th><th>Max Unsigned</th></tr></thead><tbody><tr><td><code>TINYINT</code></td><td>1</td><td>-128</td><td>127</td><td>0</td><td>255</td></tr><tr><td><code>SMALLINT</code></td><td>2</td><td>-32768</td><td>32767</td><td>0</td><td>65535</td></tr><tr><td><code>MEDIUMINT</code></td><td>3</td><td>-8388608</td><td>8388607</td><td>0</td><td>16777215</td></tr><tr><td><code>INT</code></td><td>4</td><td>-2147483648</td><td>2147483647</td><td>0</td><td>4294967295</td></tr><tr><td><code>BIGINT</code></td><td>8</td><td>-2^63</td><td>2^63-1</td><td>0</td><td>2^64-1</td></tr></tbody></table><p>有符号与无符号类型使用相同的存储空间，也具有相同的性能，可以根据需要来选择。不过如果选择了无符号类型，当插入的数据是负数时，会保存为0，需要注意。</p><p>对于整数的<em><code>M</code></em>，比如<code>INT(11)</code>，对于大多数应用这是没有意义的，因为这不会限制值的合法范围，只是规定了MySQL的一些交互工具（比如MySQL命令行客户端）用来显示字符的个数。对于存储和计算来说，<code>INT(1)</code>和<code>INT(11)</code>是相同的。</p><p>还有一个类型，<code>BOOL</code>(也可以是<code>BOOLEAN</code>)，这个类型和<code>TINYINT(1)</code>一样，0为<code>false</code>，非零为<code>true</code>。但是在MySQL中，<code>TRUE</code>就是1<code>FALSE</code>就是0：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT IF(2 = TRUE, 'true', 'false');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果是<code>false</code>。</p><h4 id="2-2-实数类型"><a href="#2-2-实数类型" class="headerlink" title="2.2 实数类型"></a>2.2 实数类型</h4><p>MySQL中除了整数还可以储存实数。对于实数，MySQL既支持精确类型（定点），也支持不精确类型（浮点）。</p><p>对于精确实数类型，MySQL中有<code>DECIMAL</code>，也可以叫做<code>DEC</code>和<code>NUMERIC</code>。</p><p><code>DECIMAL</code>类型定义如下：</p><pre class="line-numbers language-mysql"><code class="language-mysql">salary DECIMAL(5,2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中5就是精度2就是小数点后面的位数。精度也就是数字的总位数，这样<code>salary</code>的范围就是<code>-999.99</code>到<code>999.99</code>。</p><p>对于不精确类型，MySQL有<code>FLOAT</code>和<code>DOUBLE</code>类型，其中<code>FLOAT</code>使用4个字节（也有可能使用8个字节），而<code>DOUBLE</code>使用8个字节进行存储。</p><p>对于<code>FLOAT</code>，还可以这样来指定类型：<code>FLOAT(p)</code>，可以用来指定存储空间大小，具体的大小和<code>p</code>有关。</p><p>浮点类型通常在相同精度时比<code>DECIMAL</code>所需空间少，所以应该尽量在需要精确计算时使用<code>DECIMAL</code>。</p><p>下面列出了不同类型所占的空间：</p><table><thead><tr><th>Data Type</th><th>Storage Required</th></tr></thead><tbody><tr><td><code>FLOAT(p)</code></td><td><code>0&lt;=p&lt;=24</code>时4个字节，<code>25&lt;=p&lt;=53</code>时8个字节</td></tr><tr><td><code>FLOAT</code></td><td>4个字节</td></tr><tr><td><code>DOUBLE</code></td><td>8个字节</td></tr></tbody></table><p>对于<code>DECIMAL</code>情况有些复杂，MySQL将数字打包成二进制字符串来存储，每9个数字使用4个字节，并且对于整数部分和小数部分分开计算。计算规则如下：</p><ol><li>每9个数字使用4个字节；</li><li>不够9个数字的通过下面的表格确定；</li><li>将整数部分和小数部分所占空间相加即是整体空间。</li></ol><p>不够9个数字的部分所占空间：</p><table><thead><tr><th>Leftover Digits</th><th>Number of Bytes</th></tr></thead><tbody><tr><td>0</td><td>0</td></tr><tr><td>1-2</td><td>1</td></tr><tr><td>3-4</td><td>2</td></tr><tr><td>5-6</td><td>3</td></tr><tr><td>7-8</td><td>4</td></tr></tbody></table><p>比如，对于123.123，整数部分3个数字不够9个，查表使用2个字节；同理小数部分也使用2个字节，一共4个字节。</p><p>对于12345.1，整数部分使用3个字节，小数部分使用1个字节，一共4个字节。</p><h4 id="2-3-位数据类型"><a href="#2-3-位数据类型" class="headerlink" title="2.3 位数据类型"></a>2.3 位数据类型</h4><p><code>BIT</code>类型可以存储比特位，<code>BIT(M)</code>可以存储<code>M</code>个比特位，其中<code>M</code>可以取1到64之间的任意值。。</p><p>对于<code>BIT</code>类型，不同的存储引擎存储方式不同。MyISAM会把所有的比特位打包存储，所以19个单独的<code>BIT</code>列只需要19位来存储，所以一共3个字节就可以了；但是对于InnoDB来说，会为每个<code>BIT</code>列使用一个足够小的最小整数类型来存储，所以不能节省空间。</p><p>还有一点需要注意的是，MySQL是使用字符串来存储的，而不是ASCII码的”0”或”1”。但是在数字上下文的场景使用时，结果是把位字符串转换成了数字。比如，如果存储一个<code>b&#39;00111001&#39;</code>（二进制值是57）到<code>BIT(8)</code>中并检索使用，得到的内容是字符码为57的字符串，也就是得到了字符”9”，但是在数字上下文中，得到的是57：</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE bittest(a bit(8));INSERT INTO bittest VALUES (b'00111001');SELECT a, a+0 FROM bittest;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+------+------+| a    | a+0  |+------+------+| 9    |   57 |+------+------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个建议就是，尽可能不使用<code>BIT</code>类型。</p><h3 id="3-String类型"><a href="#3-String类型" class="headerlink" title="3. String类型"></a>3. String类型</h3><h4 id="3-1-VARCHAR和CHAR类型"><a href="#3-1-VARCHAR和CHAR类型" class="headerlink" title="3.1 VARCHAR和CHAR类型"></a>3.1 <code>VARCHAR</code>和<code>CHAR</code>类型</h4><p><code>VARCHAR</code>和<code>CHAR</code>是两种主要的类型，虽然相似，但是在好多方面各不相同。而且，两种类型在磁盘和内存中的存储方式也和存储引擎有关，这里的描述主要是InnoDB和MyISAM。</p><p><strong>区别一：<code>VARCHAR</code>是变长的，<code>CHAR</code>是定长的。</strong></p><p><code>VARDCHAR</code>根据存储的内容使用不同的空间，最长长度定义时指定；而<code>CHAR</code>使用定义时指定的空间。如果存储的值超过了指定的空间，两种类型都会截断超过的部分。</p><p><strong>区别二：两种类型所能存储的最长字符串不同。</strong></p><p><code>VARCHAR</code>可以最多存储65535个字符；而<code>CHAR</code>最多能存储255个字符。最长字符都可以在定义时指定。</p><p><strong>区别三：填充方式</strong></p><p>由于<code>CHAR</code>是定长的，如果存储的值不够指定长度，会在末尾填充空格；而<code>VARCHAR</code>不会填充空格。</p><p><strong>区别四：空间占用</strong></p><p><code>CHAR</code>是定长的，所以指定的长度就是真正需要的空间，不过还和使用的字符集有关。如果使用latin1字符集，那么<code>CHAR(4)</code>就使用4个字节存储。</p><p><code>VARCHAR</code>是变长的，所以需要额外记录字符串的长度。对于字符数小于等于255，额外需要一个字节存储长度；字符数超过255，需要两个字节。</p><p><strong>区别五：末尾空格</strong></p><p>在区别三种提到了<code>CHAR</code>会在后面使用空格填充，但是如果数据本身后面就有空格的话，两个类型处理方式就不同了。<code>CHAR</code>当然会保存空格，但是在检索时会把空格去掉；而<code>VARCHAR</code>不会：存入什么，得到什么。</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE vc (v VARCHAR(4), c CHAR(4));INSERT INTO vc VALUES ('ab  ', 'ab  ');SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+---------------------+---------------------+| CONCAT('(', v, ')') | CONCAT('(', c, ')') |+---------------------+---------------------+| (ab  )              | (ab)                |+---------------------+---------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面的表格演示了两者的区别：</p><table><thead><tr><th>Value</th><th><code>CHAR(4)</code></th><th>Storage Required</th><th><code>VARCHAR(4)</code></th><th>Storage Required</th></tr></thead><tbody><tr><td><code>&#39;&#39;</code></td><td><code>&#39;    &#39;</code></td><td>4 bytes</td><td><code>&#39;&#39;</code></td><td>1 byte</td></tr><tr><td><code>&#39;ab&#39;</code></td><td><code>&#39;ab  &#39;</code></td><td>4 bytes</td><td><code>&#39;ab&#39;</code></td><td>3 bytes</td></tr><tr><td><code>abcd</code></td><td><code>&#39;abcd&#39;</code></td><td>4 bytes</td><td><code>&#39;abcd&#39;</code></td><td>5 bytes</td></tr><tr><td><code>abcdefgh</code></td><td><code>&#39;abcd&#39;</code></td><td>4 bytes</td><td><code>&#39;abcd&#39;</code></td><td>5 bytes</td></tr></tbody></table><p><code>VARCHAR</code>可以节省空间，不过由于是变长的，在更新时可能会比原来的长，这就需要额外的操作。如果一个行占用的空间增长，并且在页中没有更多的空间的话，不同的存储引擎处理方式不同。MyISAM会将行拆分成不同的片段存储；InnoDB则需要分裂页来使行可以放进页内。</p><p><code>CHAR</code>适合存储很短的字符串，或者所有值都接近同一个长度，比如MD5值。对于经常变更的数据，<code>CHAR</code>也比<code>VARCHAR</code>好，因为不会产品碎片。</p><h4 id="3-2-VARBINARY和BINARY类型"><a href="#3-2-VARBINARY和BINARY类型" class="headerlink" title="3.2 VARBINARY和BINARY类型"></a>3.2 <code>VARBINARY</code>和<code>BINARY</code>类型</h4><p><code>VARBINARY</code>和<code>BINARY</code>两种类型和<code>VARCHAR</code>和<code>CHAR</code>类似，不同在于，前两者储存的是二进制字符串（二进制字符码），而后两者存储的是常规字符串（字符）。</p><p>这样有一个问题就是，虽然前两者的长度限制和后两者的一样，但是前两者计算的是字节数，而后两者计算的字符数，这在有些单个字符使用多个字节的字符集中会有所不同。</p><p>还有一点需要注意，<code>BINARY</code>会在数据后面填充<code>\0</code>而不是空格，在检索的时候也不会删除后面的<code>\0</code>。</p><p>二进制字符的优势在于比较。MySQL比较<code>BINARY</code>字符串时，每次按一个字节，并且根据该字节的数值比较。这会比字符比较更快。</p><h4 id="3-3-BLOB和TEXT类型"><a href="#3-3-BLOB和TEXT类型" class="headerlink" title="3.3 BLOB和TEXT类型"></a>3.3 <code>BLOB</code>和<code>TEXT</code>类型</h4><p><code>BLOB</code>和<code>TEXT</code>都是为了存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。</p><p>其实它们也有各自的类型族：<code>TINYBLOB</code>、<code>BLOB</code>、<code>MEDIUMBLOB</code>、<code>LONGBLOB</code>和<code>TINYTEXT</code>、<code>TEXT</code>、<code>MEDIUMTEXT</code>和<code>LONGTEXT</code>。</p><p>当<code>BLOG</code>和<code>TEXT</code>过大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1-4个字节来存储一个指针，指向外部存储区域的实际值。</p><p>MySQL对于<code>BLOB</code>和<code>TEXT</code>列进行排序与其它类型不同：只对最前面的<code>max_sort_length</code>字节而不是整个字符串进行排序。</p><p>MySQL不能将<code>BLOB</code>和<code>TEXT</code>列全部长度的字符串进行索引，也不能使用这些索引消除排序。</p><h4 id="3-4-ENUM类型"><a href="#3-4-ENUM类型" class="headerlink" title="3.4 ENUM类型"></a>3.4 <code>ENUM</code>类型</h4><p>有时候可以使用枚举类型代替常用的字符串类型。枚举类型可以把一些不重复的字符串存储成一个预定义的集合。枚举类型使用一个或两个字节来编码枚举值，最多可以用65535个不同的枚举值。</p><p>创建一个枚举值：</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE shirts (    name VARCHAR(40),    size ENUM('x-small', 'small', 'medium', 'large', 'x-large'));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这也是使用枚举类型的一个缺点，当需要增加枚举值时，只能使用<code>ALTER TABLE</code>：</p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE shirts MODIFY COLUMN size ENUM('x-small', 'small', 'medium', 'large', 'x-large', 'xx-large');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>存储枚举值时使用的是数字而不是对应的字符串：</p><pre class="line-numbers language-mysql"><code class="language-mysql">INSERT INTO shirts (name, size) VALUES ('dress shirt','large'), ('t-shirt','medium'),  ('polo shirt','small');SELECT * FROM shirts;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+-------------+--------+| name        | size   |+-------------+--------+| dress shirt | large  || t-shirt     | medium || polo shirt  | small  |+-------------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过在数字上下文中，可以看到真实存储的值：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT size+0 FROM shirts;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-mysql"><code class="language-mysql">+--------+| size+0 |+--------+|      4 ||      3 ||      2 |+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此：<strong>千万不要使用数字作为枚举值</strong>。</p><p>还有一点，枚举字段是根据存储的数字来排序的而不是定义的字符串：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT size FROM shirts ORDER BY size;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+--------+| size   |+--------+| small  || medium || large  |+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-5-SET类型"><a href="#3-5-SET类型" class="headerlink" title="3.5 SET类型"></a>3.5 <code>SET</code>类型</h4><p>一位可以存储一个只有<code>true/false</code>值，如果有很多<code>true/false</code>值的话，可以使用<code>SET</code>类型，它在MySQL中打包存储，可以有效节省空间，最多可以存储64个<code>true/false</code>值，只需要8个字节。</p><p>和<code>ENUM</code>一样，一个主要的缺点是添加新的定义时需要使用<code>ALTER TABLE</code>。而且，也不能在<code>SET</code>上使用索引。</p><p>作为一个替代方案，可以使用一个整数来包装一系列的位，然后再应用中操作这个整数。不过是使用这个方法还是使用<code>SET</code>依据每个人的偏好。</p><h3 id="4-Date-and-Time类型"><a href="#4-Date-and-Time类型" class="headerlink" title="4. Date and Time类型"></a>4. Date and Time类型</h3><p>MySQL中的时间和日期类型有如下几种：<code>DATE</code>、<code>TIME</code>、<code>DATETIME</code>、<code>TIMESTAMP</code>和<code>YEAR</code>。每种类型都有自己对应的零值和取值范围：</p><table><thead><tr><th>Data Type</th><th>“Zero” Value</th><th>Time Range</th></tr></thead><tbody><tr><td><code>Date</code></td><td><code>&#39;0000-00-00&#39;</code></td><td><code>&#39;1000-01-01&#39;</code> 到<code>&#39;9999-12-31&#39;</code></td></tr><tr><td><code>TIME</code></td><td><code>&#39;00:00:00&#39;</code></td><td><code>&#39;-838：59：59&#39;</code>到<code>&#39;838:59:59&#39;</code></td></tr><tr><td><code>DATETIME</code></td><td><code>&#39;0000-00-00 00:00:00&#39;</code></td><td><code>&#39;1000-01-01 00:00:00&#39;</code>到<code>&#39;9999-12-31 23:59:59&#39;</code></td></tr><tr><td><code>TIMESTAMP</code></td><td><code>&#39;0000-00-00 00:00:00&#39;</code></td><td><code>&#39;1970-01-01 00:00:01&#39;</code>到<code>&#39;2038-01-19 03:14:07&#39;</code></td></tr><tr><td><code>YEAR</code></td><td><code>0000</code></td><td><code>&#39;1901&#39;</code>到<code>&#39;2155&#39;</code>或<code>&#39;0&#39;</code>到<code>&#39;99&#39;</code></td></tr></tbody></table><h4 id="4-1-DATE、DATETIME和TIMESTAMP类型"><a href="#4-1-DATE、DATETIME和TIMESTAMP类型" class="headerlink" title="4.1 DATE、DATETIME和TIMESTAMP类型"></a>4.1 <code>DATE</code>、<code>DATETIME</code>和<code>TIMESTAMP</code>类型</h4><p>这三种类型都含有年月日的信息，但是三种类型又有一些不同。</p><p><code>DATE</code>类型只有日期而没有时间；<code>DATETIME</code>和<code>TIMESTAMP</code>除了日期还有具体的时间。</p><p><code>DATETIME</code>和<code>TIMESTAMP</code>的一个区别是两者的范围不同。<code>DATETIME</code>将日期存储为<code>YYYYMMDDHHMMSS</code>格式的整数中，使用8个字节；而<code>TIMESTAMP</code>使用4个字节存储从1970年1月1日以来的秒数，所以范围小了很多。</p><p>另外一个区别就是<code>TIMESTAMP</code>依赖时区而<code>DATETIME</code>不包含时区。MySQL服务器、操作系统以及客户端连接都可以设置时区。</p><p><code>TIMESTAMP</code>也有一些<code>DATETIME</code>没有的属性，比如可以设置插入和更新时<code>TIMESTAMP</code>列的行为。</p><p>在MySQL 5.6之后<code>DATETIME</code>和<code>TIMESTAMP</code>增加了时间的精确度，在原来秒的基础上精确度增加到了微秒级别，不过需要在定义中指定精确度，比如<code>DATETIME(6)</code>，括号中的数字就是时间的精确度，取值范围是0-6。</p><p>如果指定了额外的精确度的话，MySQL需要额外的空间来存储，所需的空间和精度有关：</p><table><thead><tr><th>fsp</th><th>Storage Required</th></tr></thead><tbody><tr><td>0</td><td>0 bytes</td></tr><tr><td>1, 2</td><td>1 byte</td></tr><tr><td>3, 4</td><td>2 bytes</td></tr><tr><td>5, 6</td><td>3 bytes</td></tr></tbody></table><h4 id="4-2-TIME类型"><a href="#4-2-TIME类型" class="headerlink" title="4.2 TIME类型"></a>4.2 <code>TIME</code>类型</h4><p><code>TIME</code>类型的存储范围并不是感觉上的<code>&#39;00:00:00&#39;</code>到<code>&#39;23:59:59&#39;</code>，而是<code>&#39;-838：59：59&#39;</code>到<code>&#39;838:59:59&#39;</code>，这样就可以表示是两个事件之间的时间差了。</p><p>MySQL中<code>TIME</code>的格式是<code>hh:mm:ss</code>，使用3个字节来存储。</p><p>在对<code>TIME</code>列进行赋值时，需要注意的是，<code>11:12</code>的结果是<code>&#39;11:12:00&#39;</code>，而不是<code>00:11:12</code>；<code>&#39;1112&#39;</code>的结果是<code>&#39;00:11:12&#39;</code>；<code>&#39;12&#39;</code>的结果是<code>&#39;00:00:12&#39;</code>。不过建议不要这么做。</p><p>同样，<code>TIME</code>类型在MySQL 5.6 版本之后添加了微秒级的精度，只需要在定义的时候指定精度即可，所需的额外空间就是上面的表格。</p><h4 id="4-3-YEAR类型"><a href="#4-3-YEAR类型" class="headerlink" title="4.3 YEAR类型"></a>4.3 <code>YEAR</code>类型</h4><p><code>YEAR</code>类型是使用1个字节来存储的数据类型，用来表示年份。在MySQL中，有两种：<code>YEAR(4)</code>和<code>YEAR(2)</code>。</p><p><code>YEAR(4)</code>可以表示的范围是<code>&#39;1901&#39;</code>到<code>&#39;2155&#39;</code>；</p><p><code>YEAR(2)</code>可以的取值范围是<code>&#39;0&#39;</code>到<code>&#39;99&#39;</code>，可以表示的范围是<code>&#39;1970&#39;</code>到<code>&#39;2069&#39;</code>。</p><p>由于范围小，尽量不要使用<code>YEAR(2)</code>。</p><h3 id="5-选择优化的数据类型"><a href="#5-选择优化的数据类型" class="headerlink" title="5. 选择优化的数据类型"></a>5. 选择优化的数据类型</h3><p>MySQL支持的数据类型非常多，选择正确的类型对于性能来说也很重要。下面是选择数据类型时的一些原则。</p><ol><li>一般情况下，应该尽量使用可以正确存储数据的最小数据类型；</li><li>使用简单的数据类型。比如，使用MySQL的内建类型来存储时间而不是字符串，使用整型次数IP地址而不是字符串；</li><li>通常情况下最好指定列为<code>NOT NULL</code>，除非真的需要存储<code>NULL</code>值；</li><li>尽量使用相同的数据类型来存储相似或相关的值，尤其是需要在关联条件中使用的列；</li><li>注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存；</li><li>避免使用MySQL已经遗弃的特性，比如指定浮点数的精度，或者整数的显示宽度；</li><li>小心使用<code>ENUM</code>和<code>SET</code>，不要滥用；</li><li>谨慎使用<code>BIT</code>，对于大部分应用，最好避免使用这个类型。</li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> data_type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File to Redis</title>
      <link href="/2019/12/10/file-to-redis/"/>
      <url>/2019/12/10/file-to-redis/</url>
      
        <content type="html"><![CDATA[<p>问题是这样的，现在需要把一个文件里的所有数据上传到redis的set中，文件里存储的就是ID，每行一个：</p><pre class="line-numbers language-shell"><code class="language-shell">head id.list10000100011000210003100041000510006100071000810009<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了将这一万条记录添加到redis中的某个set中，需要写一个脚本来执行这个操作。</p><p>主要的思路就是构造一个如下命令组成的一堆命令：</p><pre class="line-numbers language-shell"><code class="language-shell">sadd setname 10000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后使用<code>redis-cli</code>将命令通过pipeline的形式发送到服务器。流程如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Redis/file2redis.PNG"><p>下面就是生成命令的shell脚本：</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bashINFILE=$1SETKEY=$2TOFILE=${SETKEY}'.data'echo $TOFILErm $TOFILE >/dev/null 2>&1while IFS= read -r line; do    echo "sadd $SETKEY $line" >> $TOFILEdone < $INFILEunix2dos $TOFILEcat $TOFILE | ./redis-cli --pipe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在脚本的最后，通过下面的命令将所有的redis命令发送到了redis服务器中：</p><pre class="line-numbers language-shell"><code class="language-shell">cat $TOFILE | ./redis-cli --pipe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以在redis中查看是否正确。</p><p>对于将数据导入redis的其它格式中，也是类似的过程，只需要把循环中添加的命令改成需要的形式就可以了。</p><p>Done</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Character Sets and Collations in MySQL</title>
      <link href="/2019/12/08/character-sets-and-collations-in-mysql/"/>
      <url>/2019/12/08/character-sets-and-collations-in-mysql/</url>
      
        <content type="html"><![CDATA[<p>最近遇到一个关于MySQL字符乱码的问题，比较好解决，但是为了更好地理解MySQL中的字符系统，参考MySQL的文档整理一下关于MySQL中字符集合字符序的问题。</p><h3 id="1-什么是字符集和字符序"><a href="#1-什么是字符集和字符序" class="headerlink" title="1. 什么是字符集和字符序"></a>1. 什么是字符集和字符序</h3><p>MySQL是存储数据的数据库，既然是存储数据的，那么数据就需要一个编码的规则，因为计算机对于所有的数据都是通过二进制编码的方式存储的。字符集（Character Sets），就是字符到二进制编码映射的集合。由于不同的语言所包含的字符不同，所以为了支持不同的语言，MySQL定义了许许多多不同的字符集。</p><p>举一个简单的例子，假如我们有一种语言只有四个字符：<code>A, B, a, b</code>。</p><p>我们规定了这四个字符到二进制编码的规则：</p><table><thead><tr><th>Symbol</th><th>Encoding</th></tr></thead><tbody><tr><td><code>A</code></td><td>0</td></tr><tr><td><code>B</code></td><td>1</td></tr><tr><td><code>a</code></td><td>2</td></tr><tr><td><code>b</code></td><td>3</td></tr></tbody></table><p>在这里，<code>A</code>就是一个字符，而数字0就是字符<code>A</code>的编码，这四个字符和编码组合在一起就是字符集。</p><p>接下来看看什么是字符序（Collations）。</p><p>对于上面的字符集，我们需要有一个比较的规则。比如，我们想比较<code>A</code>和<code>B</code>，当然结果有三种：等于、小于或大于。但我们熟悉的还是<code>A&lt;B</code>。一种简单的方式就是比较他们的编码数字。因为<code>0&lt;1</code>，所以对应的字符<code>A&lt;B</code>。</p><p>这样就构成了一条字符比较的规则。这样的一条规则就可以构成一个字符序。</p><p>进一步，如果我们规定大写字母和对应的小写字母相等呢？这样就又多了一条规则：</p><blockquote><p><code>a</code>=<code>A</code>, <code>b</code>=<code>B</code></p></blockquote><p>这样，两条比较的规则就又构成了一个字符序。</p><p>通过这个简单的例子，我们可以知道：</p><ol><li>字符集就是字符到二进制编码的映射集合；</li><li>字符序是比较字符集的规则集合；</li><li>一个字符集可能有多个字符序。</li></ol><p>在MySQL中，定义了许多字符集合字符序。这些字符集合字符序可以帮助我们处理很多字符相关的问题。</p><h3 id="2-MySQL中的字符集合字符序"><a href="#2-MySQL中的字符集合字符序" class="headerlink" title="2. MySQL中的字符集合字符序"></a>2. MySQL中的字符集合字符序</h3><p>在MySQL中，我们可以使用如下的语句来查看字符集：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SHOW CHARACTER SET;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这会列出所有的字符集。如果想筛选的话，可以加上<code>LIKE</code>条件：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SHOW CHARATER SET LIKE 'utf%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下：</p><pre class="line-numbers language-shell"><code class="language-shell">+---------+------------------+--------------------+--------+| Charset | Description      | Default collation  | Maxlen |+---------+------------------+--------------------+--------+| utf16   | UTF-16 Unicode   | utf16_general_ci   |      4 || utf16le | UTF-16LE Unicode | utf16le_general_ci |      4 || utf32   | UTF-32 Unicode   | utf32_general_ci   |      4 || utf8    | UTF-8 Unicode    | utf8_general_ci    |      3 || utf8mb4 | UTF-8 Unicode    | utf8mb4_0900_ai_ci |      4 |+---------+------------------+--------------------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果返回了字符集的名称、描述、默认字符序以及单个字符最大长度等信息。</p><p>每一个字符集都有一个默认的字符序，有的字符集有多个字符序，可以通过下面的语句查看一个字符集的字符序：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SHOW COLLATION WHERE Charset = 'utf8mb4';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回的结果会列出所有的字符序以及相关的信息，这里就不展示了。</p><p>字符序有下面的特点：</p><ol><li>两个不同的字符集不会有相同的字符序。也就是每个字符集都有自己单独的字符序小弟，大家不会有交集；</li><li>每一个字符集都有一个默认的字符序；</li><li>字符序的名字是以对应的字符集名称为前缀的。</li></ol><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/characterset.PNG"><h3 id="3-在MySQL中使用字符集"><a href="#3-在MySQL中使用字符集" class="headerlink" title="3. 在MySQL中使用字符集"></a>3. 在MySQL中使用字符集</h3><p>MySQL中有很多可以控制字符集的选项，这些选项过于复杂很容易混淆。不过记住一点：</p><blockquote><p>只有基于字符的值才真正的“有”字符集的概念。</p></blockquote><p>对于其他类型的值，字符集只是一个设置，用来指定用哪一种字符进行比较或操作。基于字符的值能存放在某列中、查询的字符中、表达式的计算结果中或者某个用户变量中，等等。</p><p>MySQL中字符集的设置可以分为两类：创建对象时的默认值、在服务器和客户端通信时的设置。</p><h4 id="3-1-创建对象时的默认设置"><a href="#3-1-创建对象时的默认设置" class="headerlink" title="3.1 创建对象时的默认设置"></a>3.1 创建对象时的默认设置</h4><p>在MySQL中，从上到下一共有四层字符集的设置，分别是服务器（Server）、数据库（Database）、表（Table）和列（Column），在每一层都可以指定一个默认的字符集：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/charset_layers.PNG"><p>其中，服务器和数据库的字符集设置有对应的参数：<code>character_set_server</code>和<code>character_set_database</code>，表和列的字符集设置在对应的DDL语句中。</p><p>由于真正存放数据的是列，所以更高层次的字符集设置仅仅是指定一个默认值，如果在创建列时没有知道字符集，就会从下到上寻找设置的字符集。如果指定了一个字符集，那么上面所有层次的设置都没有效果了。</p><p>在MySQL 5.5、5.6和5.7中，默认的字符集是latin1，在最新的MySQL 8中，默认的字符集是utf8。</p><h4 id="3-2-服务器和客户端通信时的设置"><a href="#3-2-服务器和客户端通信时的设置" class="headerlink" title="3.2 服务器和客户端通信时的设置"></a>3.2 服务器和客户端通信时的设置</h4><p>当服务器和客户端进行通信时，可能各自使用不同的字符集。这时，服务器需要进行字符的转换工作。这涉及到MySQL中的三个参数：<code>character_set_client</code>、<code>character_set_connection</code>和<code>character_set_results</code>。</p><p>这三个参数的影响效果如下图所示：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/charset_communacate.PNG"><p>这里服务器进行了两次翻译过程：</p><ol><li>SQL语句从客户端离开时的字符集是<code>character_set_client</code>；</li><li>SQL语句进入服务器后服务器转换成<code>character_set_connection</code>；</li><li>服务器处理完SQL语句后，将结果的字符集设置成了<code>character_set_results</code>。</li></ol><p>根据需要，可以使用<code>SET NAMES</code>或者<code>SET CHARACTER SET</code>语句来改变上面的设置：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SET NAMES 'utf8';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，会将<code>character_set_client</code>、<code>character_set_connection</code>和<code>character_set_results</code>都设置成utf8。</p><p>不过在服务器上使用这个命令只能改变服务器端的设置，客户端程序也需要设置正确的字符集才能避免出现问题。</p><h4 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h4><p>可以通过<code>SHOW VARIABLES LIKE &#39;character%&#39;</code>命令来查看这些参数的值：</p><pre class="line-numbers language-shell"><code class="language-shell">+--------------------------+-----------------------------------------------------------+| Variable_name            | Value                                                     |+--------------------------+-----------------------------------------------------------+| character_set_client     | latin1                                                    || character_set_connection | latin1                                                    || character_set_database   | utf8mb4                                                   || character_set_filesystem | binary                                                    || character_set_results    | latin1                                                    || character_set_server     | utf8mb4                                                   || character_set_system     | utf8                                                      || character_sets_dir       | /usr/local/mysql-8.0.13-macos10.14-x86_64/share/charsets/ |+--------------------------+-----------------------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-字符集的选择"><a href="#4-字符集的选择" class="headerlink" title="4. 字符集的选择"></a>4. 字符集的选择</h3><p>使用不同的字符集会带来更多的CPU操作，可能也会消耗更多的内存和磁盘空间。因此，为了方便，最好先为服务器（或者数据库）设置一个合理的字符集，然后根据不同的情况让某些列选择合适的字符集，</p><p>如果统一使用utf8字符集，整个世界都清净了。这也是很常见的一种做法。不过有的时候并不需要使用utf8，使用utf8之后会增加磁盘空间的消耗。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> charset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What is physics</title>
      <link href="/2019/12/07/what-is-physics/"/>
      <url>/2019/12/07/what-is-physics/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是阅读《费恩曼物理学讲义 第一卷 新千年版》第1-3章的阅读笔记。</p></blockquote><h3 id="1-从一片沙滩开始"><a href="#1-从一片沙滩开始" class="headerlink" title="1. 从一片沙滩开始"></a>1. 从一片沙滩开始</h3><p>我们生活在一个多姿多彩的世界中。</p><p>想象一下，去年的某一天，我们正在一个美丽的海边沙滩享受着没有工作烦恼的美妙时光。你躺在柔软细密的沙滩上，不远处就是蔚蓝的大海，海水波光粼粼，海风吹拂，你感受到了凉爽，海水在海风的吹拂下翻起阵阵海浪；海水拍打在海中岩石上，激起浪花与泡沫；海水中生活着许许多多不同的生物，也许海绵宝宝和派大星正在不远处的海底捉水母；太阳挂在天上，持续不断发着光；望着这一切，作为观察者的你在想着什么呢？或许是晚上吃啥以及和她那美好的回忆与幸福。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/beach.jpg" alt=""></p><p>除了这些，我们生活的世界还有许许多多的错综复杂以及变化无穷。那么，这些事物到底是什么呢？是什么使得它们如此不同，但在某些方面又表现得如此相同？面对这一切，作为智慧生物，我们的好奇心驱使我们，提出种种问题，把事物联系起来，而将它们的种种表现理解为或许是由较少量的基本事物和相互作用以无穷多的方式组合后所产生的的结果。毕竟，阿瑟·克拉克说，“心智”是宇宙间最珍贵的东西。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/A%20Space%20Odyssey.jpg" alt="2001：太空漫游"></p><p>比如，沙粒和岩石是两回事儿吗？也许沙粒就是小小的岩石？那月亮是否也是岩石呢？如果我们了解了岩石，是不是就了解了沙粒和月亮呢？</p><p>再比如，风是不是和海洋里的水流类似，就是一种空气的流动？不同的运动有什么共同性质呢？</p><p>等等。我们就是希望试图了解我们所生活环境中的所有问题，将乍看起来不同的事物联系起来，减少不同事物的数目，从而能更好地理解它们。</p><h3 id="2-什么是理解"><a href="#2-什么是理解" class="headerlink" title="2. 什么是理解"></a>2. 什么是理解</h3><p>既然我们希望理解所有的事物，那么首先就应该先问问自己，<strong>什么是理解？</strong>毕竟，有目标才能更好达成目标。</p><p>想象一下，整个世界的运作方式是无所不能的神们所下的一盘巨大的琪。下棋有下棋的规则，我们就是这盘棋的观众。作为普通的观众我们不知道神们下棋的规则，只能看神们是如何下棋的，并以此来猜测棋的规则。就像小时候在旁边看父亲下棋一样。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/chess.jpg" alt="" width="50%" height="50%"><p>如果我们看得够多了，我们就能猜出一些规则来。但即使我们能够猜出一些规则，我们也不能很好地理解某一步棋为什么要那么走，这仅仅是因为情况太复杂了，而我们的智力又是有限的。</p><p>如果你会下象棋，就会知道，知道象棋的规则与如何下好是很不同的。</p><p>自然界也是如此，但是自然更加复杂。</p><p>我们要做的，就是尽可能知道更多的规则，知道了这些规则，就可以说“理解”了世界。</p><h3 id="3-如何理解"><a href="#3-如何理解" class="headerlink" title="3. 如何理解"></a>3. 如何理解</h3><p>几百年前，人们就已经想出了一些方法，那就是：观察、推理和实验，这就是通常所说的科学方法。更详细一点，就是下面这样：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/science.JPG" alt="" width="50%" height="50%"><p>虽然通过上面的方法我们可以得到一些规则，但是，这些规则都是对大自然整个真理的近似，因为我们不知道所有的规则，所以只能一步一步去近似，这样我们才能更好地理解。</p><p>对于理解的检验，有一条科学的原则：实验是一切知识的试金石。</p><h3 id="4-怎么知道我们理解的对呢？"><a href="#4-怎么知道我们理解的对呢？" class="headerlink" title="4. 怎么知道我们理解的对呢？"></a>4. 怎么知道我们理解的对呢？</h3><p>之前我们说过，我们不能全面地理解神们下的棋。既然这样，我们怎么知道我们已经知道的规则就是正确的呢？</p><p>一共有三种办法。第一个，我们首先将大自然安排得非常简单，只有几个部分组成。因为简单，我们可以正确地预测会发生什么事。</p><p>比如，对于象棋，我们知道棋盘上有格子和线条的交叉点。通过几次（甚至一次）观察我们就知道，棋子是放在线条交叉点上的而不是格子里（国际象棋是放在格子里）。</p><p>第二个，利用由已知规则推导出来的较一般性法则来检验已知规则本身。</p><p>比如，我们可能发现，“卒”和“兵”只能前进，不能后退，因此我们可以推断，“卒”和“兵”只能在最开始所在的那条直线上。但是随着更多的观察我们发现，有的“卒”和“兵”在越过中间的楚河汉界之后，还能左右移动，但不管怎样，它们还是不能后退而只能前进。这样，我们通过新发生的现象，更好地理解了之前已知的规则。</p><p>第三个比较粗糙，就是用粗略的近似方法来加以辨别。我们可能不知道公园老大爷那么走的原因，但我们可以猜测，那肯定是为了化解对方的一次将军。同样，根据我们对自然的理解，即使我们不能看出所有事物的规则，我们也能更多地理解我们的自然。</p><h3 id="5-什么是物理"><a href="#5-什么是物理" class="headerlink" title="5. 什么是物理"></a>5. 什么是物理</h3><p>说了这么多，终于到了主题：<strong>什么是物理。</strong></p><p>“物理”一词在英文里是“physics”，最先出自于古希腊文“φύσις”，原意是“自然”。在中文里，这词最早可在战国时期佚书《鹖冠子·王𫓧篇》找到，“愿闻其人情物理所以啬万物与天地总与神明体正之道。”在这里，“物理”指的是一切事物之道理。</p><p>上面说了好多自然啊、事物啊、理解啊、规则啊什么的，其实物理就是研究万物运行的道理。</p><h3 id="6-物理学与其他科学的关系"><a href="#6-物理学与其他科学的关系" class="headerlink" title="6. 物理学与其他科学的关系"></a>6. 物理学与其他科学的关系</h3><p>假如人类遭遇了末日，所有的科学知识都丢了，只能把一句话留给后人，那么怎么用最少的字传递最多的知识呢？</p><blockquote><p>所有的物体都是由原子构成的——这些原子是一些小小的粒子，它们一直不停地运动着，当彼此略微离开时相互吸引，当彼此过于挤紧时又相互排斥。</p></blockquote><p>这一句话，包含了关于这个世界的大量信息。</p><p>这也是物理和其他科学的关系的基石。因为所有的物体都是由原子构成的，其他的科学研究的也是各种物体，不管是化学研究的有机物和无机物，生物研究的各种生命体，天文学研究各种天体，以及地质学研究的各种地质问题，归根结底研究的都是“物体”，而所有的物体都是由原子构成的。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/relations.png" alt=""></p><p>这并不是没有了物理学我们就不能开展其他科学研究了。仅仅是研究的不同角度而已。物理不能回答为什么青蛙会跳，但是物理知道青蛙是什么，就是一堆堆不同的分子组成的一个物体，仅此而已。</p><h3 id="7-那么，开始吧"><a href="#7-那么，开始吧" class="headerlink" title="7. 那么，开始吧"></a>7. 那么，开始吧</h3><p>最后，跟着费恩曼的脚步，逐渐理解我们的世界，慢慢品味物理的美酒。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/feynman.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> physics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> physics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go struct to json</title>
      <link href="/2019/12/05/go-struct-to-json/"/>
      <url>/2019/12/05/go-struct-to-json/</url>
      
        <content type="html"><![CDATA[<p>最近做了一些将go中结构体输出到json的事情，各种花样输出，在这里整理一下。</p><h3 id="问题1：如何将struct转成json？"><a href="#问题1：如何将struct转成json？" class="headerlink" title="问题1：如何将struct转成json？"></a>问题1：如何将struct转成json？</h3><p>这是最简单的一种情况，直接使用<code>encoding/json</code>包中的函数就可以了：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"encoding/json"</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">type</span> Item <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Label <span class="token builtin">string</span>    Value <span class="token builtin">int32</span>    URL   <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    item <span class="token operator">:=</span> Item<span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token string">"http://test.com"</span><span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"Label"</span><span class="token operator">:</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token property">"Value"</span><span class="token operator">:</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token property">"URL"</span><span class="token operator">:</span><span class="token string">"http://test.com"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题2：我想自定义输出json的key怎么弄？"><a href="#问题2：我想自定义输出json的key怎么弄？" class="headerlink" title="问题2：我想自定义输出json的key怎么弄？"></a>问题2：我想自定义输出json的key怎么弄？</h3><p>使用struct的tag即可：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Item <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Label <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>    Value <span class="token builtin">int32</span>  <span class="token string">`json:"value"`</span>    URL   <span class="token builtin">string</span> <span class="token string">`json:"url"`</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token property">"value"</span><span class="token operator">:</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token property">"url"</span><span class="token operator">:</span><span class="token string">"http://test.com"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题3：有的字段不是必须的，如果为空就不输出呢？"><a href="#问题3：有的字段不是必须的，如果为空就不输出呢？" class="headerlink" title="问题3：有的字段不是必须的，如果为空就不输出呢？"></a>问题3：有的字段不是必须的，如果为空就不输出呢？</h3><p>比如URL字段可能为空，如果为空的话就不希望输出了。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    item <span class="token operator">:=</span> Item<span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"label"</span><span class="token operator">:</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token property">"value"</span><span class="token operator">:</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token property">"url"</span><span class="token operator">:</span><span class="token string">""</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用<code>omitempty</code>标签来达到这个目的：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Item <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Label <span class="token builtin">string</span> <span class="token string">`json:"label"`</span>    Value <span class="token builtin">int32</span>  <span class="token string">`json:"value"`</span>    URL   <span class="token builtin">string</span> <span class="token string">`json:"url,omitempty"`</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"label"</span><span class="token operator">:</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token property">"value"</span><span class="token operator">:</span><span class="token number">127</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题4：我想忽略某一个具体的字段"><a href="#问题4：我想忽略某一个具体的字段" class="headerlink" title="问题4：我想忽略某一个具体的字段"></a>问题4：我想忽略某一个具体的字段</h3><p>方法一：可以直接使用这个标签：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name     <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>    Email    <span class="token builtin">string</span> <span class="token string">`json:"email"`</span>    Password <span class="token builtin">string</span> <span class="token string">`json:"-"`</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：如果struct是别人定义的不允许我们修改这个标签，除了我们自定义一个struct外，还可以使用匿名struct：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    user <span class="token operator">:=</span> User<span class="token punctuation">{</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span> <span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>User        Password <span class="token builtin">bool</span> <span class="token string">`json:"password,omitempty"`</span>    <span class="token punctuation">}</span><span class="token punctuation">{</span>        User<span class="token punctuation">:</span> <span class="token operator">&amp;</span>user<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span><span class="token property">"email"</span><span class="token operator">:</span><span class="token string">"1749118121@qq.com"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里使用了嵌套结构体的概念，外面的<code>Password</code>字段覆盖了里面<code>User</code>的<code>Password</code>字段，然后通过问题3里的技巧，达到忽略某个字段的目的。</p><h3 id="问题5：临时添加一个或多个字段"><a href="#问题5：临时添加一个或多个字段" class="headerlink" title="问题5：临时添加一个或多个字段"></a>问题5：临时添加一个或多个字段</h3><p>这个就比较简单了，自定义一个struct即可：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name     <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>    Email    <span class="token builtin">string</span> <span class="token string">`json:"email"`</span>    Password <span class="token builtin">string</span> <span class="token string">`json:"password"`</span><span class="token punctuation">}</span><span class="token keyword">type</span> PublicUser <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token operator">*</span>User    Password <span class="token builtin">bool</span>   <span class="token string">`json:"password,omitempty"`</span>    Token    <span class="token builtin">string</span> <span class="token string">`json:"token"`</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    user <span class="token operator">:=</span> User<span class="token punctuation">{</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span> <span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">}</span>    publicUser <span class="token operator">:=</span> PublicUser<span class="token punctuation">{</span>        User<span class="token punctuation">:</span>  <span class="token operator">&amp;</span>user<span class="token punctuation">,</span>        Token<span class="token punctuation">:</span> <span class="token string">"test_token"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>publicUser<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span><span class="token property">"email"</span><span class="token operator">:</span><span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span><span class="token property">"token"</span><span class="token operator">:</span><span class="token string">"test_token"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题6：将多个struct组合成一个json"><a href="#问题6：将多个struct组合成一个json" class="headerlink" title="问题6：将多个struct组合成一个json"></a>问题6：将多个struct组合成一个json</h3><p>可能一个服务的数据来自不同的接口，需要组合到一个json里，那么同样自定义一个struct就可以了：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name     <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>    Email    <span class="token builtin">string</span> <span class="token string">`json:"email"`</span>    Password <span class="token builtin">string</span> <span class="token string">`json:"password"`</span><span class="token punctuation">}</span><span class="token keyword">type</span> Analytics <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Blogs <span class="token builtin">int32</span> <span class="token string">`json:"blogs"`</span>    Read  <span class="token builtin">int32</span> <span class="token string">`json:"read"`</span><span class="token punctuation">}</span><span class="token keyword">type</span> PublicUser <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token operator">*</span>User    Password <span class="token builtin">bool</span> <span class="token string">`json:"password,omitempty"`</span>    <span class="token operator">*</span>Analytics<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    user <span class="token operator">:=</span> User<span class="token punctuation">{</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span> <span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">}</span>    analytics <span class="token operator">:=</span> Analytics<span class="token punctuation">{</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">}</span>    publicUser <span class="token operator">:=</span> PublicUser<span class="token punctuation">{</span>        User<span class="token punctuation">:</span>      <span class="token operator">&amp;</span>user<span class="token punctuation">,</span>        Analytics<span class="token punctuation">:</span> <span class="token operator">&amp;</span>analytics<span class="token punctuation">,</span>    <span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>publicUser<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span><span class="token property">"email"</span><span class="token operator">:</span><span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span><span class="token property">"blogs"</span><span class="token operator">:</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token property">"read"</span><span class="token operator">:</span><span class="token number">200</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题7：我能自定义一个struct如何转换成json吗？"><a href="#问题7：我能自定义一个struct如何转换成json吗？" class="headerlink" title="问题7：我能自定义一个struct如何转换成json吗？"></a>问题7：我能自定义一个struct如何转换成json吗？</h3><p>比如，我们有这样的结构：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Article <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Title   <span class="token builtin">string</span>    <span class="token string">`json:"title"`</span>    PubTime time<span class="token punctuation">.</span>Time <span class="token string">`json:"pubtime"`</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>直接<code>Marshal</code>后会是这样：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"title"</span><span class="token operator">:</span><span class="token string">"my_title"</span><span class="token punctuation">,</span><span class="token property">"pubtime"</span><span class="token operator">:</span><span class="token string">"2019-12-05T20:52:50.759801+08:00"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果我们想<code>pubtime</code>输出的时间是时间戳，可以自定义输出形式：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>a Article<span class="token punctuation">)</span> <span class="token function">MarshalJSON</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">type</span> Alias Article    <span class="token keyword">return</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token punctuation">{</span>        PubTime <span class="token builtin">int64</span> <span class="token string">`json:"pubtime"`</span>        Article    <span class="token punctuation">}</span><span class="token punctuation">{</span>        PubTime<span class="token punctuation">:</span> a<span class="token punctuation">.</span>PubTime<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        Article<span class="token punctuation">:</span>   a<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而这样是不行的，执行后会报一个<code>fatal error: stack overflow</code>的错误。这是因为，在自定义的<code>MarshalJSON</code>函数里直接调用了<code>Article.MarshalJSON</code>函数，这样就无限调用了，直到报错。</p><p>为了避免出现这个错误，可以定义一个别名（Alias）：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>a Article<span class="token punctuation">)</span> <span class="token function">MarshalJSON</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">type</span> Alias Article    <span class="token keyword">return</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token punctuation">{</span>        PubTime <span class="token builtin">int64</span> <span class="token string">`json:"pubtime"`</span>        Alias    <span class="token punctuation">}</span><span class="token punctuation">{</span>        PubTime<span class="token punctuation">:</span> a<span class="token punctuation">.</span>PubTime<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        Alias<span class="token punctuation">:</span>   <span class="token punctuation">(</span>Alias<span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"pubtime"</span><span class="token operator">:</span><span class="token number">1575638467</span><span class="token punctuation">,</span><span class="token property">"title"</span><span class="token operator">:</span><span class="token string">"my_title"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>完美。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>这篇文章的结束不是这个话题的结束。关于go语言中使用json还有很多话题可以讨论，这里仅仅是将go中的struct转换成json输出，此外，还有将json转换成struct，以及自定义<code>Marshal</code>和<code>Unmarshal</code>函数等话题。</p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/12/04/hello-world/"/>
      <url>/2019/12/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/lufy.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> hello </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> start </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
