<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Roman Empire</title>
      <link href="/roman-empire/"/>
      <url>/roman-empire/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是根据假期看的《罗马人的故事》记录的罗马流水线的第二部分：罗马帝国。罗马帝国从27BC开始到467AD西罗马帝国灭亡共500年的历史，不包括东罗马帝国（拜占庭帝国）。</p></blockquote><h2 id="1-尤利乌斯·克劳狄乌斯王朝（27BC-68AD）"><a href="#1-尤利乌斯·克劳狄乌斯王朝（27BC-68AD）" class="headerlink" title="1. 尤利乌斯·克劳狄乌斯王朝（27BC-68AD）"></a>1. 尤利乌斯·克劳狄乌斯王朝（27BC-68AD）</h2><p>凯撒绘制了罗马元首制的蓝图。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/1.%E5%B0%A4%E5%88%A9%E4%B9%8C%E6%96%AF-%E5%85%8B%E5%8A%B3%E7%8B%84%E4%B9%8C%E6%96%AF%E7%8E%8B%E6%9C%9D.png" alt="尤利乌斯-克劳狄乌斯王朝"></p><h3 id="1-1-屋大维（27BC0116-14AD0819）"><a href="#1-1-屋大维（27BC0116-14AD0819）" class="headerlink" title="1.1 屋大维（27BC0116-14AD0819）"></a>1.1 屋大维（27BC0116-14AD0819）</h3><p>后三头之一</p><p>凯撒养子</p><p>建立近卫军</p><p>在位时间最长的皇帝</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%85%AC%E5%85%8314%E5%B9%B4%E7%9A%84%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD.png" alt="公元14年的罗马帝国"></p><h3 id="1-2-提比略（14-0918-37-0316）"><a href="#1-2-提比略（14-0918-37-0316）" class="headerlink" title="1.2 提比略（14.0918-37.0316）"></a>1.2 提比略（14.0918-37.0316）</h3><p>北方防线退回莱茵河</p><p>隐退卡普里岛</p><h3 id="1-3-卡利古拉（37-0318-41-0124）"><a href="#1-3-卡利古拉（37-0318-41-0124）" class="headerlink" title="1.3 卡利古拉（37.0318-41.0124）"></a>1.3 卡利古拉（37.0318-41.0124）</h3><p>日尔曼尼库斯的儿子，“小军靴”</p><p>残暴</p><h3 id="1-4-克劳狄乌斯（41-0124-54-1013）"><a href="#1-4-克劳狄乌斯（41-0124-54-1013）" class="headerlink" title="1.4 克劳狄乌斯（41.0124-54.1013）"></a>1.4 克劳狄乌斯（41.0124-54.1013）</h3><p>出兵不列颠</p><p>克劳狄乌斯港</p><h3 id="1-5-尼禄（54-1013-68-0609）"><a href="#1-5-尼禄（54-1013-68-0609）" class="headerlink" title="1.5 尼禄（54.1013-68.0609）"></a>1.5 尼禄（54.1013-68.0609）</h3><p>弑母</p><p>罗马大火</p><p>与帕提亚的和平</p><p>记录抹杀刑</p><h2 id="2-四帝内乱时期（68-69）"><a href="#2-四帝内乱时期（68-69）" class="headerlink" title="2. 四帝内乱时期（68-69）"></a>2. 四帝内乱时期（68-69）</h2><p>尼禄被元老院定为全民公敌，南法高卢总督起兵造反兵败被杀。近西班牙行省总督加尔巴被推举为皇帝，四帝内乱时期开始。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/2.%E5%9B%9B%E5%B8%9D%E5%86%85%E4%B9%B1%E6%97%B6%E6%9C%9F.png" alt="四帝内乱时期"></p><h3 id="2-1-加尔巴（68-0618-69-0115）"><a href="#2-1-加尔巴（68-0618-69-0115）" class="headerlink" title="2.1 加尔巴（68.0618-69.0115）"></a>2.1 加尔巴（68.0618-69.0115）</h3><p>近西班牙行省总督</p><h3 id="2-2-奥托（69-0115-69-0415）"><a href="#2-2-奥托（69-0115-69-0415）" class="headerlink" title="2.2 奥托（69.0115-69.0415）"></a>2.2 奥托（69.0115-69.0415）</h3><p>远西班牙行省总督</p><h3 id="2-3-维特里乌斯（69-0416-69-1220）"><a href="#2-3-维特里乌斯（69-0416-69-1220）" class="headerlink" title="2.3 维特里乌斯（69.0416-69.1220）"></a>2.3 维特里乌斯（69.0416-69.1220）</h3><p>日耳曼军团指挥官</p><h3 id="2-4-韦斯帕芗（69-0701-79-0623）"><a href="#2-4-韦斯帕芗（69-0701-79-0623）" class="headerlink" title="2.4 韦斯帕芗（69.0701-79.0623）"></a>2.4 韦斯帕芗（69.0701-79.0623）</h3><p>军人皇帝</p><h2 id="3-弗拉维王朝（69-96）"><a href="#3-弗拉维王朝（69-96）" class="headerlink" title="3. 弗拉维王朝（69-96）"></a>3. 弗拉维王朝（69-96）</h2><p>韦斯帕芗成为四帝内乱时期唯一的皇帝，开创了弗拉维王朝。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/3.%E5%BC%97%E6%8B%89%E7%BB%B4%E7%8E%8B%E6%9C%9D.png" alt="弗拉维王朝"></p><h3 id="3-1-韦斯帕芗（69-0701-79-0623）"><a href="#3-1-韦斯帕芗（69-0701-79-0623）" class="headerlink" title="3.1 韦斯帕芗（69.0701-79.0623）"></a>3.1 韦斯帕芗（69.0701-79.0623）</h3><p>犹太战争</p><h3 id="3-2-提图斯（79-0624-81-0913）"><a href="#3-2-提图斯（79-0624-81-0913）" class="headerlink" title="3.2 提图斯（79.0624-81.0913）"></a>3.2 提图斯（79.0624-81.0913）</h3><p>在位两年天灾不断</p><p>庞培古城</p><h3 id="3-3-图密善（81-0914-96-0918）"><a href="#3-3-图密善（81-0914-96-0918）" class="headerlink" title="3.3 图密善（81.0914-96.0918）"></a>3.3 图密善（81.0914-96.0918）</h3><p>被刺杀</p><p>记录抹杀刑</p><h2 id="4-安敦尼王朝（96-192）"><a href="#4-安敦尼王朝（96-192）" class="headerlink" title="4. 安敦尼王朝（96-192）"></a>4. 安敦尼王朝（96-192）</h2><p>图密善被刺杀后，涅尔瓦被推举为皇帝。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/4.%E5%AE%89%E6%95%A6%E5%B0%BC%E7%8E%8B%E6%9C%9D.png" alt="安敦尼王朝"></p><h3 id="4-1-涅尔瓦（96-0919-98-0127）"><a href="#4-1-涅尔瓦（96-0919-98-0127）" class="headerlink" title="4.1 涅尔瓦（96.0919-98.0127）"></a>4.1 涅尔瓦（96.0919-98.0127）</h3><p>养子继承制</p><h3 id="4-2-图拉真（98-0127-117-0809）"><a href="#4-2-图拉真（98-0127-117-0809）" class="headerlink" title="4.2 图拉真（98.0127-117.0809）"></a>4.2 图拉真（98.0127-117.0809）</h3><p>罗马帝国的鼎盛时期</p><p>征服达契亚</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD%E5%85%A8%E7%9B%9B%E6%97%B6%E6%9C%9F.png" alt="全盛时期的罗马帝国"></p><h3 id="4-3-哈德良（117-0809-138-0710）"><a href="#4-3-哈德良（117-0809-138-0710）" class="headerlink" title="4.3 哈德良（117.0809-138.0710）"></a>4.3 哈德良（117.0809-138.0710）</h3><p>“哈德良长城”</p><p>日耳曼长城，连接多瑙河防线和莱茵河防线</p><h3 id="4-4-安敦尼·庇护（138-0710-161-0307）"><a href="#4-4-安敦尼·庇护（138-0710-161-0307）" class="headerlink" title="4.4 安敦尼·庇护（138.0710-161.0307）"></a>4.4 安敦尼·庇护（138.0710-161.0307）</h3><p>帝国的鼎盛期</p><h3 id="4-5-马可·奥勒留（161-0308-180-0317）"><a href="#4-5-马可·奥勒留（161-0308-180-0317）" class="headerlink" title="4.5 马可·奥勒留（161.0308-180.0317）"></a>4.5 马可·奥勒留（161.0308-180.0317）</h3><p>“哲学家皇帝”</p><p>死于日耳曼前线</p><h3 id="4-6-康茂德（180-0317-192-1231）"><a href="#4-6-康茂德（180-0317-192-1231）" class="headerlink" title="4.6 康茂德（180.0317-192.1231）"></a>4.6 康茂德（180.0317-192.1231）</h3><p>“角斗士皇帝”</p><p>被暗杀</p><p>记录抹杀刑</p><h2 id="5-五帝之年（193）"><a href="#5-五帝之年（193）" class="headerlink" title="5. 五帝之年（193）"></a>5. 五帝之年（193）</h2><p>康茂德被刺杀后，内乱开始。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/5.%E4%BA%94%E5%B8%9D%E4%B9%8B%E5%B9%B4.png" alt="五帝之年"></p><h3 id="5-1-佩提纳克斯（193-0101-193-0328）"><a href="#5-1-佩提纳克斯（193-0101-193-0328）" class="headerlink" title="5.1 佩提纳克斯（193.0101-193.0328）"></a>5.1 佩提纳克斯（193.0101-193.0328）</h3><p>近卫军长官雷特拥立佩提纳克斯为皇帝。</p><p>后因没满足条件被雷特刺杀。</p><h3 id="5-2-狄第乌斯·尤利安（193-0328-193-0601）"><a href="#5-2-狄第乌斯·尤利安（193-0328-193-0601）" class="headerlink" title="5.2 狄第乌斯·尤利安（193.0328-193.0601）"></a>5.2 狄第乌斯·尤利安（193.0328-193.0601）</h3><p>尤利安和佩提纳克斯的岳父弗拉维斯·斯皮切努斯在近卫军面前竞价成功，被近卫军推举为皇帝。</p><p>塞维鲁进军意大利后被近卫军刺杀。</p><h3 id="5-3-赛普提米乌斯·塞维鲁（193-0411-211-0204）"><a href="#5-3-赛普提米乌斯·塞维鲁（193-0411-211-0204）" class="headerlink" title="5.3 赛普提米乌斯·塞维鲁（193.0411-211.0204）"></a>5.3 赛普提米乌斯·塞维鲁（193.0411-211.0204）</h3><p>近潘诺尼亚行省总督塞维鲁被军团兵推举为皇帝。</p><h3 id="5-4-克劳狄乌斯·亚尔比努斯"><a href="#5-4-克劳狄乌斯·亚尔比努斯" class="headerlink" title="5.4 克劳狄乌斯·亚尔比努斯"></a>5.4 克劳狄乌斯·亚尔比努斯</h3><p>不列颠总督，塞维鲁的共治皇帝。</p><p>尼戈失败后，与塞维鲁战争失败被杀。</p><h3 id="5-5-培辛尼乌斯·尼戈"><a href="#5-5-培辛尼乌斯·尼戈" class="headerlink" title="5.5 培辛尼乌斯·尼戈"></a>5.5 培辛尼乌斯·尼戈</h3><p>叙利亚总督，与塞维鲁争夺帝位失败被杀。</p><h2 id="6-塞维鲁王朝（193-235）"><a href="#6-塞维鲁王朝（193-235）" class="headerlink" title="6. 塞维鲁王朝（193-235）"></a>6. 塞维鲁王朝（193-235）</h2><p>五帝之年唯一胜利者赛普提米乌斯·塞维鲁开创了塞维鲁王朝。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/6.%E5%A1%9E%E7%BB%B4%E9%B2%81%E7%8E%8B%E6%9C%9D.png" alt="塞维鲁王朝"></p><h3 id="6-1-塞维鲁（193-0411-211-0204）"><a href="#6-1-塞维鲁（193-0411-211-0204）" class="headerlink" title="6.1 塞维鲁（193.0411-211.0204）"></a>6.1 塞维鲁（193.0411-211.0204）</h3><p>罗马政权军事化的始作俑者。</p><p>东征帕提亚，征服美索不达米亚。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E4%B8%89%E4%B8%96%E7%BA%AA%E5%88%9D%E7%9A%84%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD.png" alt="三世纪初的罗马帝国"></p><h3 id="6-2-卡拉卡拉（211-0204-217-0408）"><a href="#6-2-卡拉卡拉（211-0204-217-0408）" class="headerlink" title="6.2 卡拉卡拉（211.0204-217.0408）"></a>6.2 卡拉卡拉（211.0204-217.0408）</h3><p>安东尼努斯敕令：帝国全境都成为罗马公民</p><p>杀死弟弟盖塔</p><h3 id="6-3-马克里努斯（217-0411-218）"><a href="#6-3-马克里努斯（217-0411-218）" class="headerlink" title="6.3 马克里努斯（217.0411-218）"></a>6.3 马克里努斯（217.0411-218）</h3><p>与帕提亚媾和，放弃美索不达米亚。</p><p>没有进入罗马的皇帝。</p><h3 id="6-4-埃拉伽巴路斯（218-0516-222-0311）"><a href="#6-4-埃拉伽巴路斯（218-0516-222-0311）" class="headerlink" title="6.4 埃拉伽巴路斯（218.0516-222.0311）"></a>6.4 埃拉伽巴路斯（218.0516-222.0311）</h3><p>第一位出身于叙利亚的皇帝。</p><p>被谋杀。</p><h3 id="6-5-亚历山大·塞维鲁（222-0311-235-0318）"><a href="#6-5-亚历山大·塞维鲁（222-0311-235-0318）" class="headerlink" title="6.5 亚历山大·塞维鲁（222.0311-235.0318）"></a>6.5 亚历山大·塞维鲁（222.0311-235.0318）</h3><p>日耳曼战争中被马克西米努斯杀死。</p><h2 id="7-危机时代（235-268）"><a href="#7-危机时代（235-268）" class="headerlink" title="7. 危机时代（235-268）"></a>7. 危机时代（235-268）</h2><p>亚历山大死后，帝国危机达到高潮。下面列出主要的皇帝，一些共治皇帝没有列出来。</p><h3 id="7-1-马克西米努斯（235-238）"><a href="#7-1-马克西米努斯（235-238）" class="headerlink" title="7.1 马克西米努斯（235-238）"></a>7.1 马克西米努斯（235-238）</h3><p>第一位蛮族出身的皇帝（色雷斯人）。</p><h3 id="7-2-戈尔迪安一世（238-0322-238-0412）"><a href="#7-2-戈尔迪安一世（238-0322-238-0412）" class="headerlink" title="7.2 戈尔迪安一世（238.0322-238.0412）"></a>7.2 戈尔迪安一世（238.0322-238.0412）</h3><p>北非行省总督</p><p>支持马克西米努斯的努米底亚总督造反。</p><p>戈尔迪安一世上吊自杀。</p><h3 id="7-3-戈尔迪安二世（238-0322-238-0412）"><a href="#7-3-戈尔迪安二世（238-0322-238-0412）" class="headerlink" title="7.3 戈尔迪安二世（238.0322-238.0412）"></a>7.3 戈尔迪安二世（238.0322-238.0412）</h3><p>戈尔迪安一世的儿子</p><p>战死</p><h3 id="7-4-普皮恩努斯（238）"><a href="#7-4-普皮恩努斯（238）" class="headerlink" title="7.4 普皮恩努斯（238）"></a>7.4 普皮恩努斯（238）</h3><p>元老院推举的皇帝</p><p>被近卫军杀死</p><h3 id="7-5-巴尔比努斯（238）"><a href="#7-5-巴尔比努斯（238）" class="headerlink" title="7.5 巴尔比努斯（238）"></a>7.5 巴尔比努斯（238）</h3><p>元老院推举的皇帝</p><p>被近卫军杀死</p><h3 id="7-6-戈尔迪安三世（238-244）"><a href="#7-6-戈尔迪安三世（238-244）" class="headerlink" title="7.6 戈尔迪安三世（238-244）"></a>7.6 戈尔迪安三世（238-244）</h3><p>戈尔迪安二世的儿子</p><p>被近卫军杀死</p><h3 id="7-7-阿拉伯人菲利普（244-249）"><a href="#7-7-阿拉伯人菲利普（244-249）" class="headerlink" title="7.7 阿拉伯人菲利普（244-249）"></a>7.7 阿拉伯人菲利普（244-249）</h3><p>庆祝罗马建国1000周年</p><p>与德基乌斯的帝位之争失败后自杀</p><p>记录抹杀刑</p><h3 id="7-8-德基乌斯（249-251）"><a href="#7-8-德基乌斯（249-251）" class="headerlink" title="7.8 德基乌斯（249-251）"></a>7.8 德基乌斯（249-251）</h3><p>第一位与蛮族的战争中战死的罗马皇帝（哥特人）</p><h3 id="7-9-加卢斯（251-253）"><a href="#7-9-加卢斯（251-253）" class="headerlink" title="7.9 加卢斯（251-253）"></a>7.9 加卢斯（251-253）</h3><p>远米西亚行省总督</p><p>与哥特人媾和</p><p>被谋杀</p><h3 id="7-10-瓦勒良（253-260）"><a href="#7-10-瓦勒良（253-260）" class="headerlink" title="7.10 瓦勒良（253-260）"></a>7.10 瓦勒良（253-260）</h3><p>第一个被俘的罗马皇帝（波斯萨珊王朝）</p><h3 id="7-11-加里恩努斯（253-268）"><a href="#7-11-加里恩努斯（253-268）" class="headerlink" title="7.11 加里恩努斯（253-268）"></a>7.11 加里恩努斯（253-268）</h3><p>瓦勒良的儿子</p><p>263年高卢独立成立高卢帝国</p><p>帝国三分</p><h2 id="8-伊利里亚诸帝（268-284）"><a href="#8-伊利里亚诸帝（268-284）" class="headerlink" title="8. 伊利里亚诸帝（268-284）"></a>8. 伊利里亚诸帝（268-284）</h2><p>下面的几个皇帝来自于伊利里亚（巴尔干半岛西北部）。</p><h3 id="8-1-克劳狄乌斯二世（268-270）"><a href="#8-1-克劳狄乌斯二世（268-270）" class="headerlink" title="8.1 克劳狄乌斯二世（268-270）"></a>8.1 克劳狄乌斯二世（268-270）</h3><p>战胜哥特人</p><p>死于瘟疫</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E4%B8%89%E5%88%86%E7%9A%84%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD.png" alt="三分的罗马帝国 公元270年左右"></p><h3 id="8-2-奥勒良（270-275）"><a href="#8-2-奥勒良（270-275）" class="headerlink" title="8.2 奥勒良（270-275）"></a>8.2 奥勒良（270-275）</h3><p>重新统一罗马</p><p>塞尔维乌斯城墙被凯撒推翻后，奥勒良重新建造了奥勒良城墙。</p><p>271年，放弃达契亚。</p><p>被谋杀</p><h3 id="8-3-克劳狄乌斯·塔西佗（275-276）"><a href="#8-3-克劳狄乌斯·塔西佗（275-276）" class="headerlink" title="8.3 克劳狄乌斯·塔西佗（275-276）"></a>8.3 克劳狄乌斯·塔西佗（275-276）</h3><p>历史学家塔西佗的后裔</p><p>病死</p><h3 id="8-4-普罗布斯（276-282）"><a href="#8-4-普罗布斯（276-282）" class="headerlink" title="8.4 普罗布斯（276-282）"></a>8.4 普罗布斯（276-282）</h3><p>克劳狄乌斯·塔西佗的同母异父的弟弟</p><p>数次战胜蛮族入侵</p><p>被谋杀</p><h3 id="8-5-卡鲁斯（282-283）"><a href="#8-5-卡鲁斯（282-283）" class="headerlink" title="8.5 卡鲁斯（282-283）"></a>8.5 卡鲁斯（282-283）</h3><p>东征波斯</p><p>遭雷击而死</p><h3 id="8-6-努梅里安（282-283）"><a href="#8-6-努梅里安（282-283）" class="headerlink" title="8.6 努梅里安（282-283）"></a>8.6 努梅里安（282-283）</h3><p>卡鲁斯的儿子</p><p>卡鲁斯死后被谋杀</p><h3 id="8-7-卡里努斯（282-284）"><a href="#8-7-卡里努斯（282-284）" class="headerlink" title="8.7 卡里努斯（282-284）"></a>8.7 卡里努斯（282-284）</h3><p>卡鲁斯的儿子</p><p>被谋杀</p><h2 id="9-四帝共治（284-337）"><a href="#9-四帝共治（284-337）" class="headerlink" title="9. 四帝共治（284-337）"></a>9. 四帝共治（284-337）</h2><p>从戴克里先开始，罗马帝国由元首制变为绝对君主制。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%9B%9B%E5%B8%9D%E5%85%B1%E6%B2%BB.png" alt="四帝共治"></p><h3 id="9-1-戴克里先（284-1120-305-0501）"><a href="#9-1-戴克里先（284-1120-305-0501）" class="headerlink" title="9.1 戴克里先（284.1120-305.0501）"></a>9.1 戴克里先（284.1120-305.0501）</h3><p>结束了三世纪危机，开启四帝共治制度。</p><p>公元305年退位。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E4%B8%89%E4%B8%96%E7%BA%AA%E6%9C%AB%E7%9A%84%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD.png" alt="三世纪末的罗马帝国"></p><h3 id="9-2-马克西米安（286-305）"><a href="#9-2-马克西米安（286-305）" class="headerlink" title="9.2 马克西米安（286-305）"></a>9.2 马克西米安（286-305）</h3><p>首轮四帝共治的西方正帝</p><p>镇压高卢起义</p><p>自杀</p><h3 id="9-3-伽列里乌斯（305-311）"><a href="#9-3-伽列里乌斯（305-311）" class="headerlink" title="9.3 伽列里乌斯（305-311）"></a>9.3 伽列里乌斯（305-311）</h3><p>第一轮四帝共治的东方副帝</p><p>第二轮四帝共治的东方正帝</p><p>病死</p><h3 id="9-4-君士坦提乌斯一世（305-306）"><a href="#9-4-君士坦提乌斯一世（305-306）" class="headerlink" title="9.4 君士坦提乌斯一世（305-306）"></a>9.4 君士坦提乌斯一世（305-306）</h3><p>第一轮四帝共治的西方副帝</p><p>第二轮四帝共治的西方正帝</p><p>死于不列颠</p><h3 id="9-5-塞维鲁二世（306-307）"><a href="#9-5-塞维鲁二世（306-307）" class="headerlink" title="9.5 塞维鲁二世（306-307）"></a>9.5 塞维鲁二世（306-307）</h3><p>君士坦提乌斯一世死后成为西方正帝</p><p>讨伐马克森提乌斯时自杀</p><h3 id="9-6-马克森提乌斯（306-312）"><a href="#9-6-马克森提乌斯（306-312）" class="headerlink" title="9.6 马克森提乌斯（306-312）"></a>9.6 马克森提乌斯（306-312）</h3><p>马克西米安的儿子，自立为帝</p><p>米里维桥战役失败</p><h3 id="9-7-李锡尼（308-324）"><a href="#9-7-李锡尼（308-324）" class="headerlink" title="9.7 李锡尼（308-324）"></a>9.7 李锡尼（308-324）</h3><p>塞维鲁二世死后任西方正帝</p><p>后与君士坦丁一世的斗争中失败</p><h3 id="9-8-马克西米努斯·代亚（310-313）"><a href="#9-8-马克西米努斯·代亚（310-313）" class="headerlink" title="9.8 马克西米努斯·代亚（310-313）"></a>9.8 马克西米努斯·代亚（310-313）</h3><p>第二轮四帝共治的东方副帝</p><p>战败自杀</p><h3 id="9-9-君士坦丁一世（307-337）"><a href="#9-9-君士坦丁一世（307-337）" class="headerlink" title="9.9 君士坦丁一世（307-337）"></a>9.9 君士坦丁一世（307-337）</h3><p>第二轮四帝共治的西方副帝</p><p>成为唯一的皇帝</p><h2 id="10-君士坦丁王朝（307-364）"><a href="#10-君士坦丁王朝（307-364）" class="headerlink" title="10. 君士坦丁王朝（307-364）"></a>10. 君士坦丁王朝（307-364）</h2><p>经过多年的内战，君士坦丁一世成为唯一的皇帝。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/7.%E5%90%9B%E5%A3%AB%E5%9D%A6%E4%B8%81%E7%8E%8B%E6%9C%9D.png" alt="君士坦丁王朝"></p><h3 id="10-1-君士坦丁一世（307-337）"><a href="#10-1-君士坦丁一世（307-337）" class="headerlink" title="10.1 君士坦丁一世（307-337）"></a>10.1 君士坦丁一世（307-337）</h3><p>米兰敕令：承认基督教</p><p>建设新首都君士坦丁堡</p><p>第一个皈依基督教的罗马皇帝</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%90%9B%E5%A3%AB%E5%9D%A6%E4%B8%81%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BA%BA%E4%BA%8B%E5%9B%BE.png" alt="君士坦丁的继承人事图"></p><h3 id="10-2-君士坦提乌斯二世（337-361）"><a href="#10-2-君士坦提乌斯二世（337-361）" class="headerlink" title="10.2 君士坦提乌斯二世（337-361）"></a>10.2 君士坦提乌斯二世（337-361）</h3><p>君士坦丁一世的儿子</p><p>杀害多名亲属</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%85%AC%E5%85%83%E5%9B%9B%E4%B8%96%E7%BA%AA%E4%B8%AD%E5%8F%B6%E7%9A%84%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD.png" alt="公元四世纪中叶的罗马帝国"></p><h3 id="10-3-尤利安（361-363）"><a href="#10-3-尤利安（361-363）" class="headerlink" title="10.3 尤利安（361-363）"></a>10.3 尤利安（361-363）</h3><p>“叛教者尤利安”</p><p>斯特拉斯堡大捷</p><p>远征波斯战死</p><h3 id="10-4-约维安（363-364）"><a href="#10-4-约维安（363-364）" class="headerlink" title="10.4 约维安（363-364）"></a>10.4 约维安（363-364）</h3><p>尤利安的近卫队长，尤利安死后成为皇帝，与波斯缔结合约后暴毙。</p><p>全面推翻尤利安的政策。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%9B%9B%E4%B8%96%E7%BA%AA%E5%90%8E%E6%9C%9F%E8%9B%AE%E6%97%8F%E7%9A%84%E5%88%86%E5%B8%83%E5%92%8C%E5%85%A5%E4%BE%B5%E8%B7%AF%E7%BA%BF.png" alt="四世纪后期蛮族的分布和入侵路线"></p><h2 id="11-瓦伦提尼安王朝（364-392）"><a href="#11-瓦伦提尼安王朝（364-392）" class="headerlink" title="11. 瓦伦提尼安王朝（364-392）"></a>11. 瓦伦提尼安王朝（364-392）</h2><p>约维安死后，瓦伦提尼安成为皇帝，开始了瓦伦提尼安王朝。</p><h3 id="11-1-瓦伦提尼安一世（364-375）"><a href="#11-1-瓦伦提尼安一世（364-375）" class="headerlink" title="11.1 瓦伦提尼安一世（364-375）"></a>11.1 瓦伦提尼安一世（364-375）</h3><p>纯血统的蛮族人</p><h3 id="11-2-瓦伦斯（364-378）"><a href="#11-2-瓦伦斯（364-378）" class="headerlink" title="11.2 瓦伦斯（364-378）"></a>11.2 瓦伦斯（364-378）</h3><p>允许西哥特人入境居住</p><p>378年在与西哥特人的战争中战死（哈德良堡战役）</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%93%88%E5%BE%B7%E8%89%AF%E5%A0%A1%E6%88%98%E5%BD%B9%E5%90%8E%E7%9A%84%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD.png" alt="哈德良堡战役后的罗马帝国"></p><h3 id="11-3-格拉提安（375-383）"><a href="#11-3-格拉提安（375-383）" class="headerlink" title="11.3 格拉提安（375-383）"></a>11.3 格拉提安（375-383）</h3><p>哈德良堡战役后任命狄奥多西为东方皇帝</p><p>被谋杀</p><h3 id="11-4-瓦伦提尼安二世（375-392）"><a href="#11-4-瓦伦提尼安二世（375-392）" class="headerlink" title="11.4 瓦伦提尼安二世（375-392）"></a>11.4 瓦伦提尼安二世（375-392）</h3><p>被谋杀</p><h2 id="12-狄奥多西王朝（379-423）"><a href="#12-狄奥多西王朝（379-423）" class="headerlink" title="12. 狄奥多西王朝（379-423）"></a>12. 狄奥多西王朝（379-423）</h2><p>哈德良堡战役后，格拉提安任命狄奥多西为东方皇帝（这里没有列出东罗马帝国的皇帝）。</p><h3 id="12-1-狄奥多西一世（379-395）"><a href="#12-1-狄奥多西一世（379-395）" class="headerlink" title="12.1 狄奥多西一世（379-395）"></a>12.1 狄奥多西一世（379-395）</h3><p>统一罗马</p><p>宣布基督教为国教</p><p>公元393年废止奥运会</p><p>分裂罗马帝国</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%9B%9B%E4%B8%96%E7%BA%AA%E6%9C%AB%E7%9A%84%E8%9B%AE%E6%97%8F%E5%85%A5%E4%BE%B5.png" alt="四世纪末的蛮族入侵"></p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%85%AC%E5%85%83395%E5%B9%B4%E4%B8%9C%E8%A5%BF%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD%E7%9A%84%E5%88%86%E8%A3%82.png" alt="公元395年东西罗马帝国的分裂"></p><h3 id="12-2-霍诺里乌斯（395-423）"><a href="#12-2-霍诺里乌斯（395-423）" class="headerlink" title="12.2 霍诺里乌斯（395-423）"></a>12.2 霍诺里乌斯（395-423）</h3><p>西罗马帝国皇帝，狄奥多西一世的儿子</p><p>公元410年第一次罗马浩劫</p><p>失去不列颠</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%85%AC%E5%85%83410%E5%B9%B4%E7%9A%84%E8%A5%BF%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD%E4%B8%8E%E8%9B%AE%E6%97%8F.png" alt="公元410年的西罗马帝国与蛮族"></p><h2 id="13-最后的挣扎（423-476）"><a href="#13-最后的挣扎（423-476）" class="headerlink" title="13. 最后的挣扎（423-476）"></a>13. 最后的挣扎（423-476）</h2><p>霍诺里乌斯死后皇帝由外甥瓦伦提尼安三世继承，但是当时瓦伦提尼安三世太小，真正的统治是在425年开始的。</p><h3 id="13-1-瓦伦提尼安三世（425-455）"><a href="#13-1-瓦伦提尼安三世（425-455）" class="headerlink" title="13.1 瓦伦提尼安三世（425-455）"></a>13.1 瓦伦提尼安三世（425-455）</h3><p>被谋杀</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E4%BA%94%E4%B8%96%E7%BA%AA%E4%B8%AD%E5%8F%B6%E7%9A%84%E8%A5%BF%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD.png" alt="五世纪中叶的西罗马帝国"></p><h3 id="13-2-佩特罗尼乌斯·马克西穆斯（455）"><a href="#13-2-佩特罗尼乌斯·马克西穆斯（455）" class="headerlink" title="13.2 佩特罗尼乌斯·马克西穆斯（455）"></a>13.2 佩特罗尼乌斯·马克西穆斯（455）</h3><p>第二次罗马浩劫</p><p>被谋杀</p><h3 id="13-3-阿维图斯（455-456）"><a href="#13-3-阿维图斯（455-456）" class="headerlink" title="13.3 阿维图斯（455-456）"></a>13.3 阿维图斯（455-456）</h3><p>蛮族推荐的皇帝</p><p>被谋杀</p><h3 id="13-4-马约里安（457-461）"><a href="#13-4-马约里安（457-461）" class="headerlink" title="13.4 马约里安（457-461）"></a>13.4 马约里安（457-461）</h3><p>被谋杀</p><h3 id="13-5-塞维鲁（461-465）"><a href="#13-5-塞维鲁（461-465）" class="headerlink" title="13.5 塞维鲁（461-465）"></a>13.5 塞维鲁（461-465）</h3><p>傀儡皇帝</p><p>被谋杀</p><p>之后皇位空余两年</p><h3 id="13-6-安特米乌斯（467-472）"><a href="#13-6-安特米乌斯（467-472）" class="headerlink" title="13.6 安特米乌斯（467-472）"></a>13.6 安特米乌斯（467-472）</h3><p>东罗马帝国安排的皇帝</p><h3 id="13-7-奥利布里乌斯（472）"><a href="#13-7-奥利布里乌斯（472）" class="headerlink" title="13.7 奥利布里乌斯（472）"></a>13.7 奥利布里乌斯（472）</h3><p>病死</p><h3 id="13-8-格里希里乌斯（473-474）"><a href="#13-8-格里希里乌斯（473-474）" class="headerlink" title="13.8 格里希里乌斯（473-474）"></a>13.8 格里希里乌斯（473-474）</h3><p>退位</p><h3 id="13-9-尤利乌斯·尼波斯（474-475）"><a href="#13-9-尤利乌斯·尼波斯（474-475）" class="headerlink" title="13.9 尤利乌斯·尼波斯（474-475）"></a>13.9 尤利乌斯·尼波斯（474-475）</h3><p>东罗马帝国安排的皇帝</p><p>退位</p><h3 id="13-10-罗慕路斯·奥古斯都（475-476）"><a href="#13-10-罗慕路斯·奥古斯都（475-476）" class="headerlink" title="13.10 罗慕路斯·奥古斯都（475-476）"></a>13.10 罗慕路斯·奥古斯都（475-476）</h3><p>末代皇帝</p><p>被蛮族首领奥多亚克废黜</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%85%AC%E5%85%83500%E5%B9%B4%E5%89%8D%E5%90%8E%E7%9A%84%E5%8E%9F%E8%A5%BF%E7%BD%97%E9%A9%AC%E5%B8%9D%E5%9B%BD.png" alt="公元500年前后的原西罗马帝国"></p>]]></content>
      
      
      <categories>
          
          <category> reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> history </tag>
            
            <tag> rome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Roman Republic</title>
      <link href="/roman-republic/"/>
      <url>/roman-republic/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于疫情，有了一个漫长的假期。不玩游戏不看电影不追剧，看书成了唯一的消遣。十几天的时间看完了盐野七生的15卷本《罗马人的故事》，对古罗马的脉络有了一个大体的了解。在这篇文章中，对罗马王政时期和共和国时期的历史做一下简单的梳理。</p></blockquote><h2 id="1-王政时期（753BC-509BC）"><a href="#1-王政时期（753BC-509BC）" class="headerlink" title="1. 王政时期（753BC-509BC）"></a>1. 王政时期（753BC-509BC）</h2><h3 id="1-1-建国之王：罗慕路斯（753BC-716BC）"><a href="#1-1-建国之王：罗慕路斯（753BC-716BC）" class="headerlink" title="1.1. 建国之王：罗慕路斯（753BC-716BC）"></a>1.1. 建国之王：罗慕路斯（753BC-716BC）</h3><p>杀死弟弟瑞摩斯成为罗马唯一的王。</p><p>台伯河：发源于亚平宁山脉，全长300多公里。自罗马向前流经约30公里，经过奥斯提亚注入地中海。</p><p>罗马七山丘：</p><ul><li>奎里尔诺山</li><li>维弥纳山</li><li>埃斯奎利山</li><li>卡匹托尔山</li><li>西里欧山</li><li>阿文庭山</li></ul><p>建国纪念日：公元前753年4月21日。</p><p>国王、元老院和市民大会</p><p>国王：宗教祭祀、军事和政治的最高领导人，由市民大会投票选举产生。</p><p>元老院：不是政府官职，向国王提出忠告和建议，不需要通过市民大会的选举，100人。</p><p>市民大会：全体罗马市民。选出国王和各级政府官员，没有制定政策的权力，但是对国王听取元老院的建议后制定出来的政策有赞成和反对的表决权力。对外关系的战和也需要征得市民大会的同意。</p><p>和萨宾的四次战争。</p><p>同化萨宾人。</p><h3 id="1-2-努马（716BC-672BC）"><a href="#1-2-努马（716BC-672BC）" class="headerlink" title="1.2. 努马（716BC-672BC）"></a>1.2. 努马（716BC-672BC）</h3><p>战神雅努斯神殿</p><p>宗教改革</p><p>罗马众神：</p><ul><li>诸神之王朱庇特</li><li>其妻朱诺女神（幸福婚姻和妇女的保护神）</li><li>美和爱的女神维纳斯</li><li>狩猎女神戴安娜</li><li>学问和艺术之神阿波罗</li><li>智慧女神雅典娜</li><li>战神马尔斯（雅努斯呢？）</li><li>谷物女神克瑞斯</li><li>酒神巴克斯</li><li>商业旅行保护神墨丘利</li><li>医神阿斯克勒庇俄斯</li><li>维里普拉卡女神（调解夫妻矛盾的保护神）</li><li>协和女神</li></ul><h3 id="1-3-托里斯·奥斯蒂吕斯（672BC-642BC）"><a href="#1-3-托里斯·奥斯蒂吕斯（672BC-642BC）" class="headerlink" title="1.3. 托里斯·奥斯蒂吕斯（672BC-642BC）"></a>1.3. 托里斯·奥斯蒂吕斯（672BC-642BC）</h3><p>攻占阿鲁巴，拉丁民族的大本营。</p><h3 id="1-4-安库斯·马尔西乌斯（642BC-616BC）"><a href="#1-4-安库斯·马尔西乌斯（642BC-616BC）" class="headerlink" title="1.4. 安库斯·马尔西乌斯（642BC-616BC）"></a>1.4. 安库斯·马尔西乌斯（642BC-616BC）</h3><p>托里斯女婿、努马外孙，萨宾人。</p><p>建造台伯河上第一座桥。</p><p>征服了奥斯提亚，罗马有了港口。</p><h3 id="1-5-塔克文·普利斯库斯（616BC-578BC）"><a href="#1-5-塔克文·普利斯库斯（616BC-578BC）" class="headerlink" title="1.5. 塔克文·普利斯库斯（616BC-578BC）"></a>1.5. 塔克文·普利斯库斯（616BC-578BC）</h3><p>增加元老院人数到200人。</p><p>被先王安库斯的两个儿子暗杀。</p><h3 id="1-6-塞尔维乌斯·图利乌斯（578BC-543BC）"><a href="#1-6-塞尔维乌斯·图利乌斯（578BC-543BC）" class="headerlink" title="1.6. 塞尔维乌斯·图利乌斯（578BC-543BC）"></a>1.6. 塞尔维乌斯·图利乌斯（578BC-543BC）</h3><p>先王塔克文的养子。</p><p>没有经过市民大会的选举，只通过元老院的决议就登上了王位。</p><p>罗马城墙：塞尔维乌斯城墙。</p><p>罗马选举制不是一人一票制，按军团的最小单位百人队一票。</p><p>被女儿图里亚杀死。</p><h3 id="1-7-最后的国王：傲慢者塔克文（543BC-509BC）"><a href="#1-7-最后的国王：傲慢者塔克文（543BC-509BC）" class="headerlink" title="1.7. 最后的国王：傲慢者塔克文（543BC-509BC）"></a>1.7. 最后的国王：傲慢者塔克文（543BC-509BC）</h3><p>第五代国王的儿子，先王塞尔维乌斯的女婿，妻子图里亚。</p><p>没有市民大会的选举，也没有元老院的同意。</p><p>儿子赛克斯图斯侮辱了科拉提努斯的妻子琉克蕾西亚，琉克蕾西亚自杀。</p><p>被罗马人民驱逐。</p><h2 id="2-罗马共和国（509BC-27BC）"><a href="#2-罗马共和国（509BC-27BC）" class="headerlink" title="2. 罗马共和国（509BC-27BC）"></a>2. 罗马共和国（509BC-27BC）</h2><h3 id="2-1-共和政体的创始人：布鲁图斯"><a href="#2-1-共和政体的创始人：布鲁图斯" class="headerlink" title="2.1. 共和政体的创始人：布鲁图斯"></a>2.1. 共和政体的创始人：布鲁图斯</h3><p>509BC年第一位执政官。</p><p>执政官任期一年。</p><p>杀死参与王政复辟的两个儿子。</p><p>在和傲慢者塔克文的战争中战死。</p><h3 id="2-2-亲民者瓦莱利乌斯"><a href="#2-2-亲民者瓦莱利乌斯" class="headerlink" title="2.2. 亲民者瓦莱利乌斯"></a>2.2. 亲民者瓦莱利乌斯</h3><p>509BC年到503BC年担任四届执政官。</p><p>挫败塔克文和伊特鲁里亚联邦的丘西国王波塞纳的复辟计划。</p><h3 id="2-3-寡头政治下的贵族与平民的对立"><a href="#2-3-寡头政治下的贵族与平民的对立" class="headerlink" title="2.3. 寡头政治下的贵族与平民的对立"></a>2.3. 寡头政治下的贵族与平民的对立</h3><p>公元前494年，罗马与邻近部落的战争中，平民拒绝服兵役，平民运动。</p><p>独裁官任期六个月。</p><p>第二个独裁官，亲民者瓦莱利乌斯的弟弟，马尼乌斯。</p><p>设立护民官，由公民大会选举产生，两人。</p><p>公元前五世纪中叶，考察雅典。</p><p>454BC年，成立一个由贵族和平民组成的十人立法委员会。</p><p>451BC年，十人立法委员会颁布法典，刻在10个铜表上。</p><p>449BC年，新增两表，著名的《十二铜表法》。</p><p>445BC年，允许贵族和平民之间的通婚。</p><p>贵族保护人，平民被保护人。</p><h3 id="2-4-六人军事指挥官"><a href="#2-4-六人军事指挥官" class="headerlink" title="2.4. 六人军事指挥官"></a>2.4. 六人军事指挥官</h3><p>410BC年到360BC年，由六个军事指挥官取代两个执政官。</p><h3 id="2-5-高卢人的入侵"><a href="#2-5-高卢人的入侵" class="headerlink" title="2.5. 高卢人的入侵"></a>2.5. 高卢人的入侵</h3><p>凯尔特人是希腊人的称呼，罗马人叫做高卢人。</p><p>396BC年，独裁官马克斯·弗瑞耶斯·卡米卢斯经过十年战争，罗马消灭了伊特鲁里亚人的城市维爱，直接与凯尔特人接壤。</p><p>卡米卢斯五次担任独裁官，举行过四次凯旋仪式，被誉为仅次于罗慕路斯的罗马的第二个创建者。</p><p>390BC年，高卢人攻克罗马，占领七个月。</p><p>待解决问题：</p><ol><li>在注重防卫的同时，重建被毁的罗马；</li><li>与叛离的旧同盟各部族作战，以此确保边境安全；</li><li>消除贵族与平民之间的对立，实现社会安定和舆论统一。</li></ol><h3 id="2-6-政治改革"><a href="#2-6-政治改革" class="headerlink" title="2.6. 政治改革"></a>2.6. 政治改革</h3><p>367BC年，实施《李锡尼法》</p><ol><li>废除六人军事指挥官，恢复两人执政官。明确罗马实行寡头政治；</li><li>规定共和国政府的所有要职向平民出身的人开放。</li></ol><p>古罗马广场内的协和神殿，纪念《李锡尼法》的实施。</p><p>366BC年，第一个平民执政官。</p><p>356BC年，第一个平民独裁官。</p><p>351BC年，第一个平民财务官。</p><p>332BC年，第一个平民法务官。</p><p>322BC年，禁止因无法还清欠债而剥夺其人身自由。</p><p>287BC年，《霍腾休斯法》平民大会通过的决议可以成为国家的法令。</p><h3 id="2-7-罗马政体"><a href="#2-7-罗马政体" class="headerlink" title="2.7. 罗马政体"></a>2.7. 罗马政体</h3><p>公元前四世纪中叶，罗马的共和政体趋于完善。</p><h4 id="2-7-1-罗马的选举制"><a href="#2-7-1-罗马的选举制" class="headerlink" title="2.7.1. 罗马的选举制"></a>2.7.1. 罗马的选举制</h4><p>采用按照收入的多少纳税。</p><p>百人队构成一票。</p><p>市民大会的总投票数是193票，只要有97票就过半数。</p><p>只要第一等级意见一致，就控制了过半的票。</p><h4 id="2-7-2-执政官（Consul）"><a href="#2-7-2-执政官（Consul）" class="headerlink" title="2.7.2. 执政官（Consul）"></a>2.7.2. 执政官（Consul）</h4><p>市民大会选举产生，元老院批准后就职，任期一年，允许再选，年龄下限40岁，两人。</p><p>召开市民大会，内政的最高领导人。</p><p>也是军队的指挥官，前执政官。</p><p>12个刀斧手做开路先锋。</p><h4 id="2-7-3-独裁官（Dictator）"><a href="#2-7-3-独裁官（Dictator）" class="headerlink" title="2.7.3. 独裁官（Dictator）"></a>2.7.3. 独裁官（Dictator）</h4><p>国家处于非常紧急时期任命的官职，独裁官由两位执政官中的一个指定。</p><p>无权决定改变政体，任何问题上享有绝对的决定权。</p><p>一人，任期六个月。</p><p>24个刀斧手做开路先锋。</p><p>509BC年到390BC年，只任命过7位独裁官。</p><h4 id="2-7-4-法务官（Praetor）"><a href="#2-7-4-法务官（Praetor）" class="headerlink" title="2.7.4. 法务官（Praetor）"></a>2.7.4. 法务官（Praetor）</h4><p>任期一年，40岁以上。</p><p>最初1人，后逐渐扩增至16人。</p><p>除了执政官没有扩增外，其余几乎所有官职都扩增了。</p><p>执政官上前线时管理后方，后变为司法负责人。</p><p>执政官不在时，法务官担任议长，召集在首都罗马举行的市民大会。</p><h4 id="2-7-5-财务检察官（Quaestor）"><a href="#2-7-5-财务检察官（Quaestor）" class="headerlink" title="2.7.5. 财务检察官（Quaestor）"></a>2.7.5. 财务检察官（Quaestor）</h4><p>最初2人，共和末期增加到40人。</p><p>任期一年，30岁以上。</p><p>负责前线的财务。</p><h4 id="2-7-6-财务官（Censor）"><a href="#2-7-6-财务官（Censor）" class="headerlink" title="2.7.6. 财务官（Censor）"></a>2.7.6. 财务官（Censor）</h4><p>最初为人口调查而设，每五年进行一次人口调查选举一次。</p><p>任期一年半以上，两人。</p><p>仅次于执政官的权力。</p><h4 id="2-7-7-按察官（Aedilis）"><a href="#2-7-7-按察官（Aedilis）" class="headerlink" title="2.7.7. 按察官（Aedilis）"></a>2.7.7. 按察官（Aedilis）</h4><p>四人，贵族和平民各两人。</p><p>任期一年，30岁以上。</p><p>策划组织庆祝和祭祀活动；公共安全；保障粮食的供给；负责道路维修、交通整顿和上下水道管理；对各种违法行为作出罚款金额的决定；对市场进行严格监管；在共和末期担任向无产者无偿配送小麦。</p><h4 id="2-7-8-护民官（Tribunus-Plebis）"><a href="#2-7-8-护民官（Tribunus-Plebis）" class="headerlink" title="2.7.8. 护民官（Tribunus Plebis）"></a>2.7.8. 护民官（Tribunus Plebis）</h4><p>平民大会上产生（贵族也可以参加市民大会）。</p><p>任期一年，年龄没有限制，两人，后来增加到10人。</p><p>保护平民的权利，有权对征服所做的决定行使否决权，战时不可以。</p><p>护民官任期结束后，通常转为元老院议员。</p><h4 id="2-7-9-元老院（Senatus）"><a href="#2-7-9-元老院（Senatus）" class="headerlink" title="2.7.9. 元老院（Senatus）"></a>2.7.9. 元老院（Senatus）</h4><p>元老院以及罗马市民（SPQR）：Senatus, Populus, Que, Romanus</p><p>只有元老院议员不需要选举，任期终身。</p><h3 id="2-8-罗马联盟"><a href="#2-8-罗马联盟" class="headerlink" title="2.8. 罗马联盟"></a>2.8. 罗马联盟</h3><p>同盟国只需与罗马缔结协议，加盟国之间不可以。</p><p>338BC年成立。</p><h4 id="2-8-1-盟主罗马"><a href="#2-8-1-盟主罗马" class="headerlink" title="2.8.1 盟主罗马"></a>2.8.1 盟主罗马</h4><p>只要是自由民，部分贵族和平民，都有罗马市民权。有服兵役的义务。</p><p>享有投票权和被选举权，以及参与国政的权利。</p><h4 id="2-8-2-旧拉丁同盟的加盟国"><a href="#2-8-2-旧拉丁同盟的加盟国" class="headerlink" title="2.8.2 旧拉丁同盟的加盟国"></a>2.8.2 旧拉丁同盟的加盟国</h4><p>BC390年背离罗马之后又被罗马打败的国家。</p><p>与罗马有相同的语言、宗教和习俗。</p><p>完全的罗马市民权。</p><h4 id="2-8-3-自治城市"><a href="#2-8-3-自治城市" class="headerlink" title="2.8.3 自治城市"></a>2.8.3 自治城市</h4><p>无投票权的罗马市民权。</p><p>没有选举权和被选举权。</p><p>准罗马市民，三年后可以得到罗马市民权。</p><h4 id="2-8-4-殖民地"><a href="#2-8-4-殖民地" class="headerlink" title="2.8.4 殖民地"></a>2.8.4 殖民地</h4><p>只有被认为战略上非常重要的地方，罗马市民团才回开展殖民建设。是罗马殖民地。</p><p>具有完全的罗马市民权。</p><p>拉丁殖民地：罗马联盟其他加盟国的人民建设的殖民地。</p><h4 id="2-8-5-统称“同盟国”的国家"><a href="#2-8-5-统称“同盟国”的国家" class="headerlink" title="2.8.5 统称“同盟国”的国家"></a>2.8.5 统称“同盟国”的国家</h4><p>当时叫做“同盟市”。</p><p>350BC年以后被罗马打败的国家。</p><p>具有完全的国内自治，允许保留自己的语言、宗教和习俗。</p><p>只需要提供兵力。</p><h3 id="2-9-对意大利中南部的征服"><a href="#2-9-对意大利中南部的征服" class="headerlink" title="2.9 对意大利中南部的征服"></a>2.9 对意大利中南部的征服</h3><p>主要有意大利中南部山岳地带的萨莫奈人，和伊庇鲁斯国王皮洛士。</p><h4 id="2-9-1-萨莫奈人"><a href="#2-9-1-萨莫奈人" class="headerlink" title="2.9.1 萨莫奈人"></a>2.9.1 萨莫奈人</h4><p>第一次萨莫奈战争（343BC-341BC）</p><p>第二次萨莫奈战争（327BC-304BC）</p><p>321BC年考地乌姆耻辱</p><p>第三次萨莫奈战争（298BC-290BC）</p><p>北边高卢人、伊特鲁里亚人和翁布里亚人参战，南部萨莫奈人参战。</p><p>297BC年，昆图斯·费边第五次当选执政官，另一人是德西乌斯第四次当选（平民）。</p><h4 id="2-9-2-意大利南部希腊"><a href="#2-9-2-意大利南部希腊" class="headerlink" title="2.9.2 意大利南部希腊"></a>2.9.2 意大利南部希腊</h4><p>塔兰托和希腊北部的伊庇鲁斯国王皮洛士。</p><p>皮洛士战争（280BC-275BC）</p><p>272BC年，罗马攻陷塔兰托。</p><p>270BC年，完成卢孔比河以南意大利半岛的统一。</p><h3 id="2-10-布匿战争"><a href="#2-10-布匿战争" class="headerlink" title="2.10 布匿战争"></a>2.10 布匿战争</h3><p>罗马和迦太基争夺地中海霸权的战争。</p><h4 id="2-10-1-第一次布匿战争（264BC-241BC）"><a href="#2-10-1-第一次布匿战争（264BC-241BC）" class="headerlink" title="2.10.1 第一次布匿战争（264BC-241BC）"></a>2.10.1 第一次布匿战争（264BC-241BC）</h4><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B8%83%E5%8C%BF%E6%88%98%E4%BA%89%E5%89%8D%E7%9A%84%E7%BD%97%E9%A9%AC%E5%92%8C%E8%BF%A6%E5%A4%AA%E5%9F%BA.png" alt="第一次布匿战争前的罗马和迦太基"></p><p>288BC年，一群叙拉古雇佣兵占领墨西拿。</p><p>265BC年，叙拉古国王希伦二世出兵墨西拿驱逐雇佣兵。</p><p>265BC年，墨西拿向罗马求救。</p><p>264BC年，第一次布匿战争开始。</p><p>262BC年，阿格里真托战役。</p><p>260BC年，米列海战（现在的米拉佐，罗马海军获胜，第一次使用乌鸦吊桥）。</p><p>257BC年，巴勒莫海战（罗马海军获胜）。</p><p>256BC年，埃克诺穆斯海战（现在的利卡塔，罗马海军获胜）。</p><p>256BC年，罗马远征军登陆非洲，战败。</p><p>241BC年，埃加迪群岛海战（罗马海军获胜）。</p><p>结果：罗马获得西西里岛、萨丁岛和科西嘉岛。</p><h4 id="2-10-2-第二次布匿战争（汉尼拔战争，218BC-202BC）"><a href="#2-10-2-第二次布匿战争（汉尼拔战争，218BC-202BC）" class="headerlink" title="2.10.2 第二次布匿战争（汉尼拔战争，218BC-202BC）"></a>2.10.2 第二次布匿战争（汉尼拔战争，218BC-202BC）</h4><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%B8%83%E5%8C%BF%E6%88%98%E4%BA%89%E5%89%8D%E7%9A%84%E7%BD%97%E9%A9%AC%E5%92%8C%E8%BF%A6%E5%A4%AA%E5%9F%BA.png" alt="第二次布匿战争前的罗马和迦太基"></p><p>218BC年，汉尼拔从西班牙出发，跨过阿尔卑斯山，进入意大利。</p><p>218BC年，提契诺河战役（汉尼拔获胜）。</p><p>218BC年，特雷比亚河战役（汉尼拔获胜）。</p><p>217BC年，特拉西梅诺湖战役（汉尼拔获胜）。</p><p>216BC年，坎尼会战（汉尼拔获胜）。</p><p>大西庇阿，普布利乌斯·科尔内利乌斯·西庇阿（235BC-183BC），阿非利加努斯。</p><p>征服西班牙</p><p>征战非洲</p><p>202BC，扎马战役（西庇阿获胜）。</p><p>结果：迦太基只剩下非洲，海军解散，任何自卫战争需征得罗马同意。罗马成为地中海最强大的国家。</p><h4 id="2-10-3-第三次布匿战争（149BC-146BC）"><a href="#2-10-3-第三次布匿战争（149BC-146BC）" class="headerlink" title="2.10.3 第三次布匿战争（149BC-146BC）"></a>2.10.3 第三次布匿战争（149BC-146BC）</h4><p>三年围城战，迦太基灭亡。</p><h3 id="2-11-马其顿战争"><a href="#2-11-马其顿战争" class="headerlink" title="2.11 马其顿战争"></a>2.11 马其顿战争</h3><p>第一次马其顿战争（214BC-205BC），马其顿和汉尼拔结盟。</p><p>第二次马其顿战争（200BC-196BC）。</p><p>塞琉古战争（192BC-188BC），罗马和叙利亚塞琉古王朝的战争。</p><p>第三次马其顿战争（171BC-168BC）。</p><p>第四次马其顿战争（150BC-148BC），战后，马其顿成为罗马的一个行省。</p><h3 id="2-12-格拉古兄弟改革"><a href="#2-12-格拉古兄弟改革" class="headerlink" title="2.12 格拉古兄弟改革"></a>2.12 格拉古兄弟改革</h3><p>格拉古兄弟是大西庇阿的外孙。</p><h4 id="2-12-1-第一次改革：提比略·格拉古"><a href="#2-12-1-第一次改革：提比略·格拉古" class="headerlink" title="2.12.1 第一次改革：提比略·格拉古"></a>2.12.1 第一次改革：提比略·格拉古</h4><p>提比略·格拉古（168BC-133BC）</p><p>133BC年当选护民官，提出土地法案，每户所占公有土地不可以超过1000尤格（约650英亩）。超过部分国家补偿并收回，发放给贫穷农民，三人委员会负责处理。</p><p>被反对派杀死，改革终止。</p><h4 id="2-12-2-第二次改革：盖约·格拉古"><a href="#2-12-2-第二次改革：盖约·格拉古" class="headerlink" title="2.12.2 第二次改革：盖约·格拉古"></a>2.12.2 第二次改革：盖约·格拉古</h4><p>盖约·格拉古（154BC-121BC）</p><p>123BC，122BC年， 当选护民官，陪审团全部由骑士阶级担任；建设海外殖民地安置平民；粮食法低价购买粮食；拉丁公民获得罗马公民权，其余意大利人获得拉丁公民权（未成功）。</p><p>121BC年，被反对派杀死。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%85%AC%E5%85%83%E5%89%8D130%E5%B9%B4%E7%9A%84%E5%9C%B0%E4%B8%AD%E6%B5%B7%E4%B8%96%E7%95%8C.png" alt="公元前130年的地中海世界"></p><h3 id="2-13-西西里奴隶起义"><a href="#2-13-西西里奴隶起义" class="headerlink" title="2.13 西西里奴隶起义"></a>2.13 西西里奴隶起义</h3><p>第一次西西里奴隶起义：137BC-132BC</p><p>第二次西西里奴隶起义：104BC-101BC</p><h3 id="2-14-军人共和"><a href="#2-14-军人共和" class="headerlink" title="2.14 军人共和"></a>2.14 军人共和</h3><h4 id="2-14-1-盖乌斯·马略"><a href="#2-14-1-盖乌斯·马略" class="headerlink" title="2.14.1 盖乌斯·马略"></a>2.14.1 盖乌斯·马略</h4><p>盖乌斯·马略（157BC-86BC），平民。</p><p>辛布里战争（113BC-101BC），日耳曼族入侵。马略成功击败。</p><p>军事改革（志愿兵制）</p><p>晚年和苏拉的斗争。</p><h4 id="2-14-2-路奇乌斯·科尔内利乌斯·苏拉"><a href="#2-14-2-路奇乌斯·科尔内利乌斯·苏拉" class="headerlink" title="2.14.2 路奇乌斯·科尔内利乌斯·苏拉"></a>2.14.2 路奇乌斯·科尔内利乌斯·苏拉</h4><p>路奇乌斯·科尔内利乌斯·苏拉（138BC-78BC）</p><p>朱古达战争（111BC-105BC），努米底亚</p><p>同盟者战争（91BC-88BC），原罗马同盟者</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%90%8C%E7%9B%9F%E6%88%98%E4%BA%89%E6%97%B6%E7%9A%84%E6%84%8F%E5%A4%A7%E5%88%A9%E5%8D%97%E9%83%A8.png" alt="同盟战争时期的意大利南部"></p><p>第一次米特拉达梯战争（89BC-84BC）本都王国</p><p>第一次苏拉内战（88BC-87BC）</p><p>第二次苏拉内战（83BC-81BC）</p><p>81BC-79BC：苏拉独裁</p><h4 id="2-14-3-卢库卢斯"><a href="#2-14-3-卢库卢斯" class="headerlink" title="2.14.3 卢库卢斯"></a>2.14.3 卢库卢斯</h4><p>卢库卢斯（117BC-56BC）</p><p>第一次米特拉达梯战争（89BC-84BC）</p><p>第二次米特拉达梯战争（74BC-66BC）</p><h4 id="2-14-4-马库斯·李锡尼·克拉苏"><a href="#2-14-4-马库斯·李锡尼·克拉苏" class="headerlink" title="2.14.4 马库斯·李锡尼·克拉苏"></a>2.14.4 马库斯·李锡尼·克拉苏</h4><p>前三头之一</p><p>马库斯·李锡尼·克拉苏（115BC-53BC）</p><p>斯巴达克斯起义（73BC-71BC）</p><p>东征帕提亚失败被杀</p><h4 id="2-14-5-格涅乌斯·庞培"><a href="#2-14-5-格涅乌斯·庞培" class="headerlink" title="2.14.5 格涅乌斯·庞培"></a>2.14.5 格涅乌斯·庞培</h4><p>庞培·阿格努斯（伟大的庞培，106BC-48BC）</p><p>肃清海盗</p><p>与凯撒的内战中战败被杀</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E5%BA%9E%E5%9F%B9%E5%B9%B3%E5%AE%9A%E4%B8%9C%E6%96%B9%EF%BC%88%E5%89%8D63%E5%B9%B4%EF%BC%89%E7%9A%84%E5%9C%B0%E4%B8%AD%E6%B5%B7.png" alt="庞培平定东方（前63年）的地中海"></p><h4 id="2-14-5-凯撒"><a href="#2-14-5-凯撒" class="headerlink" title="2.14.5 凯撒"></a>2.14.5 凯撒</h4><p>盖乌斯·尤利乌斯·凯撒（100BC-44BC）</p><p>前三头之一</p><p>征服高卢（58BC-49）</p><p>渡过卢孔比河，内战（49BC-45BC）</p><p>终身独裁官</p><p>被刺杀（44BC）</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/History/%E9%AB%98%E5%8D%A2%E6%88%98%E8%AE%B0%E4%B8%8E%E5%86%85%E6%88%98%E8%AE%B0.png" alt="高卢战记与内战记"></p>]]></content>
      
      
      <categories>
          
          <category> reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> history </tag>
            
            <tag> rome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSL and TLS (Part 3): Protocol</title>
      <link href="/ssl-and-tls-part-3-protocol/"/>
      <url>/ssl-and-tls-part-3-protocol/</url>
      
        <content type="html"><![CDATA[<p>在前面的文章中，我们从密码学的角度讨论了一些主要的密码原语（cryptographic primitive），最后通过组合这些密码原语构成一个可用的安全通信协议。</p><p>这篇文章更进一步，看看TLS是怎么做的。不过TLS的细节太多了也有点难，这里只是在较高的层次上给出一个清晰的认识，不深入复杂的细节。</p><h2 id="1-Record-Protocol"><a href="#1-Record-Protocol" class="headerlink" title="1. Record Protocol"></a>1. Record Protocol</h2><p>像网络模型里其它层一样，TLS也需要一个协议来对数据进行封装。这就是Record Protocol，每个TLS record结构如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/tls_record.png"><p>如果数据过长，TLS会将数据分成大小合适的两条record；如果数据少的话也会合并到一起构成一个record。</p><p>record中的data就是使用Alice和Bob协商的方法和参数加密后的数据了。这样，只要有一个建立好的TLS链接，后续传输的数据都是安全的了。</p><p>那么接下来的问题就是，<strong>TLS是怎么建立一条安全的链接的</strong>。</p><h2 id="2-Handshake-Protocol"><a href="#2-Handshake-Protocol" class="headerlink" title="2. Handshake Protocol"></a>2. Handshake Protocol</h2><p>Handshake Protocol是TLS中最重要的一个协议。在这个过程中，通信的双方，Alice和Bob需要商量好一个具体的方法以及参数，用来在接下来的通信过程中对数据进行加密。这就是Handshake Protocol的目的。</p><p>根据支持的协议和配置的不同，Handshake Protocol主要有三种变形：</p><ol><li>full handshake with server authentication（和一个认证的服务器来一次完整的握手）；</li><li>handshake with client and server authentication（一个认证的client和一个认证的server之前的握手）</li><li>abbreviated handshake that resumes an earlier session（之前握过手，这次就可以简单点了）。</li></ol><p>在讨论握手细节之前，看看消息的格式。</p><h3 id="2-1-Message"><a href="#2-1-Message" class="headerlink" title="2.1 Message"></a>2.1 Message</h3><p>Handshake Protocol的消息格式如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span><span class="token punctuation">{</span>    HandshakeType msg_type<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* handshake type */</span>    uint24 length<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/* remaining bytes in message */</span>    HandshakeMessage message<span class="token punctuation">;</span><span class="token punctuation">}</span> Handshake<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在协商的过程中会有不同的阶段，也有不同类型的消息，每个消息都有自己的格式。<code>message</code>字段的内容根据消息类型而定。</p><h3 id="2-2-Full-Handshake"><a href="#2-2-Full-Handshake" class="headerlink" title="2.2 Full Handshake"></a>2.2 Full Handshake</h3><p>好的，两个之前完全陌生的人见面了，需要“完整地握一次手”认识一下。</p><p>在一个Full Handshake过程中，client和server主要完成下面的四步操作：</p><ol><li>交换容量（capabilities）并确定其他连接参数；</li><li>认证证书，或者使用其他方式进行认证（<strong>真实性</strong>）；</li><li>协商构造一个master secret，用来对会话进行加密（<strong>保密性</strong>）；</li><li>验证Handshake消息的完整性（<strong>完整性</strong>）。</li></ol><p>其中，第2和第3步在一个操作中完成，叫做秘钥交换（key exchange）。分成这两个是为了强调认证的过程，毕竟真实性是很重要的一部分。</p><p>下图展示了一个未认证的client和一个已认证的server之间的Full Handshake流程：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/full_handshake.png"><ol><li>client开启会话并向server发送自己的容量，其中还有很多额外的信息；</li><li>server选择连接的参数；</li><li>server发送自己的证书链（必要的时候）；</li><li>根据选择的参数，server发送生成master secret需要的额外信息；</li><li>server发送一条信息标识协商结束；</li><li>client发送生成master secret需要的额外信息；</li><li>client开启加密模式并通知server；</li><li>client对自己发送和收到的Handshake消息生成一个MAC并发送给server；</li><li>server开启加密模式并通知client；</li><li>server对自己发送和收到的Handshake消息生成一个MAC并发送给client。</li></ol><p>到目前为止，如果没有错误的话，那么一个安全的连接就建立了。接下来详细看看Handshake消息的细节。</p><h4 id="2-2-1-ClientHello"><a href="#2-2-1-ClientHello" class="headerlink" title="2.2.1 ClientHello"></a>2.2.1 ClientHello</h4><p>作为握手的第一个消息，ClientHello包含一些重要的参数和首选项。</p><p>毕竟是要和sever协商一个加密的方法，所以client需要告诉server，我都支持哪些加密算法。之外，如果不是第一次建立连接，希望复用之前协商的结果的话，就应该有个字段标识出之前保存的会话（session）。这就大概包含了主要的信息：</p><table><thead><tr><th>字段</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>Version</td><td>版本</td><td>比如TLS 1.2</td></tr><tr><td>Random</td><td>随机信息</td><td>包含一个随机字符串（32字节）</td></tr><tr><td>Session ID</td><td>会话ID</td><td>第一次为空，如果希望复用的话就使用对应的ID</td></tr><tr><td>Cipher suites</td><td>支持的加密算法</td><td></td></tr><tr><td>Extensions</td><td>扩展模块</td><td>其他的信息可以放在这个模块中</td></tr></tbody></table><h4 id="2-2-2-ServerHello"><a href="#2-2-2-ServerHello" class="headerlink" title="2.2.2 ServerHello"></a>2.2.2 ServerHello</h4><p>对于server，当收到一个ClientHello后，就需要作出回应。因为client在ClientHello中列出了支持的算法，这里server需要选择一个，加上其他的参数一起通知给client，这就是ServerHello的作用。</p><p>ServerHello和ClientHello的消息格式大致相同。</p><h4 id="2-2-3-Certificate"><a href="#2-2-3-Certificate" class="headerlink" title="2.2.3 Certificate"></a>2.2.3 Certificate</h4><p>连接参数和加密算法商量好之后，server需要发送证书给client，以便client来做认证。这就是Certificate消息的作用。</p><p>server需要保证发送的证书和之前协商好的加密算法匹配。常用的证书是X.509格式的。</p><p>大多数情况下使用的是公钥加密算法来进行认证（RSA或ECDSA）。</p><p>Certificate消息是可选的，因为有的认证方法不需要证书。</p><h4 id="2-2-4-SeverKeyExchange"><a href="#2-2-4-SeverKeyExchange" class="headerlink" title="2.2.4 SeverKeyExchange"></a>2.2.4 SeverKeyExchange</h4><p>好的，发送完Certificate之后，client认证了server。接下来就可以开始秘钥交换了（key exchange）。这就是ServerKeyExchange消息的作用。随着使用的秘钥交换协议的不同，这个消息的格式也不一样。知道这个消息的作用就好了。</p><p>ServerKeyExchange也是可选的。</p><h4 id="2-2-5-ServerHelloDone"><a href="#2-2-5-ServerHelloDone" class="headerlink" title="2.2.5 ServerHelloDone"></a>2.2.5 ServerHelloDone</h4><p>到这里，server要做的就暂时结束了，接下来就发送一个ServerHelloDone通知一下client，然后等着client的进一步消息。</p><h4 id="2-2-6-ClientKeyExchange"><a href="#2-2-6-ClientKeyExchange" class="headerlink" title="2.2.6 ClientKeyExchange"></a>2.2.6 ClientKeyExchange</h4><p>秘钥交换是需要通信的双方一起的。server发送完ServerKeyExchange之后，需要client发送自己的消息，这就是ClientKeyExchange。</p><p>这里对秘钥交换多说一些。在TLS中，会话的安全依赖于一个48位长的秘钥，叫做master secret。但是在秘钥交换过程中交换的不是这个master secret，而是另一个值，premaster secret，通过这个值client和server能够计算出master secret。</p><p>TLS支持多种秘钥交换算法比如RSA、DHE_RSA、ECDHE_RSA和ECDHE_ECDSA等。不用管细节了，这些算法都挺复杂的。</p><h4 id="2-2-7-ChangeCipherSpec"><a href="#2-2-7-ChangeCipherSpec" class="headerlink" title="2.2.7 ChangeCipherSpec"></a>2.2.7 ChangeCipherSpec</h4><p>当client接收了ServerKeyExchange并生成自己的ClientKeyExchange之后，那就完成了秘钥交换（具体是怎么做的就不展开了）。根据协商好的秘钥，就可以对后序的数据加密了。同时，对于server来说，收到ClientKeyExchange之后也可以获得通信的秘钥了，然后就可以是所有这个秘钥加密通信了。</p><p>这就是ChangeCipherSpec的作用。不过ChangeCipherSpec不是Handshake Message。</p><h4 id="2-2-8-Finished"><a href="#2-2-8-Finished" class="headerlink" title="2.2.8 Finished"></a>2.2.8 Finished</h4><p>秘钥交换完了，那握手就可以结束了。不过，前面的过程我们实现了保密性和真实性，还少了完整性，这就是Finished达到的目标。</p><p>Finished中有一个<code>verify_data</code>字段，这个字段是通过下面的方法计算得到的，可以用来保证数据的完整性，并在有中间人修改时可以检测到：</p><pre><code>verify_data = PRF(master_secret, finished_label, Hash(handshake_message))</code></pre><p>其中<code>PRF()</code>是为随机函数（pseudorandom function），可以生成任意长度的随机数；<code>finished_label</code>对于不同的消息值也不同（client发送的就是”client finished”，server发送的就是”server finished”）；<code>Hash()</code>是协商好的哈希函数。</p><h3 id="2-3-Client-Authentication"><a href="#2-3-Client-Authentication" class="headerlink" title="2.3 Client Authentication"></a>2.3 Client Authentication</h3><p>server是必须认证的，client的认证是可选的。不过server可以通过发送一个CertificateRequest来请求对client进行认证。然后client发送自己的Certificate消息。整体的流程如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/client_authentication.png"><h4 id="2-3-1-CertificateRequest"><a href="#2-3-1-CertificateRequest" class="headerlink" title="2.3.1 CertificateRequest"></a>2.3.1 CertificateRequest</h4><p>server通过发送这个消息来请求对client进行认证。</p><h4 id="2-3-2-CertificateVerify"><a href="#2-3-2-CertificateVerify" class="headerlink" title="2.3.2 CertificateVerify"></a>2.3.2 CertificateVerify</h4><p>client发送这个消息来对自己的身份进行认证。这个消息包含对到目前为止收到的Handshake消息的签名。这样server就可以进行认证了。</p><h3 id="2-4-Session-Resumption"><a href="#2-4-Session-Resumption" class="headerlink" title="2.4 Session Resumption"></a>2.4 Session Resumption</h3><p>由于加密算法的协商和参数的选择，一个完整的握手需要两个RTT（round-trip time）。同时，握手期间的加解密操作也很耗时，如果能复用之间协商的结果的话，那就可以减轻负担了。</p><p>在一个完整握手过程中，如果server希望复用，那么就可以在ServerHello中返回一个session ID给client，然后将数据保存起来。如果client希望复用，在ClientHello中加上那个session ID就可以了：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/session_resumption.png"><p>这样只有一个RTT就完成了握手。</p><p>除了session ID，还可以使用session tickets的方式来恢复会话。在TLS 1.3中，使用的是PSK（Pre-Shared Key）。</p><p>这里简单描述了一个握手的整个过程。握手完成之后，就可以安全地通信了。</p><h2 id="3-加密"><a href="#3-加密" class="headerlink" title="3. 加密"></a>3. 加密</h2><p>完成了认证和秘钥交换，就可以进行加密操作了。TLS支持多种加密算法，常用的是AES，有三种不同类型的加密，stream，block和authenticated。在TLS中，数据的完整性校验也包含在加密过程中。</p><h3 id="3-1-Stream-Encryption"><a href="#3-1-Stream-Encryption" class="headerlink" title="3.1 Stream Encryption"></a>3.1 Stream Encryption</h3><p>流密码的加密过程如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/stream_encryption.png"><p>有两个步骤：</p><ol><li>将序列号（Sequence Number）、头部Header和明文数据组合在一起生成MAC，由于Header数据没有被加密，在计算MAC过程中包含Header可以防止Header被篡改；包含序列号可以防止重放攻击；</li><li>明文数据和第一步计算出来的MAC放在一起加密得到密文。</li></ol><h3 id="3-2-Block-Encryption"><a href="#3-2-Block-Encryption" class="headerlink" title="3.2 Block Encryption"></a>3.2 Block Encryption</h3><p>使用分组密码的流程如下：</p><ol><li>计算序列号、header和明文的MAC（和流密码一样）；</li><li>由于使用分组密码，可能需要填充padding操作（通常分组是16字节）；</li><li>生成初始向量（initialization vector，IV），长度和分组一样长；</li><li>使用CBC模式加密明文，MAC和padding；</li><li>发送IV和密文。</li></ol><p>如图：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/block_encryption.png"><p>这里有个问题就是，padding没有放在计算MAC之内。</p><h3 id="3-3-Authenticated-Encryption"><a href="#3-3-Authenticated-Encryption" class="headerlink" title="3.3 Authenticated Encryption"></a>3.3 Authenticated Encryption</h3><p>认证密码把加密和完整性校验放在了一起，全称叫做authenticated encryption with associated data(AEAD)。过程如下：</p><ol><li>生成一个64位的nonce；</li><li>对明文加密，同时使用认证算法将序列号和header添加进来；</li><li>将密文和nonce一起发送。</li></ol><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/authenticated_encryption.png"><h2 id="4-密码学操作"><a href="#4-密码学操作" class="headerlink" title="4. 密码学操作"></a>4. 密码学操作</h2><p>上面是在较高的层次的层次上讨论TLS是怎么做的。接下来从密码学的角度看看一些操作。</p><h3 id="4-1-伪随机函数"><a href="#4-1-伪随机函数" class="headerlink" title="4.1 伪随机函数"></a>4.1 伪随机函数</h3><p>前面我们说过了伪随机函数PRF（pseudorandom function），用来产生任意长度的伪随机数。从TLS 1.2开始，所有的算法都需要指定自己的PRF。TLS 1.2中，PRF定义在P_hash函数上的：</p><pre><code>PRF(secret, label, seed) = P_hash(secret, label + seed)</code></pre><p>三个参数，<code>secret</code>，<code>label</code>和<code>seed</code>。</p><p>而<code>P_hash</code>函数是基于HMAC的：</p><pre><code>P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +                       HMAC_hash(secret, A(2) + seed) +                       HMAC_hash(secret, A(3) + seed) + ...</code></pre><p>其中<code>A(i)</code>函数定义如下：</p><pre><code>A(1) = HMAC_hash(secret, seed)A(2) = HMAC_hash(secret, A(1))...A(i) = HMAC_hash(secret, A(i-1))</code></pre><p>由于使用了<code>seed</code>和<code>label</code>，同一个<code>secret</code>可以使用多次。</p><h3 id="4-2-Master-Secret"><a href="#4-2-Master-Secret" class="headerlink" title="4.2 Master Secret"></a>4.2 Master Secret</h3><p>之前说过，秘钥交换的不是master secret，而是premaster secret，然后生成master secret。通过下面的方法可以生成48字节长的master secret：</p><pre><code>master_secret = PRF(pre_master_secret, &quot;master secret&quot;, ClientHello.random + ServerHello.random)</code></pre><h3 id="4-3-生成秘钥"><a href="#4-3-生成秘钥" class="headerlink" title="4.3 生成秘钥"></a>4.3 生成秘钥</h3><p>有了master secret之后，就可以生成秘钥了：</p><pre><code>key_block = PRF(SecurityParamters.master_secret,                &quot;key expansion&quot;,                SecurityParameters.server_random + SecurityParameters.client_random)</code></pre><p>生成的key_block可以分成六部分：两个MAC秘钥，两个加密秘钥还有两个初始化变量（IV）。不同的秘钥用于不同的操作，这样可以防止秘钥的重复使用。</p><h2 id="5-Cipher-Suites"><a href="#5-Cipher-Suites" class="headerlink" title="5. Cipher Suites"></a>5. Cipher Suites</h2><p>最后，介绍一下加密算法。一个cipher suite就是一组密码原语以及定义实现的参数的组合。主要包括下面的东西：</p><ul><li>认证方法（Authentication method）</li><li>秘钥交换方法（Key exchange method）</li><li>加密算法（Encryption algorithm）</li><li>加密秘钥长度（Encryption key size）</li><li>密码模式（Cipher mode）</li><li>MAC算法（MAC algorithm）</li><li>PRF</li><li>Finished消息使用的哈希函数</li><li>verify_data的长度</li></ul><p>一个cipher suite的名字就指出了上面那些内容的具体实现：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/cipher_suite_name.png"><p>下表列出了一些常见的cipher suite：</p><table><thead><tr><th>Cipher Suite Name</th><th>Auth</th><th>KX</th><th>Cipher</th><th>MAC</th><th>PRF</th></tr></thead><tbody><tr><td>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</td><td>RSA</td><td>ECDHE</td><td>AES-128-GCM</td><td>-</td><td>SHA256</td></tr><tr><td>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</td><td>ECDSA</td><td>ECDHE</td><td>AES-256-GCM</td><td>-</td><td>SHA384</td></tr><tr><td>TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA</td><td>RSA</td><td>DHE</td><td>3DES-EDE-CBC</td><td>SHA1</td><td>Protocol</td></tr><tr><td>TLS_RSA_WITH_AES_128_CBC_SHA</td><td>RSA</td><td>RSA</td><td>AES-128_CBC</td><td>SHA1</td><td>Protocol</td></tr><tr><td>TLS_ECDHE_ECDSA_WITH_AES_128_CCM</td><td>ECDSA</td><td>ECDHE</td><td>AES-128-CCM</td><td>-</td><td>SHA256</td></tr></tbody></table><p>好了，到现在为止我们对TLS是如何操作的有了一个大概的认识。</p><p>To Be Continued…</p>]]></content>
      
      
      <categories>
          
          <category> cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tls </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSL and TLS (Part 2): Cryptography</title>
      <link href="/ssl-and-tls-part-2-cryptography/"/>
      <url>/ssl-and-tls-part-2-cryptography/</url>
      
        <content type="html"><![CDATA[<p>在<a href="https://deuterium.fun/ssl-and-tls-part-1-brief-intro/">SSL and TLS (Part 1): Brief Intro</a>中简单介绍了一下SSL/TLS，并以需要解决的三个问题结尾。这三个问题是：</p><ol><li><strong>保密性（Confidentiality）</strong></li><li><strong>真实性（Authenticity）</strong></li><li><strong>完整性（Integrity）</strong></li></ol><p>这篇文章中，我们主要在密码学的角度，来看看如果通过密码学来解决上面的三个问题。</p><h2 id="1-角色登场"><a href="#1-角色登场" class="headerlink" title="1. 角色登场"></a>1. 角色登场</h2><p>在解决问题之前，先看看在一个简单的场景中，都会有哪些角色。</p><p>首先是通信的双方。Alice和Bob通过互联网愉快地沟通。</p><p>由于通信链路的不安全，任何中间节点的人都可以监听Alice和Bob之间的对话，这也是SSL/TLS需要避免的问题。这里，链路中间多了一个中间人（Man in the Middle），我们把他叫做Mallory。</p><p>这样，一个简单的场景包含两个角色三个参与者：两个通信人Alice和Bob，一个中间人Mallory：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/mallory.png"><h2 id="2-对称加密（私钥加密）"><a href="#2-对称加密（私钥加密）" class="headerlink" title="2. 对称加密（私钥加密）"></a>2. 对称加密（私钥加密）</h2><p>就像钥匙和锁一样，一个简单的加密思路就是一把钥匙（secret key，秘钥）既可以将需要加密的文本（plaintext，明文）加密成别人看不出来的文本（ciphertext，密文）；同时也可以使用密钥将密文解密成明文。就像下面的过程：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/symmetric_encryption.png"><p>这就是对称加密算法（symmetric encryption），也叫私钥加密（private-key cryptography）。对称的意思是说一个秘钥即可以加密又可以解密；而私钥意味着，这个秘钥是需要保密的，不能让别人知道。</p><p>这样，如果Alice和Bob之间有一个只有他们两个人才知道的密钥并通过这个密钥进行加密，那么不知道密钥的Mallory是不知道他俩之间的通信内容的。</p><p>对称加密算法历史悠久，著名的就是凯撒密码。这是一种替换加密算法（substitution cipher），即使用字母表后三位的字母来替换明文中的字母。比如将明文中的a替换为d，以此类推。在这种加密算法中，没有密钥（其实也可以说3就是密钥），算法的安全性依赖于加密方法的保密性。如果敌人知道加密算法了，那么也就会解密了。</p><p>随着密码学的发展，一个加密算法需要满足下面的特征才能算是安全的：</p><blockquote><p>一个攻击者即使知道关于加密算法的所有细节，但是不知道密钥，算法仍是安全的。</p></blockquote><p>这时，密文的安全性依赖于密钥。如果密钥是从一个非常大的可选空间中选择的，并且破解这个密钥需要巨大的计算能力，那么这个加密算法就是计算安全的。</p><p>这样，如果我们有一个计算安全的加密算法，我们就解决了第一个问题：<strong>保密性</strong>，只要我们保证密钥的安全即可。</p><p>加密算法可以分为两种：流密码（stream cipher）和分组密码（block cipher）。</p><h3 id="2-1-流密码"><a href="#2-1-流密码" class="headerlink" title="2.1 流密码"></a>2.1 流密码</h3><p>流密码（stream cipher），从名字就可以想象出这种加密算法的加密方式。把加密算法当做一个机器，每来一个字节明文经过这个机器，就输出一个字节的密文，直到所有的明文都经过加密。对于解密，就是过程反过来。</p><p>RC4是一种比较知名的流密码，它的加密过程如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/rc4.png"><p>算法的核心是一个有限长度的随机密钥流（keystream），然后用这个keystream对明文进行异或操作得到密文。解密的时候使用密文亦或keystream就可以得到明文了。</p><p>这个算法的一个特点是每个keystream只能使用一次，重复使用会增大被破解的概率。</p><p>RC4算法现在已经是不安全的了。</p><h3 id="2-2-分组密码"><a href="#2-2-分组密码" class="headerlink" title="2.2 分组密码"></a>2.2 分组密码</h3><p>分组密码（block cipher），就是对一块一块的明文进行加密得到一块一块的密文。现代的分组密码的分组大小一般是128位（16字节）。分组密码也可以看做是一个机器，输入一个分组的明文，机器一顿操作得到一个分组的密文。如果key一致，那么对于不同的明文，都会有唯一对应的密文。</p><p>分组密码有一些缺点：</p><ol><li>只能加密一定长度的明文。使用分组密码需要对变长明文进行一定操作来满足要求（就是下面的padding填充）；</li><li>分组密码是确定的，明文相同，那么对应的密文也相同。这个特性增大了被攻击的概率。</li></ol><p>同时，分组密码也是好多加密方法的基础，比如哈希函数，消息验证码，伪随机数生成器，甚至流密码。</p><p>比较著名的分组密码是AES（Advanced Encryption Standard），分组的大小有128位，192位和256位可供选择。</p><p>在实际应用中，分组密码通常通过分组密码模式（block cipher mode）的方式来使用。模式就是在分组密码的基础上扩展的加密方式，使之方便使用。这里只介绍两个模式：ECB和CBC模式。</p><h4 id="2-2-1-Electronic-Codebook-Mode"><a href="#2-2-1-Electronic-Codebook-Mode" class="headerlink" title="2.2.1 Electronic Codebook Mode"></a>2.2.1 Electronic Codebook Mode</h4><p>ECB，电子密码本模式，是最简单的加密模式。只对满足一定条件长度的明文进行加密，不满足的需要先使用padding方式填充。</p><p>加密时将明文分成一定长度的块，然后分别加密。</p><p>简单是它的缺点。</p><h4 id="2-2-2-Cipher-Block-Chaining-Mode"><a href="#2-2-2-Cipher-Block-Chaining-Mode" class="headerlink" title="2.2.2 Cipher Block Chaining Mode"></a>2.2.2 Cipher Block Chaining Mode</h4><p>CBC，密码块链模式，通过引入初始向量值（initialization vector，IV）的方式来解决分组密码的确定性，这样，即使明文相同，不同时间加密后的密文也不一样：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/cbc.png"><p>初始向量IV的值是随机生成的（<strong>这里，又引出一个问题，怎么生成一个随机值呢？</strong>）。从上图可以看出Chaining是怎么形成的。</p><h3 id="2-3-Padding"><a href="#2-3-Padding" class="headerlink" title="2.3 Padding"></a>2.3 Padding</h3><p>使用分组密码时，如果明文长度不满足条件，需要对明文进行padding操作。比如，AES需要的输入是128位，同时生成128位的密文。如果明文不是128位的倍数，那么就需要对最后一个不足128位的分组进行填充。</p><p>为了能让Bob知道Alice对最后一个分组填充了多少数据，填充的内容不能是随机的。在TLS中，最后一个字节标识填充字节的长度（除了最后一个字节），然后填充字节的内容和长度一致。比如：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/tlb_padding.png"><p>Bob收到密文解密后查看最后一个分组的最后一个字节，内容是3，表示还需要去掉三个字节。这样就得到了明文。</p><h2 id="3-哈希函数"><a href="#3-哈希函数" class="headerlink" title="3. 哈希函数"></a>3. 哈希函数</h2><p>哈希函数（hash function）是一个将任意长的输入转换成固定长度输出的函数，结果也可以简单的叫哈希值（hash）。在编程语言中哈希函数很常用，但是这些都不适合在加密中使用。密码学中的哈希函数应该满足下面的要求：</p><ol><li><strong>Preimage Resistance</strong>：就是说，给定一个哈希值，很难找到一个输入可以生成这个哈希值；</li><li><strong>Second Preimage Resistance</strong>：给定一个输入和对应的哈希值，很难找到一个不同的输入可以生成同样的哈希值；</li><li><strong>Collision Resistance</strong>：很难找到两个不同的输入可以得到相同的哈希值。</li></ol><p>哈希函数对于比较大文件来说很有用。不用直接比较两个大文件，比较两个文件的哈希值就可以了。哈希函数也可以叫做指纹（fingerprints）、消息摘要（message digests）或摘要（digests）。</p><p>现在常用的哈希函数有SHA1，生成160位的结果，推荐使用更强的版本SHA256。</p><h2 id="4-消息验证码"><a href="#4-消息验证码" class="headerlink" title="4. 消息验证码"></a>4. 消息验证码</h2><p>哈希函数可以用于验证数据的完整性，因为对原始数据的一点点修改都会导致哈希值发生很大的变化。但是这需要数据和哈希值分开传输，否则Mallory就可以同时修改数据和对应的哈希值。</p><p>消息验证码（message authentication codes，MAC）在哈希函数的基础上增加了认证，也就是需要有一个hashing key，只有拥有hashing key的人才可以生成一个有效的MAC。</p><p>这样，当一个MAC和数据一起传输的时候，接收者Bob就可以通过hashing key和收到的MAC来检查数据是否被修改过。</p><p>使用哈希函数的消息验证码叫做HMAC（hash-based message authentication code）。实际上，HMAC通过安全的方式将hashing key和数据组合在一起。</p><p>这样，我们就解决了第三个问题：<strong>完整性</strong>。</p><h2 id="5-非对称加密（公钥加密）"><a href="#5-非对称加密（公钥加密）" class="headerlink" title="5. 非对称加密（公钥加密）"></a>5. 非对称加密（公钥加密）</h2><p>对称加密的一个优点是加密速度快。但是当参与通信的人越来越多的时候，对称加密就会有如下的缺点：</p><ol><li>如果同一个群体成员使用相同的秘钥的话，那么随着成员的增加，密钥泄漏的风险也在增加；</li><li>如果不使用同一个密钥，每两个人使用一个密钥，那么随着成员的增加，秘钥将爆炸增长；</li><li>对于无人值守系统不能使用对称加密来保护数据。因为同一个秘钥既可以加密也可以解密。</li></ol><p>非对称加密（asymmetric encryption，public-key cryptography）使用两个秘钥来进行加密和解密，一个秘钥是私有的，叫做私钥（private key），只能由私钥的所有者知道；另一个是公钥（public key），所有人都可以知道。</p><p>如果使用公钥加密，那么只有对应的私钥所有者才能解密；如果使用私钥加密，那么所有人都可以解密，因为私钥对应的公钥是公开的，所有人都可以知道。后一个加密方式可以当做一个数字签名，因为只有私钥持有人才可以用私钥加密。</p><p>非对称加密过程如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/asymmetric_encryption.png"><p>使用非对称加密可以解决大规模群体间的加密问题。任何人都可以使用公钥对私钥持有人发送加密消息；如果对方使用私钥加密，那么你也可以确切地知道对方是谁。</p><p>不过，非对称加密也有缺点：加密很慢，不适合大量数据。</p><p>RSA是现在最出名的非对称加密算法，推荐的秘钥长度是2048位。</p><h2 id="6-数字签名"><a href="#6-数字签名" class="headerlink" title="6. 数字签名"></a>6. 数字签名</h2><p>数字签名（digital signature）是一种密码学方案，用来验证消息的真实性。MAC也可以用来验证消息的真实性，不过需要一个事先准备好私有的hashing key，这就是它的一个缺点。</p><p>通过非对称加密可以达到数字签名的作用。比如，使用RSA的私钥加密，那么只有对应的公钥才能解密：</p><ol><li>计算一个需要签名的文件或数据的哈希值，不管文件或数据多大，哈希值总是固定长度的。比如SHA256的值就是256位；</li><li>将一些基本信息和哈希值放在一起，比如生成这个哈希值的算法；</li><li>将上面的数据使用私钥加密，结果就可以用来验证原始数据的真实性了。</li></ol><p>接收者使用公钥解密，得到使用的哈希函数，用这个函数对文件或数据计算哈希值，如果这个值和接收到的哈希值一致，说明文件没有问题。</p><p>有了数字签名，我们就解决了第二个问题：<strong>真实性</strong>。</p><h2 id="7-生成随机数"><a href="#7-生成随机数" class="headerlink" title="7. 生成随机数"></a>7. 生成随机数</h2><p>密码学中秘钥是一个重要的数据，需要随机生成。这就需要有一个随机数生成器。但是计算机生成的随机数有一定的可预测性，不能生成真随机数（true of random number），只能生成伪随机数（pseudorandom number）。通过seeding来生成伪随机数的过程就是伪随机数生成器（pseudorandom number generator，PRNG）。密码学中对随机数要求更高，需要使用密码学伪随机数生成器（cryptographic pseudorandom number generator，CPRNG）。</p><h2 id="8-混合在一起"><a href="#8-混合在一起" class="headerlink" title="8. 混合在一起"></a>8. 混合在一起</h2><p>前面介绍的内容都可以叫做密码原语（cryptographic primitive）。比如对称加密、哈希函数和非对称加密等。这些加密原语只做一件事情，单独使用不能保证通信的安全。因此，可以将一些密码原语组合在一起使用，形成加密方案或加密协议。</p><p>这里通过一个简单的例子，组合上面的密码原语构成一个加密协议，来保证Alice和Bob之间的通信安全。</p><p>首先Alice和Bob使用对称加密算法对数据进行加密，比如使用AES。这样，Mallory就不能通过观察的方式直接查看内容了。</p><p>但是Mallory可以劫持Alice和Bob之间的通信，篡改通信的内容而不会被Alice和Bob发现。不行，需要改进。</p><p>为了保证数据的完整性，Alice和Bob可以使用只有他们两人知道的hashing key对消息生成一个MAC，将MAC和加密后的密文一起传输，这样Mallory就不能篡改了，不然Alice和Bob就会发现。</p><p>不过Mallory还可以将劫持到的消息丢弃或重放，这时我们可以使用一个序列号，在计算MAC的时候把序列号放进去。这样当我们发现序列号缺失的时候，就知道了数据有丢失；序列号重复的时候，就检测到了一个重放攻击。最后，Alice和Bob使用一个特殊的消息标识会话结束。</p><p>到现在为止都还好，但是Alice和Bob怎么交换秘钥呢？首先可以在对话开始前使用公钥加密的方法传输一些信息，并验证对方是否是想要对话的人。这样就保证了真实性。</p><p>然后就可以通过秘钥交换协议来构造对称加密的秘钥了。常用的秘钥交换协议有RSA和Diffie-Hellman (DH)。</p><p>这样，我们就有了一个安全通信协议：</p><ol><li>第一次握手验证真实性并构造一个加密的秘钥；</li><li>使用秘钥加密数据并构造MAC，保证保密性和完整性；</li><li>会话结束时使用特殊的会话终止消息标识。</li></ol><p>这其实就和SSL/TLS的做法差不多了。</p><p>这篇文章从密码学的角度讨论了一些基本的密码学知识，并讨论如何使用这些基本的密码学方法构造一个可用的安全通信协议。对相应的密码学细节没有深入讨论，只是简单叙述。</p><p>To Be Continued…</p>]]></content>
      
      
      <categories>
          
          <category> cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tls </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSL and TLS (Part 1): Brief Intro</title>
      <link href="/ssl-and-tls-part-1-brief-intro/"/>
      <url>/ssl-and-tls-part-1-brief-intro/</url>
      
        <content type="html"><![CDATA[<p>在万物互联的时代，We don’t connect to the Internet, we <em>are</em> the Internet.</p><p>如此重要的互联网，需要一种协议来保护传输中的信息安全，那就是SSL（Secure Socket Layer）和TLS（Transport Layer Security）。</p><p>这篇文章就简单介绍一下SSL/TLS。</p><h3 id="1-一开始，我们裸奔"><a href="#1-一开始，我们裸奔" class="headerlink" title="1. 一开始，我们裸奔"></a>1. 一开始，我们裸奔</h3><p>当互联网刚开始设计的时候，并没有将安全考虑进去。所以我们的数据都是明文传输的。这在一开始接入的节点很少的时候没有问题，大家依赖君子协议也能很好地工作。</p><p>但是随着接入节点的增多以及使用互联网的业务越来越重要，这种“裸奔”越来越不合适。所以，需要一种方法对传输的数据进行加密。</p><p>未加密时，网络模型如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/network.PNG"><p>既然有五层，那就有多个地方可以完成加密的操作。这样，就引出了第一个问题：哪里加密？</p><h3 id="2-Protect-the-Transport"><a href="#2-Protect-the-Transport" class="headerlink" title="2. Protect the Transport"></a>2. Protect the Transport</h3><p>SSL/TLS是在传输层（Transport Layer）上面应用层（Application Layer）下面对数据进行加密的：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Cryptography/network_tls.PNG"><p>这也是TLS名字的由来。</p><p>从这里也可以看出网络分层的优势：每一层只关注自己的任务即可而不需要操心其他。应用层只需要把数据交给TLS层即可，TLS负责加密，然后数据就这么一层一层下发直到传输到对面节点，对面节点逆序处理，就可以得到原始数据了。</p><p>如果不需要加密，那么去除TLS层，不会影响其他层的工作。</p><p>TLS的主要目标有四个：</p><ol><li><strong>加密安全（Cryptographic Security）</strong>：主要职责，保证通信链路的安全；</li><li><strong>互通性（Interoperability）</strong>：独立开发人员可以通过共同的加密参数使用不同的开发工具开发出可以一起工作的程序或库；</li><li><strong>可扩展性（Extensibility）</strong>：TLS支持多种加密方法，这需要TLS具有可扩展性，方便加密方法的变更；</li><li><strong>高效性（Efficiency）</strong>：由于加密是一个耗时的操作，因此TLS需要把加密的额外性能消耗降到最低。</li></ol><p>接下来，看看SSL和TLS的历史，以及两者之间的关系。</p><h3 id="3-A-Brief-History-of-SSL-TLS"><a href="#3-A-Brief-History-of-SSL-TLS" class="headerlink" title="3. A Brief History of SSL/TLS"></a>3. A Brief History of SSL/TLS</h3><ol><li>1994年网景公司（Netscape）发布SSL协议，由于严重的安全缺陷SSL 1.0没有应用；</li><li>1995年发布SSL 2.0，第一次在网景公司的浏览器上应用；</li><li>1996年发布全新的SSL 3.0版本；</li><li>1996年五月，成立TLS工作组，将SSL标准化；</li><li>1999年，发布TLS 1.0；</li><li>2006年发布TLS 1.1；</li><li>2008年发布TLS 1.2；</li><li>2018年发布TLS 1.3。</li></ol><p>这里，我们使用TLS这个名称。</p><h3 id="4-好的，加密吧"><a href="#4-好的，加密吧" class="headerlink" title="4. 好的，加密吧"></a>4. 好的，加密吧</h3><p>一种加密方法，在正确部署与使用的情况下，需要解决三个问题：</p><ol><li><strong>保密性（Confidentiality）</strong>：消息不能再裸奔了，不能让人一看就知道是啥；</li><li><strong>真实性（Authenticity）</strong>：我要知道你说你是谁是不是真的；</li><li><strong>完整性（Integrity）</strong>：保护传输链路的安全，消息不能被篡改，即使被篡改也能发现。</li></ol><p>为了解决这些问题，我们需要讨论一下密码学。不过只是在较高的层次上来谈论，忽略一些底层的细节，当需要的时候再详细讨论。毕竟，密码学是一门涉及很广也和数学有很多关联的科学。</p><p>To Be Continued…</p>]]></content>
      
      
      <categories>
          
          <category> cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tls </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Web (Part 4): Cookie</title>
      <link href="/go-web-part-4-cookie/"/>
      <url>/go-web-part-4-cookie/</url>
      
        <content type="html"><![CDATA[<p>HTTP是一个无状态的协议。</p><p>这意味着服务器不会记录客户的状态。但是有时候服务器需要知道客户端的状态，这个时候就可以使用Cookie了。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb11.png"><h3 id="1-Cookie-in-Golang"><a href="#1-Cookie-in-Golang" class="headerlink" title="1. Cookie in Golang"></a>1. Cookie in Golang</h3><p>在Go中，定义了Cookie的结构：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Cookie <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name  <span class="token builtin">string</span>    Value <span class="token builtin">string</span>    Path       <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// optional</span>    Domain     <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// optional</span>    Expires    time<span class="token punctuation">.</span>Time <span class="token comment" spellcheck="true">// optional</span>    RawExpires <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// for reading cookies only</span>    <span class="token comment" spellcheck="true">// MaxAge=0 means no 'Max-Age' attribute specified.</span>    <span class="token comment" spellcheck="true">// MaxAge&lt;0 means delete cookie now, equivalently 'Max-Age: 0'</span>    <span class="token comment" spellcheck="true">// MaxAge>0 means Max-Age attribute present and given in seconds</span>    MaxAge   <span class="token builtin">int</span>    Secure   <span class="token builtin">bool</span>    HttpOnly <span class="token builtin">bool</span>    SameSite SameSite    Raw      <span class="token builtin">string</span>    Unparsed <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token comment" spellcheck="true">// Raw text of unparsed attribute-value pairs</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实Cookie就是一个key-value对，用来存储一些简单的信息。也就是上面的字段中，<code>Name</code>和<code>Value</code>是必须的，其余的都是可选的。</p><p><code>Expires</code>和<code>MaxAge</code>都可以用来设置Cookie的有效期。不同在于：</p><ol><li><code>Expires</code>指定了Cookie过期的具体时间，比如一个Cookie会在2020-02-02 02:02:02过期；</li><li><code>MaxAge</code>指定了一个Cookie在被浏览器创建后可以存在的时间，单位是秒；</li><li>几乎所有的浏览器都支持<code>Expires</code>，但是IE6、IE7和IE8不支持<code>MaxAge</code>。</li></ol><p>使用这两种方式不是Go的原因，而是浏览器的支持情况决定的。</p><h3 id="2-设置Cookie"><a href="#2-设置Cookie" class="headerlink" title="2. 设置Cookie"></a>2. 设置Cookie</h3><p>服务器设置Cookie本质上就是将一个字符串写入response中的”Set-Cookie” Header中。而这个写入的字符串，是对Cookie结构的一个序列化结果（就是<code>Cookie.String()</code>方法）。</p><pre class="line-numbers language-go"><code class="language-go">c <span class="token operator">:=</span> http<span class="token punctuation">.</span>Cookie<span class="token punctuation">{</span>    Name<span class="token punctuation">:</span>  <span class="token string">"cookie"</span><span class="token punctuation">,</span>    Value<span class="token punctuation">:</span> <span class="token string">"go web"</span><span class="token punctuation">,</span><span class="token punctuation">}</span>w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Set-Cookie"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打开浏览器可以看到下面的结果：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/cookie_result.png"><p>也可以使用<code>http.SetCookie()</code>方法：</p><pre class="line-numbers language-go"><code class="language-go">c <span class="token operator">:=</span> http<span class="token punctuation">.</span>Cookie<span class="token punctuation">{</span>    Name<span class="token punctuation">:</span>  <span class="token string">"cookie"</span><span class="token punctuation">,</span>    Value<span class="token punctuation">:</span> <span class="token string">"go web"</span><span class="token punctuation">,</span><span class="token punctuation">}</span>http<span class="token punctuation">.</span><span class="token function">SetCookie</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果也是一样，不过要注意，这里使用的是Cookie的指针。</p><h3 id="3-读取Cookie"><a href="#3-读取Cookie" class="headerlink" title="3. 读取Cookie"></a>3. 读取Cookie</h3><p>服务器写入Cookie的Header是<code>Set-Cookie</code>，浏览器向服务器传递Cookie的Header是<code>Cookie</code>，可以通过这个Header来读取浏览器的Cookie：</p><pre class="line-numbers language-go"><code class="language-go">h <span class="token operator">:=</span> r<span class="token punctuation">.</span>Header<span class="token punctuation">[</span><span class="token string">"Cookie"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样获取到的是所有的Cookie切片。为了获取所有的Cookie，还可以使用下面的方法：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Cookies parses and returns the HTTP cookies sent with the request.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">Cookies</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Cookie <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">readCookies</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Header<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面两个方法获得的是所有的Cookie，还可以获取指定的Cookie：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Cookie returns the named cookie provided in the request or</span><span class="token comment" spellcheck="true">// ErrNoCookie if not found.</span><span class="token comment" spellcheck="true">// If multiple cookies match the given name, only one cookie will</span><span class="token comment" spellcheck="true">// be returned.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">Cookie</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Cookie<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> c <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token function">readCookies</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Header<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> c<span class="token punctuation">,</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> ErrNoCookie<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过这会在Cookie不存在的时候返回一个错误。具体使用如下：</p><pre class="line-numbers language-go"><code class="language-go">c<span class="token punctuation">,</span> err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">Cookie</span><span class="token punctuation">(</span><span class="token string">"cookie"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"no such cookie"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-删除一个Cookie"><a href="#4-删除一个Cookie" class="headerlink" title="4. 删除一个Cookie"></a>4. 删除一个Cookie</h3><p>Go里没有删除Cookie的方法，不过可以通过设置一个Cookie有效期来间接删除一个Cookie。</p><p>可以将一个Cookie的<code>Expires</code>设置为一个过去的时间，或者<code>MaxAge</code>设置为负数，就可以删除一个Cookie了：</p><pre class="line-numbers language-go"><code class="language-go">c <span class="token operator">:=</span> http<span class="token punctuation">.</span>Cookie<span class="token punctuation">{</span>    Name<span class="token punctuation">:</span> <span class="token string">"old_cookie"</span><span class="token punctuation">,</span>    MaxAge<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>    Expires<span class="token punctuation">:</span> time<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span>http<span class="token punctuation">.</span><span class="token function">SetCookie</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这篇文章简单介绍了一下在Go中如果使用Cookie，包括添加、读取以及删除。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb12.png"><p>To Be Continued…</p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Web (Part 3): response</title>
      <link href="/go-web-part-3-response/"/>
      <url>/go-web-part-3-response/</url>
      
        <content type="html"><![CDATA[<p>有请求就要有响应，一来一回。这篇文章来看看response的细节。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb9.png"><h3 id="1-从处理器Handler开始"><a href="#1-从处理器Handler开始" class="headerlink" title="1. 从处理器Handler开始"></a>1. 从处理器Handler开始</h3><p>对于Request，在前一篇文章中已经知道了整个的流程。Go会构造一个<code>Request</code>结构体，将接收到的请求中的信息解析到这个结构体中。对于一些信息（比如三个Form）需要手动调用一些函数来填充。这样在之后的处理过程中就可以通过这个<code>Request</code>结构来获取具体的请求信息了。</p><p>那么对于Response，是不是也是这个过程呢？创建一个Response结构，将数据保存在这个结构中，然后返回给客户端？</p><p>不是的，服务端返回响应的时候，使用的是<code>ResponseWriter</code>接口。这一点可以从处理器Handler的定义来看：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>两个参数分别对应响应和请求。</p><p><code>net/http</code>包内部使用<code>response</code>结构来处理响应，由于是非导出类型，不能直接操作，所以通过这个接口，来操作具体的响应。</p><p>而在通过<code>ResponseWriter</code>接口操作<code>response</code>时，传递的也是指向<code>response</code>结构的指针，这也解释了为什么处理器Handler的两个参数一个是值一个是引用，因为底层实际上都是引用。</p><h3 id="2-使用ResponseWriter进行写入"><a href="#2-使用ResponseWriter进行写入" class="headerlink" title="2. 使用ResponseWriter进行写入"></a>2. 使用ResponseWriter进行写入</h3><p>在具体看看Go是怎么处理response的之前，先看看怎么使用<code>ResponseWriter</code>进行写入。</p><p><code>ResponseWriter</code>接口有三个方法：</p><ul><li><code>Write</code>：将指定的数据写入对应的链接作为响应结果；</li><li><code>WriteHeader</code>：用来写入一个HTTP响应码（比如200 OK）；</li><li><code>Header</code>：返回Header，可以用来设置值。</li></ul><p>而<code>response</code>结构实现了这几个方法。</p><h4 id="2-1-Sending-Header"><a href="#2-1-Sending-Header" class="headerlink" title="2.1 Sending Header"></a>2.1 Sending Header</h4><p>可以直接通过<code>WriteHeader()</code>方法来写入HTTP响应码：</p><pre class="line-numbers language-go"><code class="language-go">w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Server"</span><span class="token punctuation">,</span> <span class="token string">"A Test Server"</span><span class="token punctuation">)</span>w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里首先通过<code>Header()</code>方法返回Header然后设置一个值，接下来通过<code>WriteHeader()</code>方法设置HTTP响应码为200。</p><p>通过curl可以看到下面的结果：</p><pre class="line-numbers language-shell"><code class="language-shell">HTTP/1.1 200 OKServer: A Test ServerDate: Thu, 02 Jan 2020 08:18:24 GMTContent-Length: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其实，对于HTTP响应码200来说，不用显示写入，默认就会写入这个响应码。对于<code>WriteHeader</code>方法来说，最常见的应用是写入HTTP的错误码。</p><p>比如，下面的代码实现了一次HTTP重定向：</p><pre class="line-numbers language-go"><code class="language-go">w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Location"</span><span class="token punctuation">,</span> <span class="token string">"http://google.com"</span><span class="token punctuation">)</span>w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span><span class="token number">302</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这时启动浏览器之后就会自动跳到Google的页面了。</p><h4 id="2-2-Rendering-Plain-Text"><a href="#2-2-Rendering-Plain-Text" class="headerlink" title="2.2 Rendering Plain Text"></a>2.2 Rendering Plain Text</h4><p>在之前的文章中，都是通过<code>fmt.Fprintf(w, &quot;hello&quot;)</code>这种方式写入响应的。原理都是一样，也可以使用<code>Write()</code>方法来写入结果：</p><pre class="line-numbers language-go"><code class="language-go">w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"I'm a Test Server"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不同在于，这里的参数是一个<code>[]byte</code>。结果：</p><pre class="line-numbers language-shell"><code class="language-shell">HTTP/1.1 200 OKDate: Thu, 02 Jan 2020 08:27:49 GMTContent-Length: 17Content-Type: text/plain; charset=utf-8I'm a Test Server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出：</p><ul><li>对于200响应码不用手动写入；</li><li><code>Content-Length</code>字段标识了响应的长度。</li></ul><h4 id="2-3-Rendering-JSON"><a href="#2-3-Rendering-JSON" class="headerlink" title="2.3 Rendering JSON"></a>2.3 Rendering JSON</h4><p>上面写入的响应是一个纯文本。同样可以对响应写入JSON格式的数据：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>        Name <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>        Age  <span class="token builtin">int</span>    <span class="token string">`json:"age"`</span>    <span class="token punctuation">}</span>    data<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>User<span class="token punctuation">{</span><span class="token string">"Valineliu"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json"</span><span class="token punctuation">)</span>    w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意需要通过<code>Header()</code>方法将内容类型设置成<code>application/json</code>，不然就是纯文本了。结果：</p><pre class="line-numbers language-shell"><code class="language-shell">HTTP/1.1 200 OKContent-Type: application/jsonDate: Thu, 02 Jan 2020 08:32:49 GMTContent-Length: 29{"name":"Valineliu","age":25}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然除了JSON格式外，还可以写入XML等格式。</p><h4 id="2-4-Serving-a-File"><a href="#2-4-Serving-a-File" class="headerlink" title="2.4 Serving a File"></a>2.4 Serving a File</h4><p>还可以发送一个文件：</p><pre class="line-numbers language-go"><code class="language-go">http<span class="token punctuation">.</span><span class="token function">ServeFile</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token string">"luffy.jpg"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过这个函数就可以了。打开浏览器就可以看到结果。使用curl结果：</p><pre class="line-numbers language-shell"><code class="language-shell">HTTP/1.1 200 OKAccept-Ranges: bytesContent-Length: 54146Content-Type: image/jpegLast-Modified: Wed, 06 Nov 2019 01:50:35 GMTDate: Thu, 02 Jan 2020 08:39:48 GMT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-看看具体发生了什么"><a href="#3-看看具体发生了什么" class="headerlink" title="3. 看看具体发生了什么"></a>3. 看看具体发生了什么</h3><p>除了上面的那些类型的内容外，还可以返回一个HTML模板，这里就不详细说了。</p><p>接下来看看<code>net/http</code>包是怎么通过<code>ResponseHeader</code>操作<code>response</code>的。</p><p><code>response</code>定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> response <span class="token keyword">struct</span> <span class="token punctuation">{</span>    conn             <span class="token operator">*</span>conn    req              <span class="token operator">*</span>Request <span class="token comment" spellcheck="true">// request for this response</span>    reqBody          io<span class="token punctuation">.</span>ReadCloser    w  <span class="token operator">*</span>bufio<span class="token punctuation">.</span>Writer    <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里只是一部分的字段，原来这个<code>response</code>结构竟然还有请求的字段。</p><p>当链接收到一个请求后，会调用<code>server()</code>方法进行处理，简略的过程如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Serve a new connection.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">serve</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>    w<span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">readRequest</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>    <span class="token operator">...</span>    req <span class="token operator">:=</span> w<span class="token punctuation">.</span>req    <span class="token operator">...</span>    serverHandler<span class="token punctuation">{</span>c<span class="token punctuation">.</span>server<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> w<span class="token punctuation">.</span>req<span class="token punctuation">)</span>    <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先通过<code>readRequest()</code>方法获得<code>response</code>，这个时候里面的<code>Resquest</code>已经构造好了。之后就可以使用<code>w</code>和<code>w.req</code>作为参数调用<code>ServeHTTP</code>了。</p><p>而在<code>readRequest()</code>方法中：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Read next request from connection.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">readRequest</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>    req<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">readRequest</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>bufr<span class="token punctuation">,</span> keepHostHeader<span class="token punctuation">)</span>    <span class="token operator">...</span>    w <span class="token operator">=</span> <span class="token operator">&amp;</span>response<span class="token punctuation">{</span>        conn<span class="token punctuation">:</span>          c<span class="token punctuation">,</span>        cancelCtx<span class="token punctuation">:</span>     cancelCtx<span class="token punctuation">,</span>        req<span class="token punctuation">:</span>           req<span class="token punctuation">,</span>        reqBody<span class="token punctuation">:</span>       req<span class="token punctuation">.</span>Body<span class="token punctuation">,</span>        handlerHeader<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span>Header<span class="token punctuation">)</span><span class="token punctuation">,</span>        contentLength<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>        closeNotifyCh<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// We populate these ahead of time so we're not</span>        <span class="token comment" spellcheck="true">// reading from req.Header after their Handler starts</span>        <span class="token comment" spellcheck="true">// and maybe mutates it (Issue 14940)</span>        wants10KeepAlive<span class="token punctuation">:</span> req<span class="token punctuation">.</span><span class="token function">wantsHttp10KeepAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        wantsClose<span class="token punctuation">:</span>       req<span class="token punctuation">.</span><span class="token function">wantsClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> isH2Upgrade <span class="token punctuation">{</span>        w<span class="token punctuation">.</span>closeAfterReply <span class="token operator">=</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span>    w<span class="token punctuation">.</span>cw<span class="token punctuation">.</span>res <span class="token operator">=</span> w    w<span class="token punctuation">.</span>w <span class="token operator">=</span> <span class="token function">newBufioWriterSize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">.</span>cw<span class="token punctuation">,</span> bufferBeforeChunkingSize<span class="token punctuation">)</span>    <span class="token keyword">return</span> w<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这个<code>response</code>的整个构造过程。这样，后序的处理就可以通过<code>ResponseWriter</code>接口来处理了。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb10.png"><p>To Be Continued…</p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Year Reading in 2019</title>
      <link href="/year-reading-in-2019/"/>
      <url>/year-reading-in-2019/</url>
      
        <content type="html"><![CDATA[<p>又是一年岁暮时。</p><p>最近才意识到，便随着2019年的过去，一个时代也过去了。</p><p>年初定的超过2017年的读书计划，接近但是没有完成（2017年120本，2019年113本，2018年太惨了28本）。</p><p>一个华丽的柱状图：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Life/reading_2019.png" alt="奥古斯都月太惨了"></p><p>距离2019年结束还有五天，剩下的时间最多只能看一本了。</p><p>对于今年还算满意，按分类统计：</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Life/reading_category_2019.png" alt="我还是爱看故事哇"></p><h2 id="读阿婆，看人性"><a href="#读阿婆，看人性" class="headerlink" title="读阿婆，看人性"></a>读阿婆，看人性</h2><blockquote><p>人性在哪里都一样。</p></blockquote><p>年初的时候，计算用半年的时间看完阿婆的所有小说，一共八十多本。</p><p>结果我失败了（只看了30多本）。</p><p>失败的原因不是我不能坚持下来，是因为大名鼎鼎的阿婆也有好多一般甚至不咋地的书。</p><p>但这不能磨灭我对阿婆的爱！</p><p>阿婆的小说深入人性，绝大多数谋杀都是为了自己的私欲（也有个别的不是比如东方快车）。场景布局大多在不大的空间中，比如庄园、轮船或火车等。一开始就疑云密布，稍不注意就会被误导，结局又往往大出所料。</p><p>其中，我觉得精彩的有：</p><img src="http://img3.doubanio.com/view/subject/l/public/s26849345.jpg" style="zoom:20%"><p><a href="https://book.douban.com/subject/24859822/" target="_blank" rel="noopener">无人生还</a></p><p>★★★★★8.6</p><p>人在面临死亡的时候很难冷静下来，从而作出错误的决定。勿以恶小。</p><img src="http://img1.doubanio.com/view/subject/l/public/s1765799.jpg" style="zoom:37%"><p><a href="https://book.douban.com/subject/1827374/" target="_blank" rel="noopener">东方快车谋杀案</a></p><p>★★★★★9.0</p><p>心理描写过于精彩。</p><img src="http://img1.doubanio.com/view/subject/l/public/s27027698.jpg" style="zoom:22%"><p><a href="https://book.douban.com/subject/25697546/" target="_blank" rel="noopener">尼罗河上的惨案</a></p><p>★★★★★8.6</p><p>许多伟大的爱情都是悲剧。重要的不是过去，而是未来。</p><img src="http://img1.doubanio.com/view/subject/l/public/s26716169.jpg" style="zoom:23%"><p><a href="https://book.douban.com/subject/24737009/" target="_blank" rel="noopener">ABC谋杀案</a></p><p>★★★★☆8.3</p><p>一系列谋杀是为了掩盖另一个谋杀。</p><img src="http://img9.doubanio.com/view/subject/l/public/s26841474.jpg" style="zoom:23%"><p><a href="https://book.douban.com/subject/24852594/" target="_blank" rel="noopener">底牌</a></p><p>★★★★☆8.0</p><p>波洛从人性与性格方面入手以及分析真的是太精彩了。还有，犯罪不能纵容，不然会越来越严重。</p><img src="http://img3.doubanio.com/view/subject/l/public/s27988902.jpg" style="zoom:23%"><p><a href="https://book.douban.com/subject/26292535/" target="_blank" rel="noopener">帷幕</a></p><p>★★★★★8.9</p><p>一生都在制止谋杀的人在最后亲自谋杀了一个人渣。有时候，法律也是很无力。</p><h2 id="认真，不麻烦别人"><a href="#认真，不麻烦别人" class="headerlink" title="认真，不麻烦别人"></a>认真，不麻烦别人</h2><blockquote><p>我喜欢认真的人，与此同时最害怕那些把自己的欲望放在第一位、给别人添了麻烦也毫不在乎的人。哪怕他们再遵纪守法，不顾他人感受并且不以为然这一点仍让我觉得可怕，不想和他们做朋友。我总在想，这个世界全靠认真的人才得以运转。</p></blockquote><p>有那么四个人，他们是“十恶不赦”的银行劫匪，但又是四个最可爱的人。他们处处为他人着想，又努力维持正义。</p><p>伊坂幸太郎说他喜欢认真不给别人带来麻烦的人。我觉得，不麻烦别人是最大的美德了吧。</p><p>这是我喜欢伊坂幸太郎小说的一个原因。它给我带来快乐，让我思考，最后成为指导以后做事的准则。</p><p>当然，还有那暖暖的句子啊。</p><blockquote><p>面对一头剃了毛的羊，上天都会让吹到它身上的风变得温柔。</p></blockquote><img src="http://img1.doubanio.com/view/subject/l/public/s33490929.jpg" style="zoom:25%"><p><a href="https://book.douban.com/subject/30157645/" target="_blank" rel="noopener">阳光劫匪日常与袭击</a></p><p>★★★★☆8.2</p><img src="http://img9.doubanio.com/view/subject/l/public/s29787404.jpg" style="zoom:47%"><p><a href="https://book.douban.com/subject/27609210/" target="_blank" rel="noopener">阳光劫匪倒转地球</a></p><p>★★★★☆8.2</p><img src="http://img1.doubanio.com/view/subject/l/public/s33490927.jpg" style="zoom:25%"><p><a href="https://book.douban.com/subject/30203733/" target="_blank" rel="noopener">阳光劫匪友情测试</a></p><p>★★★★☆8.2</p><h2 id="世界很残酷，但还是活着吧"><a href="#世界很残酷，但还是活着吧" class="headerlink" title="世界很残酷，但还是活着吧"></a>世界很残酷，但还是活着吧</h2><p>上班后一年就磨灭了上学时对工作的种种美好的幻想。</p><p>这个世界，真的太残酷了。</p><p>996，ICU，还有那神奇的251天。</p><p>不过，还是要保持乐观哇，活着，就有希望。</p><img src="http://img3.doubanio.com/view/subject/l/public/s29053580.jpg" style="zoom:80%"><p><a href="https://book.douban.com/subject/4913064/" target="_blank" rel="noopener">活着</a></p><p>★★★★★9.4</p><p>死亡永远不是最可怕的，最可怕的是死亡带走身边所有重要的人，独留自己一个。再读《活着》，悲伤double。</p><img src="http://img3.doubanio.com/view/subject/l/public/s24575140.jpg" style="zoom:80%"><p><a href="https://book.douban.com/subject/4760224/" target="_blank" rel="noopener">许三观卖血记</a></p><p>★★★★★9.0</p><p>小人物艰难生存。我们都是小人物。</p><img src="http://img9.doubanio.com/view/subject/l/public/s29864884.jpg" style="zoom:25%"><p><a href="https://book.douban.com/subject/30259153/" target="_blank" rel="noopener">第七天</a></p><p>★★★★☆7.6</p><p>小人物的种种不幸，就像活生生发生在身边。 如果真的有那个地方，那我们是不是可以死后见想见的人，说想说的话，尽情弥补生前的各种悔恨。 不过，那是死无葬身之地。 人间不值得，人间又值得。珍惜吧。</p><img src="http://img1.doubanio.com/view/subject/l/public/s33463759.jpg" style="zoom:50%"><p><a href="https://book.douban.com/subject/34434309/" target="_blank" rel="noopener">82年生的金智英</a></p><p>★★★★☆7.9</p><p>一篇表面是小说本质是韩国现代女性生存现状的报告。作为男生看了也会对这种种的不平等深感震惊与羞愧。我我我，也有责任。</p><img src="http://img9.doubanio.com/view/subject/l/public/s29952694.jpg" style="zoom:25%"><p><a href="https://book.douban.com/subject/30374817/" target="_blank" rel="noopener">小偷家族</a></p><p>★★★★★8.6</p><p>小偷家族没有偷来什么贵重的东西，但是却偷来了最珍贵的亲情，那些在亲人那里得不到的亲情。又是小人物的艰难生存。</p><h2 id="保持好奇，不停学习"><a href="#保持好奇，不停学习" class="headerlink" title="保持好奇，不停学习"></a>保持好奇，不停学习</h2><blockquote><p>心智是宇宙间最宝贵的东西。</p></blockquote><p>克拉克在《太空漫游中》这么说道。我直到现在，才看了大名鼎鼎的《太空漫游》系列。</p><p>这是什么神仙想象！</p><p>与之类似的，是《猎魔人》。</p><blockquote><p>选取一个有趣的时间段，特别是大动荡时期：战争、宗教冲突、政治压迫、革命等等，把你的主角丢进这个女巫的坩埚，让他在里面寻找出路，让他做出抉择，让他因错误的选择而饱受磨难，让他接受洗礼，让他成熟，让他找到或是失去他的真爱、良知、理想和人性。</p></blockquote><p>《猎魔人》作者安德烈·斯帕克沃斯基这样描述历史奇幻小说的创作方法。</p><p>不管是科幻还是奇幻，都需要大量的知识来支撑庞大的背景设定。出于现实而又高于现实，丰富的想象力与创造力必不可少。</p><p>阅读这样的作品，多多少少能提高一点点创造力吧。</p><p>这个世界很奇妙，很有趣，也很复杂。</p><p>但我好想一点点弄懂啊，了解缤纷世界背后的故事。</p><p>只能不断学习。</p><p>阅读《费恩曼物理学讲义》，析万物之理。</p><p>阅读《经济学原理》，明白生活背后的道理。</p><p>看《地理学与生活》，重拾小时候看地图的乐趣。</p><p>不过这三本我都没看完，，，sad。</p><img src="http://img3.doubanio.com/view/subject/l/public/s32323941.jpg" style="zoom:25%"><p><a href="https://book.douban.com/subject/30481003/" target="_blank" rel="noopener">“太空漫游”四部曲</a></p><p>★★★★★9.0</p><img src="http://img3.doubanio.com/view/subject/l/public/s27987690.jpg" style="zoom:40%"><p><a href="https://book.douban.com/subject/26267087/" target="_blank" rel="noopener">猎魔人1：白狼崛起</a></p><p>★★★★★8.6</p><h2 id="其实还有很多"><a href="#其实还有很多" class="headerlink" title="其实还有很多"></a>其实还有很多</h2><p>除了上面那些，2019年也读了很多别的书。比如托尔斯泰的两部大部头《战争与和平》《安娜·卡列尼娜》，2020年，计划多读这样的名著。</p><p>今年，也开始记录计算机专业书籍了。基础知识需要牢固，希望2020年继续巩固自己的知识网络。</p><p>自己之前一直不屑的howto类书籍，今年也开始看了而且真香，明年继续，形成自己的方法论，这比埋头苦干更重要。</p><h2 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h2><p>最后，附上阅读清单。</p><h3 id="一月"><a href="#一月" class="headerlink" title="一月"></a>一月</h3><ol><li><p>《人性记录》阿加莎</p></li><li><p>《云中命案》阿加莎</p></li><li><p>《万圣节前夜的谋杀》阿加莎</p></li><li><p>《大象的证词》阿加莎</p></li><li><p>《寓所谜案》阿加莎</p></li><li><p>《七面钟之谜》阿加莎</p></li><li><p>《悬崖山庄奇案》阿加莎</p></li><li><p>《藏书室女尸之谜》阿加莎</p></li><li><p>《底牌》阿加莎</p></li><li><p>《天涯过客》阿加莎</p></li><li><p>《长夜》阿加莎</p></li><li><p>《怪屋》阿加莎</p></li><li><p>《魔手》阿加莎</p></li><li><p>《古墓之谜》阿加莎</p></li><li><p>《沉默的证人》阿加莎</p></li></ol><h3 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h3><ol start="16"><li><p>《高尔夫球场命案》阿加莎</p></li><li><p>《流浪地球》刘慈欣</p></li><li><p>《桑苏西来客》阿加莎</p></li><li><p>《阳光下的罪恶》阿加莎</p></li><li><p>《谋杀启事》阿加莎</p></li><li><p>《空幻之屋》阿加莎</p></li><li><p>《命案目睹记》阿加莎</p></li><li><p>《葬礼之后》阿加莎</p></li><li><p>《MySQL必知必会》Ben Forta</p></li><li><p>《鸽群中的猫》阿加莎</p></li></ol><h3 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h3><ol start="26"><li><p>《他们来到巴格达》阿加莎</p></li><li><p>《祖先》易中天</p></li><li><p>《国家》易中天</p></li><li><p>《帷幕》阿加莎</p></li><li><p>《奠基者》易中天</p></li><li><p>《青春志》易中天</p></li><li><p>《从春秋到战国》易中天</p></li><li><p>《百家争鸣》易中天</p></li><li><p>《秦并天下》易中天</p></li><li><p>《汉武的帝国》易中天</p></li><li><p>《阳光劫匪友情测试》伊坂幸太郎</p></li></ol><h3 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h3><ol start="37"><li><p>《作死的兔子大全集》安迪 莱利</p></li><li><p>《两汉两罗马》易中天</p></li><li><p>《阳光劫匪倒转地球》伊坂幸太郎</p></li><li><p>《三国纪》易中天</p></li><li><p>《魏晋风度》易中天</p></li><li><p>《南朝，北朝》易中天</p></li><li><p>《隋唐定局》易中天</p></li></ol><h3 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h3><ol start="44"><li><p>《禅宗兴起》易中天</p></li><li><p>《女皇武则天》易中天</p></li><li><p>《安史之乱》易中天</p></li><li><p>《大宋革新》易中天</p></li><li><p>《王安石变法》易中天</p></li><li><p>《风流南宋》易中天</p></li><li><p>《铁血蒙元》易中天</p></li><li><p>《朱明王朝》易中天</p></li><li><p>《阳光劫匪日常与袭击》伊坂幸太郎</p></li></ol><h3 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h3><ol start="53"><li><p>《H庄园的午餐》阿加莎</p></li><li><p>《金色梦乡》伊坂幸太郎</p></li><li><p>《棋王》阿城</p></li><li><p>《许三观卖血记》余华</p></li><li><p>《兄弟上》余华</p></li></ol><h3 id="七月"><a href="#七月" class="headerlink" title="七月"></a>七月</h3><ol start="58"><li><p>《兄弟下》余华</p></li><li><p>《在细雨中呼喊》余华</p></li><li><p>《第七天》余华</p></li><li><p>《大明王朝的七张面孔》张宏杰</p></li><li><p>《黄昏里的男孩》余华</p></li><li><p>《小狗钱钱》博多 费舍尔</p></li><li><p>《战栗》余华</p></li><li><p>《没有一条道路是重复的》余华</p></li></ol><h3 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h3><ol start="66"><li><p>《野性的呼唤》杰克 伦敦</p></li><li><p>《小狗钱钱2》博多 费舍尔</p></li><li><p>《战争与和平》托尔斯泰</p></li></ol><h3 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h3><ol start="69"><li><p>《海边理发店》荻原浩</p></li><li><p>《七堂极简物理课》卡洛 罗韦利</p></li><li><p>《代码整洁之道：程序员的职业素养》罗伯特 马丁</p></li><li><p>《安娜·卡列尼娜》托尔斯泰</p></li><li><p>《活着》余华</p></li><li><p>《给青年的十二封信》朱光潜</p></li><li><p>《牧羊少年的奇幻之旅》保罗 柯艾略</p></li><li><p>《Go语言实战》</p></li><li><p>《半小时漫画中国史1》陈磊</p></li><li><p>《半小时漫画中国史2》陈磊</p></li><li><p>《半小时漫画中国史3》陈磊</p></li><li><p>《半小时漫画世界史》陈磊</p></li><li><p>《哈佛极简中国史》阿尔伯特 克雷格</p></li></ol><h3 id="十月"><a href="#十月" class="headerlink" title="十月"></a>十月</h3><ol start="82"><li><p>《博物馆里的极简中国史》张经纬</p></li><li><p>《两个故宫的离合》夜岛刚</p></li><li><p>《Redis 4.x Cookbook 》</p></li><li><p>《借镜杀人》阿加莎</p></li><li><p>《时间之书》余世存 老树</p></li><li><p>《我在故宫修文物》</p></li><li><p>《这里是中国》</p></li><li><p>《红墙黄瓦》张克群</p></li><li><p>《半小时漫画唐诗》陈磊</p></li><li><p>《半小时漫画唐诗2》陈磊</p></li><li><p>《万古江河》许倬云</p></li><li><p>《这样读书就够了》赵周</p></li><li><p>《半小时漫画经济学》陈磊</p></li><li><p>《半小时漫画经济学2》陈磊</p></li></ol><h3 id="十一月"><a href="#十一月" class="headerlink" title="十一月"></a>十一月</h3><ol start="96"><li><p>《四魔头》阿加莎</p></li><li><p>《地理的故事》房龙</p></li><li><p>《何以中国》许宏</p></li><li><p>《日本人为何选择了战争》加藤阳子</p></li><li><p>《思维导图》胡雅茹</p></li><li><p>《万物发明指南》瑞安 诺思</p></li><li><p>《2001：太空漫游》克拉克</p></li><li><p>《如何高效学习》斯科特 杨</p></li><li><p>《2010：太空漫游》克拉克</p></li></ol><h3 id="十二月"><a href="#十二月" class="headerlink" title="十二月"></a>十二月</h3><ol start="105"><li><p>《2061：太空漫游》克拉克</p></li><li><p>《3001：太空漫游》克拉克</p></li><li><p>《82年生的金智英》赵南柱</p></li><li><p>《山茶文具店》小川糸</p></li><li><p>《少帅》张爱玲</p></li><li><p>《Go Web编程》</p></li><li><p>《猎魔人1：白狼崛起》斯帕克沃斯基</p></li><li><p>《小偷家族》是枝裕和</p></li><li><p>《猎魔人2：宿命之剑》斯帕克沃斯基</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Web (Part 2): Request</title>
      <link href="/go-web-part-2-request/"/>
      <url>/go-web-part-2-request/</url>
      
        <content type="html"><![CDATA[<p>在了解了使用<code>net/http</code>构建go web服务之后，这篇文章深入了解一下在Go中如何处理一个请求。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb7.png"><h3 id="1-请求包含什么"><a href="#1-请求包含什么" class="headerlink" title="1. 请求包含什么"></a>1. 请求包含什么</h3><p>HTTP Message有Request和Response两种。这里详细看看Request Message，一个请求消息的格式如下：</p><pre class="line-numbers language-shell"><code class="language-shell">method request-URL versionheadersentity-body<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Go中的<code>net/http</code>包提供了一个用于表示HTTP请求消息的结构<code>Reqeust</code>。<code>Request</code>将上面请求消息的内容经过分析后存储在不同的字段中，还包括一系列有用的方法。主要的字段有：</p><ul><li>URL</li><li>Header</li><li>Body</li><li>Form, PostForm, MultipartForm</li></ul><p>除了这些字段，还可以使用<code>Request</code>的一些方法处理请求中的cookie等。</p><h3 id="2-URL"><a href="#2-URL" class="headerlink" title="2. URL"></a>2. URL</h3><p><code>Request</code>中的<code>URL</code>字段可以存储请求中URL的信息，在<code>Reqeuest</code>中的<code>URL</code>字段是一个指向<code>net/url</code>包中<code>URL</code>结构的指针，<code>URL</code>结构主要字段如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> URL <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Scheme     <span class="token builtin">string</span>    User       <span class="token operator">*</span>Userinfo <span class="token comment" spellcheck="true">// username and password information</span>    Host       <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// host or host:port</span>    Path       <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// path (relative paths may omit leading slash)</span>    RawPath    <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// encoded path hint (see EscapedPath method)</span>    RawQuery   <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// encoded query values, without '?'</span>    Fragment   <span class="token builtin">string</span>    <span class="token comment" spellcheck="true">// fragment for references, without '#'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>URL的一般格式是这样的：</p><pre class="line-numbers language-shell"><code class="language-shell">scheme://[userinfo@]host/path[?query][#fragment]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中[]中的是可选的信息。</p><p>在<code>net/url</code>包中有解析URL的函数<code>Parse()</code>和<code>ParseRequestURI()</code>，两者都是将传进来的URL解析成一个<code>URL</code>结构并返回这个<code>URL</code>的指针。</p><p>比如这个URL：<a href="https://book.douban.com/people/valineliu/collect?start=30&amp;sort=time&amp;rating=all&amp;filter=all&amp;mode=list#here" target="_blank" rel="noopener">https://book.douban.com/people/valineliu/collect?start=30&amp;sort=time&amp;rating=all&amp;filter=all&amp;mode=list#here</a></p><p>解析之后的结果如下：</p><table><thead><tr><th>Field</th><th>Value</th></tr></thead><tbody><tr><td><code>Scheme</code></td><td>https</td></tr><tr><td><code>Host</code></td><td>book.douban.com</td></tr><tr><td><code>Path</code></td><td>/people/valineliu/collect</td></tr><tr><td><code>RawQuery</code></td><td>start=0&amp;sort=time&amp;rating=all&amp;filter=all&amp;mode=list</td></tr><tr><td><code>Fragment</code></td><td>here</td></tr></tbody></table><p><code>Parse()</code>和<code>ParseRequestURI()</code>不解析<code>RawPath</code>字段，需要调用<code>URL.EscapedPath()</code>函数来获得这个字段值。</p><p><code>RawQuery</code>字段包含了没有解析的查询参数，可以通过对这个参数的解析获得URL中的查询参数，不过可以直接使用<code>Request</code>结构中的<code>Form</code>字段来获取，后面再详细介绍。</p><p>还有一个需要注意的问题就是，如果请求是通过浏览器发送的话，程序就得不到<code>Fragment</code>字段，因为浏览器会截断<code>Fragment</code>，与<code>net/http</code>库无关。</p><h3 id="3-Header"><a href="#3-Header" class="headerlink" title="3. Header"></a>3. Header</h3><p>HTTP请求和响应消息都有一个Header结构，在go中，<code>net/http</code>包中有一个<code>Header</code>结构来存储Header结构。</p><p><code>Header</code>本质上就是一个<code>map</code>，定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Header <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不过值是一个<code>[]string</code>，也就是说，对一个key可以有多个值。</p><p><code>Header</code>有四个基本方法，可以方便地对内容进行操作，分别是<code>Add</code>, <code>Del</code>, <code>Set</code>, <code>Get</code>。其中<code>Set</code>方法会对已有的值进行覆盖。</p><p>除了<code>Get</code>方法外，还可以直接访问<code>Header</code>中某个key的值：</p><pre class="line-numbers language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Header<span class="token punctuation">[</span><span class="token string">"Accept-Encoding"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就像访问一个<code>map</code>一样。这种方式和<code>Get</code>的区别在于，直接访问得到的是一个字符串切片，而使用<code>Get</code>方法得到的是所有的值用逗号分割的字符串：</p><pre class="line-numbers language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Header<span class="token punctuation">[</span><span class="token string">"Accept-Encoding"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"Accept-Encoding"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">[gzip, deflate, br]gzip, deflate, br<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-Body"><a href="#4-Body" class="headerlink" title="4. Body"></a>4. Body</h3><p><code>Request</code>中的<code>Body</code>不仅是请求的Body，也是响应的Body，这里不展开描述。</p><p><code>Body</code>是一个<code>io.ReaderCloser</code>接口，意味着可以调用<code>Read</code>和<code>Close</code>两个方法。下面的例子描述了如何读取请求中的Body：</p><pre class="line-numbers language-go"><code class="language-go">length <span class="token operator">:=</span> r<span class="token punctuation">.</span>ContentLengthbody <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span>r<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>Request</code>中有一个<code>ContentLength</code>字段，这个字段记录了Body的长度，可以通过这个字段指定长度来读取Body中的内容。</p><p>GET请求没有Body，所以需要一个POST请求，可以使用curl：</p><pre class="line-numbers language-shell"><code class="language-shell">curl -id "start=30&sort=time&rating=all&filter=all&mode=list" localhost:8080/world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就可以得到Body了：</p><pre class="line-numbers language-shell"><code class="language-shell">start=30&sort=time&rating=all&filter=all&mode=list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-Form-PostForm-amp-MultipartForm"><a href="#5-Form-PostForm-amp-MultipartForm" class="headerlink" title="5. Form, PostForm &amp; MultipartForm"></a>5. Form, PostForm &amp; MultipartForm</h3><p>前面几个字段在请求达到服务器的时候就通过一定的流程解析出来了，而<code>Request</code>中的这几个关于Form的字段不是自动解析的，需要手动调用各自对应的函数来解析。</p><h4 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h4><p>这几个字段的定义如下：</p><pre class="line-numbers language-go"><code class="language-go">Form url<span class="token punctuation">.</span>ValuesPostForm url<span class="token punctuation">.</span>ValuesMultipartForm <span class="token operator">*</span>multipart<span class="token punctuation">.</span>Form<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中<code>Form</code>和<code>PostForm</code>类型一样：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Values <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也就是一个<code>map</code>，key是字符串，而值是一个字符串切片。即，对于一个key来说，可以有多个值。</p><p><code>MultipartForm</code>的类型不一样：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Form <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Value <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>    File  <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>FileHeader<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>多了一个<code>File</code>字段，这是因为<code>MultipartForm</code>还需要存储文件。</p><p>请求中的参数可以在URL中，也就是这种格式：<code>/people/valineliu/collect?start=30&amp;sort=time</code>，也可以在Body中，比如：<code>curl -id &quot;start=40&quot; localhost:8080/world</code>。同时请求消息中Body中的数据可以通过不同的格式编码发送给服务器。其中常用的有<code>application/x-www-form-urlencoded</code>和<code>multipart/form-data</code>。前一种格式可以将Body中的参数按照URL中参数的格式编码，而后者会将数据编码成一条MIME报文。</p><p>这就导致，三种Form字段在不同的编码方式下能够获得的数据也是不一样的。</p><h4 id="5-2-Form-amp-PostForm"><a href="#5-2-Form-amp-PostForm" class="headerlink" title="5.2 Form &amp; PostForm"></a>5.2 Form &amp; PostForm</h4><p>为了获得<code>Form</code>和<code>PostForm</code>字段，需要调用<code>ParseForm</code>方法：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">ParseForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> err <span class="token builtin">error</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>PostForm <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> r<span class="token punctuation">.</span>Method <span class="token operator">==</span> <span class="token string">"POST"</span> <span class="token operator">||</span> r<span class="token punctuation">.</span>Method <span class="token operator">==</span> <span class="token string">"PUT"</span> <span class="token operator">||</span> r<span class="token punctuation">.</span>Method <span class="token operator">==</span> <span class="token string">"PATCH"</span> <span class="token punctuation">{</span>            r<span class="token punctuation">.</span>PostForm<span class="token punctuation">,</span> err <span class="token operator">=</span> <span class="token function">parsePostForm</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> r<span class="token punctuation">.</span>PostForm <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            r<span class="token punctuation">.</span>PostForm <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span>Values<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>Form <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>PostForm<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>            r<span class="token punctuation">.</span>Form <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span>Values<span class="token punctuation">)</span>            <span class="token function">copyValues</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Form<span class="token punctuation">,</span> r<span class="token punctuation">.</span>PostForm<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">var</span> newValues url<span class="token punctuation">.</span>Values        <span class="token keyword">if</span> r<span class="token punctuation">.</span>URL <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> e <span class="token builtin">error</span>            newValues<span class="token punctuation">,</span> e <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">ParseQuery</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>RawQuery<span class="token punctuation">)</span>            <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                err <span class="token operator">=</span> e            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> newValues <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            newValues <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span>Values<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> r<span class="token punctuation">.</span>Form <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            r<span class="token punctuation">.</span>Form <span class="token operator">=</span> newValues        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">copyValues</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Form<span class="token punctuation">,</span> newValues<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> err<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数是幂等的，也就是多次调用效果一样。从这个解析过程可以发现：</p><ul><li>函数首先解析<code>PostForm</code>字段，然后解析<code>Form</code>字段；</li><li>而在<code>parsePostForm()</code>函数中，只对Body中<code>application/x-www-form-urlencoded</code>编码的参数解析，其余编码格式下<code>PostForm</code>字段为空；</li><li><code>Form</code>中包含<code>PostForm</code>中的信息，而且<code>PostForm</code>中的信息优先级高；</li><li>URL中的参数只会到被解析到<code>Form</code>字段中。</li></ul><p>下面的例子演示了上面的分析：</p><pre class="line-numbers language-go"><code class="language-go">r<span class="token punctuation">.</span><span class="token function">ParseForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span>Form<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span>PostForm<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用curl模拟一个请求：</p><pre class="line-numbers language-shell"><code class="language-shell">curl -id "start=30&mode=list" "localhost:8080/world?start=40&sort=time"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">map[mode:[list] sort:[time] start:[30 40]]map[mode:[list] start:[30]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一个<code>map</code>是<code>Form</code>，第二个是<code>PostForm</code>，从结果可以看到两者的区别。</p><h4 id="5-3-MultipartForm"><a href="#5-3-MultipartForm" class="headerlink" title="5.3 MultipartForm"></a>5.3 MultipartForm</h4><p>对于<code>MultipartForm</code>，需要调用<code>ParseMultipartForm</code>方法，这个方法会在需要的时候（也就是<code>Form</code>和<code>PostForm</code>为<code>nil</code>的时候）调用<code>ParseForm</code>方法先来解析<code>Form</code>和<code>PostForm</code>两个字段：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">ParseMultipartForm</span><span class="token punctuation">(</span>maxMemory <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>MultipartForm <span class="token operator">==</span> multipartByReader <span class="token punctuation">{</span>        <span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"http: multipart handled by MultipartReader"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>Form <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">ParseForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> err        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>MultipartForm <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span>    mr<span class="token punctuation">,</span> err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">multipartReader</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> err    <span class="token punctuation">}</span>    f<span class="token punctuation">,</span> err <span class="token operator">:=</span> mr<span class="token punctuation">.</span><span class="token function">ReadForm</span><span class="token punctuation">(</span>maxMemory<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> err    <span class="token punctuation">}</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>PostForm <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        r<span class="token punctuation">.</span>PostForm <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span>Values<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> f<span class="token punctuation">.</span>Value <span class="token punctuation">{</span>        r<span class="token punctuation">.</span>Form<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Form<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token operator">...</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// r.PostForm should also be populated. See Issue 9305.</span>        r<span class="token punctuation">.</span>PostForm<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>PostForm<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    r<span class="token punctuation">.</span>MultipartForm <span class="token operator">=</span> f    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时需要一个最大读取字节数的参数。</p><p>从这个解析过程可以看到：</p><ul><li>如果<code>Form</code>和<code>PostForm</code>为<code>nil</code>的话，这个函数就先调用<code>ParseForm</code>来进行解析；</li><li>不过如果编码格式是<code>multipart/form-data</code>的话，<code>Form</code>中就只会有URL中的参数，而<code>PostForm</code>中啥也没有（暂时）；</li><li><code>ParseMultipartForm</code>方法会解析Body中<code>multipart/form-data</code>格式的数据到<code>MultipartForm</code>字段中；</li><li>最后还会将Body中的参数添加到<code>Form</code>和<code>PostForm</code>中。</li></ul><p>例子：</p><pre class="line-numbers language-go"><code class="language-go">r<span class="token punctuation">.</span><span class="token function">ParseMultipartForm</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span>Form<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span>PostForm<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span>MultipartForm<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用curl模拟一个请求：</p><pre class="line-numbers language-shell"><code class="language-shell">curl -F "start=30" -F "mode=list" -F upload=@hello "localhost:8080/world?start=40&sort=time"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中前两个-F生成两个<code>multipart/form-data</code>格式的参数，而后一个-F上传一个文件。结果：</p><pre class="line-numbers language-shell"><code class="language-shell">map[mode:[list] sort:[time] start:[40 30]]map[mode:[list] start:[30]]&{map[mode:[list] start:[30]] map[upload:[0xc0000fa140]]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>前两个<code>map</code>还是和之前的一样，最后一个就是<code>MultipartForm</code>，这是两个<code>map</code>，一个是Body中的参数，一个是上传的文件。</p><p>关于<code>Form</code>和之前有一个不同，就是<code>start</code>值的顺序。之前使用<code>ParseForm</code>解析的时候30在前而现在40在前。从两个函数的代码中我们可以看到这个结果的原因。</p><h4 id="5-4-Another-Way"><a href="#5-4-Another-Way" class="headerlink" title="5.4 Another Way"></a>5.4 Another Way</h4><p>除了上面调用<code>ParseForm</code>和<code>ParseMultipartForm</code>函数外，还可以通过其它的方法获取值：<code>FormValue()</code>和<code>PostFormValue()</code>。两个方法的定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">FormValue</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>Form <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        r<span class="token punctuation">.</span><span class="token function">ParseMultipartForm</span><span class="token punctuation">(</span>defaultMaxMemory<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> vs <span class="token operator">:=</span> r<span class="token punctuation">.</span>Form<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">len</span><span class="token punctuation">(</span>vs<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> vs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token function">PostFormValue</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>PostForm <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        r<span class="token punctuation">.</span><span class="token function">ParseMultipartForm</span><span class="token punctuation">(</span>defaultMaxMemory<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> vs <span class="token operator">:=</span> r<span class="token punctuation">.</span>PostForm<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">len</span><span class="token punctuation">(</span>vs<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> vs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两个函数都会在必要的时候调用<code>ParseMultipartForm</code>函数来进行解析。和前面的方法不同在于，这两个方法返回的是对应key的第一个value值，而不是一个字符串切片。</p><p>例子：</p><pre class="line-numbers language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span><span class="token function">FormValue</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">.</span><span class="token function">PostFormValue</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">4030<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个结果很奇怪是吧，所以对于既在URL中也在Body中的参数，在获取的时候需要小心一些。最好的办法就是参数只出现在一个地方，要么URL中，要么Body中。</p><p>其实常用的编码还有<code>application/json</code>，也就是读取的Body数据可以解析成一个Json结构，这也很常见，不过不在这里细说了。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb8.png"><p>To Be Continued…</p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Web (Part 1): Handler &amp; ServeMux</title>
      <link href="/go-web-part-1-handler-servemux/"/>
      <url>/go-web-part-1-handler-servemux/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Begin"><a href="#1-Begin" class="headerlink" title="1. Begin"></a>1. Begin</h3><p>使用Go语言的标准库<code>net/http</code>可以快速构建一个简单的web服务。这篇文章从零开始构建一个简单的web服务器，并主要聚焦于处理器Handler和多路复用器ServeMux。</p><p>在开始之前，MindMap里一无所有：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb1.png"><h3 id="2-The-Simplest-Server"><a href="#2-The-Simplest-Server" class="headerlink" title="2. The Simplest Server"></a>2. The Simplest Server</h3><p>使用<code>net/http</code>包中的<code>ListenAndServe()</code>函数可以快速构建一个最简单的服务器：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>go run</code>命令执行程序，然后在本地浏览器打开<a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> ，得到<code>404 page not found</code>的错误。</p><p>这就是一个最简单的服务器，什么也不做，但确实是一个服务器。</p><p>现在MindMap里多了点东西：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb2.png"><h3 id="3-发生了什么"><a href="#3-发生了什么" class="headerlink" title="3. 发生了什么"></a>3. 发生了什么</h3><p>调用<code>http.ListenAndServe()</code>函数就可以启动一个服务器，那么发生了什么呢？</p><p>查看源码可知这个函数的实现：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span>addr <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    server <span class="token operator">:=</span> <span class="token operator">&amp;</span>Server<span class="token punctuation">{</span>Addr<span class="token punctuation">:</span> addr<span class="token punctuation">,</span> Handler<span class="token punctuation">:</span> handler<span class="token punctuation">}</span>    <span class="token keyword">return</span> server<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>原来是通过构造一个<code>Server</code>并调用这个<code>Server</code>的<code>ListenAndServe()</code>函数实现的。</p><p>那也就是说，我们可以自己构造一个<code>Server</code>，然后启动服务器：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    s <span class="token operator">:=</span> http<span class="token punctuation">.</span>Server<span class="token punctuation">{</span>        Addr<span class="token punctuation">:</span>    <span class="token string">"127.0.0.1:8080"</span><span class="token punctuation">,</span>        Handler<span class="token punctuation">:</span> <span class="token boolean">nil</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    s<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动之后结果一样（如果端口被占用可以换一个端口）。</p><p>使用<code>http.ListenAndServe()</code>函数可以使用两个参数（<code>Addr</code>服务器地址和<code>Handler</code>处理器）就可以启动一个简单的服务。如果需要更加复杂的设置，需要使用<code>Server</code>结构。<code>Server</code>定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// A Server defines parameters for running an HTTP server.</span><span class="token comment" spellcheck="true">// The zero value for Server is a valid configuration.</span><span class="token keyword">type</span> Server <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Addr    <span class="token builtin">string</span>  <span class="token comment" spellcheck="true">// TCP address to listen on, ":http" if empty</span>    Handler Handler <span class="token comment" spellcheck="true">// handler to invoke, http.DefaultServeMux if nil</span>    TLSConfig <span class="token operator">*</span>tls<span class="token punctuation">.</span>Config    ReadTimeout time<span class="token punctuation">.</span>Duration    ReadHeaderTimeout time<span class="token punctuation">.</span>Duration    WriteTimeout time<span class="token punctuation">.</span>Duration    IdleTimeout time<span class="token punctuation">.</span>Duration    MaxHeaderBytes <span class="token builtin">int</span>    TLSNextProto <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>Server<span class="token punctuation">,</span> <span class="token operator">*</span>tls<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> Handler<span class="token punctuation">)</span>    ConnState <span class="token keyword">func</span><span class="token punctuation">(</span>net<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> ConnState<span class="token punctuation">)</span>    ErrorLog <span class="token operator">*</span>log<span class="token punctuation">.</span>Logger    BaseContext <span class="token keyword">func</span><span class="token punctuation">(</span>net<span class="token punctuation">.</span>Listener<span class="token punctuation">)</span> context<span class="token punctuation">.</span>Context    ConnContext <span class="token keyword">func</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> c net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> context<span class="token punctuation">.</span>Context<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，MindMap中又多了点东西，也知道了一些关联：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb3.png"><h3 id="3-处理器Handler"><a href="#3-处理器Handler" class="headerlink" title="3. 处理器Handler"></a>3. 处理器Handler</h3><p>由于<code>Handler</code>为空，所以这个服务器什么也不做只是返回404。为了让服务器做事情，需要添加处理器Handler：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> MyHandler <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mh <span class="token operator">*</span>MyHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    s <span class="token operator">:=</span> http<span class="token punctuation">.</span>Server<span class="token punctuation">{</span>        Addr<span class="token punctuation">:</span>    <span class="token string">"127.0.0.1:8080"</span><span class="token punctuation">,</span>        Handler<span class="token punctuation">:</span> <span class="token operator">&amp;</span>MyHandler<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    s<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果就是得到了一个<code>Hello World</code>。</p><p>这里定义了一个简单的处理器<code>MyHandler</code>，然后添加到定义的<code>Server</code>中。</p><p>所以为了让服务器有事情做，需要定义<code>Handler</code>告诉它做什么。一个<code>Handler</code>其实是一个接口：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Handler <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>任何结构只要有一个签名是这样的函数，都可以作为<code>Server</code>的处理器；同样，任何接受这两个参数的函数，也可以当做一个处理器。</p><p>不过这么做有个明显的缺陷就是，服务器不会通过URL来将请求路由到不同的处理器。为了能根据URL处理不同的请求，我们需要多个处理器。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb4.png"><h3 id="4-多个Handler"><a href="#4-多个Handler" class="headerlink" title="4. 多个Handler"></a>4. 多个Handler</h3><p>直接对<code>Server</code>指定<code>Handler</code>只能添加一个处理器，为了支持多个处理器，需要别的做法：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> HelloHandler <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>hh <span class="token operator">*</span>HelloHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">type</span> WorldHandler <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>wh <span class="token operator">*</span>WorldHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    s <span class="token operator">:=</span> http<span class="token punctuation">.</span>Server<span class="token punctuation">{</span>        Addr<span class="token punctuation">:</span> <span class="token string">"127.0.0.1:8080"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>HelloHandler<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/world"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>WorldHandler<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    s<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里定义了两个<code>Handler</code>，然后通过<code>http.Handle()</code>函数注册这两个<code>Handler</code>而不是直接对<code>Server</code>指定，这样就可以使用两个处理器了。在浏览器中分别访问<a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a> 和 <a href="http://localhost:8080/world" target="_blank" rel="noopener">http://localhost:8080/world</a> 可以得到不同的结果。</p><p>来看看<code>http.Handle()</code>函数做了什么：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Handle registers the handler for the given pattern</span><span class="token comment" spellcheck="true">// in the DefaultServeMux.</span><span class="token comment" spellcheck="true">// The documentation for ServeMux explains how patterns are matched.</span><span class="token keyword">func</span> <span class="token function">Handle</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token punctuation">{</span> DefaultServeMux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> handler<span class="token punctuation">)</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>原来是把具体的<code>Handler</code>注册到了一个叫做<code>DefaultServeMux</code>的变量里，在详细看看具体做了什么之前，先看看处理器函数<code>HandlerFunc</code>。</p><h3 id="5-处理器函数HandlerFunc"><a href="#5-处理器函数HandlerFunc" class="headerlink" title="5. 处理器函数HandlerFunc"></a>5. 处理器函数HandlerFunc</h3><p>除了使用Handler结构外，还可以使用具有相同参数的函数，只不过需要使用<code>http.HandleFunc()</code>函数：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">world</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    s <span class="token operator">:=</span> http<span class="token punctuation">.</span>Server<span class="token punctuation">{</span>        Addr<span class="token punctuation">:</span> <span class="token string">"127.0.0.1:8080"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span> hello<span class="token punctuation">)</span>    http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/world"</span><span class="token punctuation">,</span> world<span class="token punctuation">)</span>    s<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果和使用<code>http.Handle()</code>一样。处理器函数能够完成和处理器一样的功能，代码也更简洁一些。可以在实际使用中根据不同场景使用不同的方式。比如，如果代码中已经有处理的接口，只需要添加一个<code>ServeHTTP</code>函数就可以把这个接口转换成处理器了。</p><p>来看看<code>http.HandleFunc()</code>做了什么：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// HandleFunc registers the handler function for the given pattern</span><span class="token comment" spellcheck="true">// in the DefaultServeMux.</span><span class="token comment" spellcheck="true">// The documentation for ServeMux explains how patterns are matched.</span><span class="token keyword">func</span> <span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    DefaultServeMux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>又是<code>DefaultServeMux</code>，接下来详细看看这个是什么，以及它是怎么和<code>Server</code>关联起来的。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb5.png"><h3 id="6-多路复用器ServeMux和DefaultServeMux"><a href="#6-多路复用器ServeMux和DefaultServeMux" class="headerlink" title="6. 多路复用器ServeMux和DefaultServeMux"></a>6. 多路复用器ServeMux和DefaultServeMux</h3><p>不管使用<code>http.Handle()</code>注册处理器<code>Handler</code>还是使用<code>http.HandleFunc()</code>注册处理器函数<code>HandlerFunc</code>，内部都涉及到了一个变量<code>DefaultServeMux</code>，这个是默认的多路复用器，即<code>ServeMux</code>的一个实例：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// DefaultServeMux is the default ServeMux used by Serve.</span><span class="token keyword">var</span> DefaultServeMux <span class="token operator">=</span> <span class="token operator">&amp;</span>defaultServeMux<span class="token keyword">var</span> defaultServeMux ServeMux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>多路复用器的作用就是根据URL将不同的请求路由到不同的处理器上进行处理：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/servemux.PNG"><p><code>ServeMux</code>结构里有一个<code>map</code>，用来保存路由和处理器的映射：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> ServeMux <span class="token keyword">struct</span> <span class="token punctuation">{</span>    mu    sync<span class="token punctuation">.</span>RWMutex    m     <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>muxEntry    es    <span class="token punctuation">[</span><span class="token punctuation">]</span>muxEntry <span class="token comment" spellcheck="true">// slice of entries sorted from longest to shortest.</span>    hosts <span class="token builtin">bool</span>       <span class="token comment" spellcheck="true">// whether any patterns contain hostnames</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而<code>ServeMux</code>的<code>Handle()</code>和<code>HandleFunc()</code>函数就是将处理器注册到这个<code>map</code>里的。</p><p>不过<code>HandleFunc()</code>怎么把一个函数变成一个处理器呢？</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// HandleFunc registers the handler function for the given pattern.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> handler <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"http: nil handler"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    mux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> <span class="token function">HandlerFunc</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原来使用了一个名叫<code>HandlerFunc</code>的结构（注意和<code>http.HandleFunc</code>的区别）完成了转换。<code>HandlerFunc</code>定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// The HandlerFunc type is an adapter to allow the use of</span><span class="token comment" spellcheck="true">// ordinary functions as HTTP handlers. If f is a function</span><span class="token comment" spellcheck="true">// with the appropriate signature, HandlerFunc(f) is a</span><span class="token comment" spellcheck="true">// Handler that calls f.</span><span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// ServeHTTP calls f(w, r).</span><span class="token keyword">func</span> <span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们就理解了不管是<code>http.Handle()</code>还是<code>http.HandleFunc()</code>最终都归结于<code>ServeMux.Handle()</code>。如果不指定<code>ServeMux</code>的话，就使用默认的<code>DefaultServeMux</code>。</p><p>还需要注意一点就是，<code>ServeMux</code>本身也实现了<code>ServeHTTP()</code>函数，也是可以作为处理器的，这就是<code>DefaultServeMux</code>可以作为处理器的原因。</p><h3 id="7-ServeMux是如何路由的"><a href="#7-ServeMux是如何路由的" class="headerlink" title="7. ServeMux是如何路由的"></a>7. ServeMux是如何路由的</h3><p>我们已经大致了解了<code>ServeMux</code>是根据内部维护的一个<code>map</code>来找到具体的处理器的。这里来看看具体的实现细节，对于理解整个流程很有帮助。</p><p>回到最开始，不管是使用<code>http.ListenAndServe()</code>还是<code>Server.ListenAndServe()</code>，都是需要先<code>Listen</code>然后<code>Serve</code>，主要的过程就是创建一个TCP链接然后监听请求，最终就是到<code>serve()</code>函数里，主要代码如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">serve</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>    serverHandler<span class="token punctuation">{</span>c<span class="token punctuation">.</span>server<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> w<span class="token punctuation">.</span>req<span class="token punctuation">)</span>    <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用了一个叫做<code>serverHandler</code>的代理：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> serverHandler <span class="token keyword">struct</span> <span class="token punctuation">{</span>    srv <span class="token operator">*</span>Server<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>sh serverHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>rw ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    handler <span class="token operator">:=</span> sh<span class="token punctuation">.</span>srv<span class="token punctuation">.</span>Handler    <span class="token keyword">if</span> handler <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        handler <span class="token operator">=</span> DefaultServeMux    <span class="token punctuation">}</span>    <span class="token keyword">if</span> req<span class="token punctuation">.</span>RequestURI <span class="token operator">==</span> <span class="token string">"*"</span> <span class="token operator">&amp;&amp;</span> req<span class="token punctuation">.</span>Method <span class="token operator">==</span> <span class="token string">"OPTIONS"</span> <span class="token punctuation">{</span>        handler <span class="token operator">=</span> globalOptionsHandler<span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span>    handler<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>rw<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这里可以看到<code>DefaultServeMux</code>就是默认的多路复用器。所以如果给<code>Server</code>指定了一个<code>Handler</code>，那么就会调用这个<code>Handler</code>的<code>ServeHTTP()</code>函数；如果没有指定的话，就调用<code>DefaultServeMux</code>的<code>ServeHTTP()</code>函数，毕竟我们在前面已经知道<code>DefaultServeMux</code>就是<code>ServeMux</code>的一个实例，而<code>ServeMux</code>实现了<code>ServeHTTP()</code>函数：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// ServeHTTP dispatches the request to the handler whose</span><span class="token comment" spellcheck="true">// pattern most closely matches the request URL.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>RequestURI <span class="token operator">==</span> <span class="token string">"*"</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> r<span class="token punctuation">.</span><span class="token function">ProtoAtLeast</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Connection"</span><span class="token punctuation">,</span> <span class="token string">"close"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>StatusBadRequest<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    h<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">Handler</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>    h<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数所做的就是根据请求找到对应的<code>Handler</code>，然后让这个处理器完成具体的工作。下面就是<code>ServeMux.Handler()</code>函数的主要部分<code>ServeMux.handler()</code>：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// handler is the main implementation of Handler.</span><span class="token comment" spellcheck="true">// The path is known to be in canonical form, except for CONNECT methods.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">handler</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> path <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>h Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// Host-specific pattern takes precedence over generic ones</span>    <span class="token keyword">if</span> mux<span class="token punctuation">.</span>hosts <span class="token punctuation">{</span>        h<span class="token punctuation">,</span> pattern <span class="token operator">=</span> mux<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>host <span class="token operator">+</span> path<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        h<span class="token punctuation">,</span> pattern <span class="token operator">=</span> mux<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        h<span class="token punctuation">,</span> pattern <span class="token operator">=</span> <span class="token function">NotFoundHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">""</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>里面调用了<code>ServeMux.match()</code>函数，其实就是根据URL到<code>map</code>去找具体的<code>Handler</code>：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Find a handler on a handler map given a path string.</span><span class="token comment" spellcheck="true">// Most-specific (longest) pattern wins.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">match</span><span class="token punctuation">(</span>path <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>h Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Check for exact match first.</span>    v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> mux<span class="token punctuation">.</span>m<span class="token punctuation">[</span>path<span class="token punctuation">]</span>    <span class="token keyword">if</span> ok <span class="token punctuation">{</span>        <span class="token keyword">return</span> v<span class="token punctuation">.</span>h<span class="token punctuation">,</span> v<span class="token punctuation">.</span>pattern    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Check for longest valid match.  mux.es contains all patterns</span>    <span class="token comment" spellcheck="true">// that end in / sorted from longest to shortest.</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> e <span class="token operator">:=</span> <span class="token keyword">range</span> mux<span class="token punctuation">.</span>es <span class="token punctuation">{</span>        <span class="token keyword">if</span> strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> e<span class="token punctuation">.</span>pattern<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> e<span class="token punctuation">.</span>h<span class="token punctuation">,</span> e<span class="token punctuation">.</span>pattern        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，精确匹配，找到了就返回。如果没有找到，就根据一定的规则来找，最后如果还没有找到，那么返回404。</p><p>在后面的那个循环中，来找最长匹配的URL。<code>mux.es</code>是一个切片，这里存储的都是在注册<code>Handler</code>时模式以<code>/</code>结尾的：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">Handle</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>    <span class="token keyword">if</span> pattern<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'/'</span> <span class="token punctuation">{</span>        mux<span class="token punctuation">.</span>es <span class="token operator">=</span> <span class="token function">appendSorted</span><span class="token punctuation">(</span>mux<span class="token punctuation">.</span>es<span class="token punctuation">,</span> e<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就清楚了，路由过程如下：</p><ol><li>精确匹配，找到就返回；</li><li>如果没有精确匹配到，就到所有注册<code>Handler</code>时模式以<code>/</code>结尾的模式中寻找，原则是最长匹配；</li><li>还没有找到的话，就404。</li></ol><p>举个例子，比如注册时将<code>hello</code>这个处理器注册到了<code>/hello/</code>下，那么对于<code>/hello/wrong</code>这个请求如果精确匹配没找到的话就可以匹配<code>/hello/</code>，因为这个模式以<code>/</code>结尾；如果注册<code>hello</code>处理器的时候模式是<code>/hello</code>的话，那就不会把<code>/hello/wrong</code>路由到<code>/hello</code>对应的处理器上来了。</p><p><code>ServeMux</code>有一个缺点就是无法使用变量来实现URL模式匹配，比如<code>/post/123</code>这种，可以使用第三方库来避开这个限制。</p><p>这篇文章梳理了一下<code>net/http</code>包中下面的几个概念：</p><ul><li><code>http.ListenAndServe()</code></li><li><code>Server.ListenAndServe()</code></li><li><code>http.Handle()</code></li><li><code>Handler</code></li><li><code>http.HandleFunc()</code></li><li><code>HandlerFunc</code></li><li><code>DefaultServeMux</code></li></ul><p>而在我们的MindMap中，形成了下面的结构：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Programming/goweb6.png"><p>To Be Continued…</p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What Happens When Using LOAD DATA</title>
      <link href="/what-happens-when-using-load-data/"/>
      <url>/what-happens-when-using-load-data/</url>
      
        <content type="html"><![CDATA[<p>在之前的文章<a href="http://deuterium.fun/2019/12/17/files-to-mysql/">Files to MySQL</a>中简单介绍了mysqlimport和<code>LOAD DATA</code>的使用，也知道了mysqlimport其实就是使用了<code>LOAD DATA</code>语句。在这篇文章中详细介绍一下<code>LOAD DATA</code>这个语句，来看看当使用这个语句导入数据时到底发生了什么以及一些需要注意的地方。</p><h3 id="1-从Manual开始"><a href="#1-从Manual开始" class="headerlink" title="1. 从Manual开始"></a>1. 从Manual开始</h3><p>在<a href="https://dev.mysql.com/doc/refman/8.0/en/load-data.html" target="_blank" rel="noopener">MySQL手册</a>中详细介绍了<code>LOAD DATA</code>这个语句。下面是这个语句的格式：</p><pre class="line-numbers language-mysql"><code class="language-mysql">LOAD DATA    [LOW_PRIORITY | CONCURRENT] [LOCAL]    INFILE 'file_name'    [REPLACE | IGNORE]    INTO TABLE tbl_name    [PARTITION (partition_name [, partition_name] ...)]    [CHARACTER SET charset_name]    [{FIELDS | COLUMNS}        [TERMINATED BY 'string']        [[OPTIONALLY] ENCLOSED BY 'char']        [ESCAPED BY 'char']    ]    [LINES        [STARTING BY 'string']        [TERMINATED BY 'string']    ]    [IGNORE number {LINES | ROWS}]    [(col_name_or_user_var        [, col_name_or_user_var] ...)]    [SET col_name={expr | DEFAULT},        [, col_name={expr | DEFAULT}] ...]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数还是挺多的，可以在手册里看到详细的介绍。不管怎么样，可以使用这个语句来导入数据了。</p><h3 id="2-文件放在哪"><a href="#2-文件放在哪" class="headerlink" title="2. 文件放在哪"></a>2. 文件放在哪</h3><p>像之前一样，创建一个测试表和测试文件：one_piece表和one_piece.txt文件。</p><p>然后，这个文件放在哪呢？</p><p>毕竟现在涉及到两台机器：mysql client机器和server机器。</p><p>在手册上写着：</p><blockquote><p>If <code>LOCAL</code> is specified, the file is read by the client program on the client host and sent to the server.</p></blockquote><p>就是说MySQL根据<code>LOCAL</code>这个参数来标识在哪里去找这个文件。如果指定了<code>LOCAL</code>就在客户端上找，否则就在服务器上找。</p><h3 id="3-在server上"><a href="#3-在server上" class="headerlink" title="3. 在server上"></a>3. 在server上</h3><p>首先现在服务器上尝试。先看看MySQL存放数据的地方：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT @@datadir;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+------------------------+| @@datadir              |+------------------------+| /usr/local/mysql/data/ |+------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在我的机器上，目录是这个。</p><p>然后把文件放在这个目录下的test目录下，这个test就是对应的数据库。</p><p>然后导入数据：</p><pre class="line-numbers language-mysql"><code class="language-mysql">LOAD DATA INFILE 'one_piece.txt' INTO TABLE one_piece FIELDS TERMINATED BY '\t' IGNORE 1 LINES (no,name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>好的，那看看<code>secure_file_priv</code>是什么：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT @@secure_file_priv;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+--------------------+| @@secure_file_priv |+--------------------+| NULL               |+--------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果是NULL，这意味着不允许MySQL从文件系统里读取文件，当然是为了安全。</p><p>可以在启动mysql服务的时候设置这个值来允许mysql读取文件：</p><pre class="line-numbers language-shell"><code class="language-shell">/usr/local/mysql/bin/mysqld --user=_mysql --basedir=/usr/local/mysql \--datadir=/usr/local/mysql/data \--plugin-dir=/usr/local/mysql/lib/plugin \--log-error=/usr/local/mysql/data/mysqld.local.err \--pid-file=/usr/local/mysql/data/mysqld.local.pid \--secure-file-priv=/usr/local/mysql/data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样查看<code>secure_file_priv</code>就是设置的值了：</p><pre class="line-numbers language-shell"><code class="language-shell">+------------------------+| @@secure_file_priv     |+------------------------+| /usr/local/mysql/data/ |+------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后导入数据就可以了：</p><pre class="line-numbers language-shell"><code class="language-shell">Query OK, 10 rows affected (0.08 sec)Records: 10  Deleted: 0  Skipped: 0  Warnings: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>MySQL的默认设置是不允许这么操作的，这也可以理解。上面这么操作主要是为了演示从服务器里导入数据的过程，实际不建议这么操作，都是在客户端导入文件到MySQL服务器。</p><h3 id="4-在client上"><a href="#4-在client上" class="headerlink" title="4. 在client上"></a>4. 在client上</h3><p>由于一些原因我们不能在MySQL服务器上导入文件，这个时候需要在客户端上来导入文件了，这也是<code>LOCAL</code>选项的含义。从客户端导入数据到MySQL服务器的过程中涉及到一些步骤，如下图：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/load_data.png"><p>简单来说涉及到下面的几个步骤：</p><ol><li>客户端发送<code>COM_QUERY</code>到服务端来执行命令，在这个例子中就是<code>LOAD DATA LOCAL INFILE xxx</code>；</li><li>服务端发送一个特殊的响应<code>OxFB</code>和文件名给客户端，来告诉客户端发送的文件名；</li><li>客户端开始将文件内容发送给服务端；</li><li>客户端发送完文件内容后，发送一个空包来通知服务端文件发文完毕；</li><li>服务端开始执行命令，执行完毕后返回一个结果（OK或者错误）。</li></ol><p>可是为什么服务端要把发送的文件名给客户端呢？客户端不知道应该发送哪个文件吗？</p><p>是这样的，SQL语句分析起来比较麻烦，所以MySQL把SQL的解析都放在了服务端，服务端解析完了告诉客户端，这样客户端就不需要解析复杂的SQL语句了。</p><p>好的，开始使用<code>LOCAL</code>导入数据：</p><pre class="line-numbers language-mysql"><code class="language-mysql">LOAD DATA INFILE 'one_piece.txt' LOCALINTO TABLE one_piece FIELDS TERMINATED BY '\t' IGNORE 1 LINES (no,name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">ERROR 1148 (42000): The used command is not allowed with this MySQL version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>失败了，不过这个错误信息不好看到底是什么错误。其实这个错误是有关安全的一些设置。</p><h3 id="5-为了安全"><a href="#5-为了安全" class="headerlink" title="5. 为了安全"></a>5. 为了安全</h3><p>在手册上，有关于<code>LOAD DATA</code>的一些<a href="https://dev.mysql.com/doc/refman/8.0/en/load-data-local.html" target="_blank" rel="noopener">安全设置</a>：</p><blockquote><p>The <code>local_infile</code> system variable controls server-side <code>LOCAL</code> capability. Depending on the <code>local_infile</code> setting, the server refuses or permits local data loading by clients that have <code>LOCAL</code> enabled on the client side. By default, <code>local_infile</code> is disabled.</p></blockquote><p>这个是MySQL 8.0版本的说明，<code>local_infile</code>默认是不开启的，在之前的版本中都是默认开启的：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT @@local_infile;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+----------------+| @@local_infile |+----------------+|              0 |+----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>了解了，设置<code>local_infile=1</code>试试：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SET GLOBAL local_infile=1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后重试导入数据。结果：</p><pre class="line-numbers language-shell"><code class="language-shell">ERROR 1148 (42000): The used command is not allowed with this MySQL version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>怎么还错了呢？</p><p>在上面客户端和服务端数据交换的过程中可以知道，这个过程涉及到客户端和服务端两个机器，上面的设置只是设置了服务端允许客户端发送文件，但是客户端也需要允许服务端来读取这个文件：</p><blockquote><p>For the <strong>mysql</strong> client, local data loading is disabled by default. To disable or enable it explicitly, use the <code>--local-infile=0</code> or <code>--local-infile[=1\]</code> option.</p></blockquote><p>也就是说，对于mysql客户端，启动的时候需要设置一下<code>--local-infile</code>：</p><pre class="line-numbers language-shell"><code class="language-shell">mysql -u root -p --local_infile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后再试一次。结果：</p><pre class="line-numbers language-shell"><code class="language-shell">Query OK, 10 rows affected (0.05 sec)Records: 10  Deleted: 0  Skipped: 0  Warnings: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>终于成功了。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Files to MySQL</title>
      <link href="/files-to-mysql/"/>
      <url>/files-to-mysql/</url>
      
        <content type="html"><![CDATA[<p><strong>问题</strong>：把一个本地的文件（比如.txt或.csv文件）导入到指定的一张MySQL表中。可以使用mysqlimport或者<code>LOAD DATA</code>命令来完成。这篇文章仅仅是简单介绍一下mysqlimport和<code>LOAD DATA</code>的简单用法。关于<code>LOAD DATA</code>的详细说明，参考<a href="http://deuterium.fun/2019/12/18/what-happens-when-using-load-data/">What Happens When Using LOAD DATA</a>。</p><h3 id="1-Prework：创建测试表和文件"><a href="#1-Prework：创建测试表和文件" class="headerlink" title="1. Prework：创建测试表和文件"></a>1. Prework：创建测试表和文件</h3><p>首先创建一个测试表：</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE one_piece (    `no`    INT,    `name`    VARCHAR(15));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后创建一个测试文件：</p><pre class="line-numbers language-shell"><code class="language-shell">cat one_piece.txtno      name100     luffy200     zoro300     nami400     usopp500     sanji600     chopper700     robin800     franky900     brook1000    jinbe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-使用mysqlimport导入文件"><a href="#2-使用mysqlimport导入文件" class="headerlink" title="2. 使用mysqlimport导入文件"></a>2. 使用mysqlimport导入文件</h3><p>使用下面的命令可以将上面创建的one_piece.txt的内容导入表中：</p><pre class="line-numbers language-shell"><code class="language-shell">mysqlimport --ignore-lines=1 \--fields-terminated-by='\t' \--local \-h host \-P port \-u username \-p db_name \/path/to/one_piece.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行后会让输入密码，之后就执行成功了。</p><p>可以查看一下：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM one_piece;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+------+---------+| no   | name    |+------+---------+|  100 | luffy   ||  200 | zoro    ||  300 | nami    ||  400 | usopp   ||  500 | sanji   ||  600 | chopper ||  700 | robin   ||  800 | franky  ||  900 | brook   || 1000 | jinbe   |+------+---------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，导入的文件名需要和对应的表名一样，比如上面的one_piece.txt和对应的表名one_piece。不然会找不到表名。</p><h3 id="3-导入多个文件到多张表中"><a href="#3-导入多个文件到多张表中" class="headerlink" title="3. 导入多个文件到多张表中"></a>3. 导入多个文件到多张表中</h3><p>使用上面的命令我们可以将多个文件导入多张表中：</p><pre class="line-numbers language-shell"><code class="language-shell">mysqlimport --ignore-lines=1 \--fields-terminated-by='\t' \--local \-h host \-P port \-u username \-p db_name \/path/to/one_piece.txt/path/to/steins_gate.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-使用LOAD-DATA导入文件"><a href="#4-使用LOAD-DATA导入文件" class="headerlink" title="4. 使用LOAD DATA导入文件"></a>4. 使用<code>LOAD DATA</code>导入文件</h3><p>mysqlimport其实是对<code>LOAD DATA</code>的一层封装，这样我们就可以使用<code>LOAD DATA</code>导入文件：</p><pre class="line-numbers language-mysql"><code class="language-mysql">LOAD DATA LOCAL INFILE '/path/to/one_piece.txt' INTO TABLE one_piece FIELDS TERMINATED BY '\t' LINES TERMINATED BY '\n' IGNORE 1 LINES (no,name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果是一样的。</p><h3 id="4-mysqlimport常用选项"><a href="#4-mysqlimport常用选项" class="headerlink" title="4. mysqlimport常用选项"></a>4. mysqlimport常用选项</h3><p>mysqlimport的参数比较多，接下来看看一些常用的参数：</p><p><code>--ignore-lines</code>：用来标识忽略的行数，比如如果文件有表头的话，可以忽略这一行；</p><p><code>--fields-terminated-by</code>：用来标识字段分隔符，常用的有<code>\t</code>和<code>,</code>；</p><p><code>--local</code>：表示读取本地文件，如果不加的话就会出错；</p><p><code>--delete</code>：在导入之前先删除所有的数据；</p><p><code>-h</code>和<code>-P</code>：表示MySQL服务器的地址，不加的话就是本地的MySQL服务器；</p><p><code>-p</code>：使用密码；</p><p>后面的<code>test</code>就是对应的数据库名。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Types in MySQL</title>
      <link href="/data-types-in-mysql/"/>
      <url>/data-types-in-mysql/</url>
      
        <content type="html"><![CDATA[<h3 id="1-开始"><a href="#1-开始" class="headerlink" title="1. 开始"></a>1. 开始</h3><p>为了能更好地理解与使用MySQL，根据MySQL文档花点时间整理了一下MySQL的数据类型。MySQL中一共有五大类数据类型，如下图：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/mysql_datatypes.PNG"><p>这篇文章只对其中的数字类型、字符串类型和时间类型进行总结。</p><p>在这些数据类型的使用中，有几个需要提前知道的地方：</p><ol><li>在整数中，<em><code>M</code></em>代表最大的展示宽度；而在浮点数和定点数中，<em><code>M</code></em>代表可以存储的总位数（也就是精度,precision）；对于字符串类型，<em><code>M</code></em>代表所能存储的最长字符数。不同类型的<em><code>M</code></em>也是不一样的；</li><li><em><code>D</code></em>适用于浮点数和定点数，表示小数点后面的位数。<em><code>D</code></em>最大值是30，但是不能大于<em><code>M-2</code></em>；</li><li><em><code>fsp</code></em>适用于时间类型，表示小于秒的精度。这个值在0和6之间，也就是说MySQL的时间可以精确到微秒级；</li><li>类型定义中的<code>[</code>和<code>]</code>表示可选项。</li></ol><p>不管什么数据类型，计算机的存储都是一样的，不同在于对于底层存储数据的解释不同。</p><p>接下来，详细看看各种数据类型是怎么存储的，以及MySQL是怎么解释的。</p><h3 id="2-Numeric类型"><a href="#2-Numeric类型" class="headerlink" title="2. Numeric类型"></a>2. Numeric类型</h3><p>数字类型还可以细分成如下的几种类型：整数、实数和位数据类型。</p><p>数字类型支持有符号和无符号属性，分别是<code>UNSIGNED</code>和<code>SIGNED</code>。其中<code>SIGNED</code>可以不写在类型定义中，默认就是有符号的。</p><h4 id="2-1-Integer类型"><a href="#2-1-Integer类型" class="headerlink" title="2.1 Integer类型"></a>2.1 Integer类型</h4><p>整数类型根据所占空间大小可以分为五种：<code>TINYINT</code>, <code>SMALLINT</code>, <code>MEDIUMINT</code>, <code>INT</code>, <code>BIGINT</code>。其中<code>INT</code>也是<code>INTEGER</code>。</p><p>按照有无符号又可以分为两种：<code>SIGNED</code>和<code>UNSIGNED</code>，其中默认是有符号的，只需要在指定无符号时使用<code>UNSIGNED</code>。</p><p>整数类型基本情况如下表：</p><table><thead><tr><th>Type</th><th>Bytes</th><th>Min Signed</th><th>Max Signed</th><th>Min Unsigned</th><th>Max Unsigned</th></tr></thead><tbody><tr><td><code>TINYINT</code></td><td>1</td><td>-128</td><td>127</td><td>0</td><td>255</td></tr><tr><td><code>SMALLINT</code></td><td>2</td><td>-32768</td><td>32767</td><td>0</td><td>65535</td></tr><tr><td><code>MEDIUMINT</code></td><td>3</td><td>-8388608</td><td>8388607</td><td>0</td><td>16777215</td></tr><tr><td><code>INT</code></td><td>4</td><td>-2147483648</td><td>2147483647</td><td>0</td><td>4294967295</td></tr><tr><td><code>BIGINT</code></td><td>8</td><td>-2^63</td><td>2^63-1</td><td>0</td><td>2^64-1</td></tr></tbody></table><p>有符号与无符号类型使用相同的存储空间，也具有相同的性能，可以根据需要来选择。不过如果选择了无符号类型，当插入的数据是负数时，会保存为0，需要注意。</p><p>对于整数的<em><code>M</code></em>，比如<code>INT(11)</code>，对于大多数应用这是没有意义的，因为这不会限制值的合法范围，只是规定了MySQL的一些交互工具（比如MySQL命令行客户端）用来显示字符的个数。对于存储和计算来说，<code>INT(1)</code>和<code>INT(11)</code>是相同的。</p><p>还有一个类型，<code>BOOL</code>(也可以是<code>BOOLEAN</code>)，这个类型和<code>TINYINT(1)</code>一样，0为<code>false</code>，非零为<code>true</code>。但是在MySQL中，<code>TRUE</code>就是1<code>FALSE</code>就是0：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT IF(2 = TRUE, 'true', 'false');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果是<code>false</code>。</p><h4 id="2-2-实数类型"><a href="#2-2-实数类型" class="headerlink" title="2.2 实数类型"></a>2.2 实数类型</h4><p>MySQL中除了整数还可以储存实数。对于实数，MySQL既支持精确类型（定点），也支持不精确类型（浮点）。</p><p>对于精确实数类型，MySQL中有<code>DECIMAL</code>，也可以叫做<code>DEC</code>和<code>NUMERIC</code>。</p><p><code>DECIMAL</code>类型定义如下：</p><pre class="line-numbers language-mysql"><code class="language-mysql">salary DECIMAL(5,2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中5就是精度2就是小数点后面的位数。精度也就是数字的总位数，这样<code>salary</code>的范围就是<code>-999.99</code>到<code>999.99</code>。</p><p>对于不精确类型，MySQL有<code>FLOAT</code>和<code>DOUBLE</code>类型，其中<code>FLOAT</code>使用4个字节（也有可能使用8个字节），而<code>DOUBLE</code>使用8个字节进行存储。</p><p>对于<code>FLOAT</code>，还可以这样来指定类型：<code>FLOAT(p)</code>，可以用来指定存储空间大小，具体的大小和<code>p</code>有关。</p><p>浮点类型通常在相同精度时比<code>DECIMAL</code>所需空间少，所以应该尽量在需要精确计算时使用<code>DECIMAL</code>。</p><p>下面列出了不同类型所占的空间：</p><table><thead><tr><th>Data Type</th><th>Storage Required</th></tr></thead><tbody><tr><td><code>FLOAT(p)</code></td><td><code>0&lt;=p&lt;=24</code>时4个字节，<code>25&lt;=p&lt;=53</code>时8个字节</td></tr><tr><td><code>FLOAT</code></td><td>4个字节</td></tr><tr><td><code>DOUBLE</code></td><td>8个字节</td></tr></tbody></table><p>对于<code>DECIMAL</code>情况有些复杂，MySQL将数字打包成二进制字符串来存储，每9个数字使用4个字节，并且对于整数部分和小数部分分开计算。计算规则如下：</p><ol><li>每9个数字使用4个字节；</li><li>不够9个数字的通过下面的表格确定；</li><li>将整数部分和小数部分所占空间相加即是整体空间。</li></ol><p>不够9个数字的部分所占空间：</p><table><thead><tr><th>Leftover Digits</th><th>Number of Bytes</th></tr></thead><tbody><tr><td>0</td><td>0</td></tr><tr><td>1-2</td><td>1</td></tr><tr><td>3-4</td><td>2</td></tr><tr><td>5-6</td><td>3</td></tr><tr><td>7-8</td><td>4</td></tr></tbody></table><p>比如，对于123.123，整数部分3个数字不够9个，查表使用2个字节；同理小数部分也使用2个字节，一共4个字节。</p><p>对于12345.1，整数部分使用3个字节，小数部分使用1个字节，一共4个字节。</p><h4 id="2-3-位数据类型"><a href="#2-3-位数据类型" class="headerlink" title="2.3 位数据类型"></a>2.3 位数据类型</h4><p><code>BIT</code>类型可以存储比特位，<code>BIT(M)</code>可以存储<code>M</code>个比特位，其中<code>M</code>可以取1到64之间的任意值。。</p><p>对于<code>BIT</code>类型，不同的存储引擎存储方式不同。MyISAM会把所有的比特位打包存储，所以19个单独的<code>BIT</code>列只需要19位来存储，所以一共3个字节就可以了；但是对于InnoDB来说，会为每个<code>BIT</code>列使用一个足够小的最小整数类型来存储，所以不能节省空间。</p><p>还有一点需要注意的是，MySQL是使用字符串来存储的，而不是ASCII码的”0”或”1”。但是在数字上下文的场景使用时，结果是把位字符串转换成了数字。比如，如果存储一个<code>b&#39;00111001&#39;</code>（二进制值是57）到<code>BIT(8)</code>中并检索使用，得到的内容是字符码为57的字符串，也就是得到了字符”9”，但是在数字上下文中，得到的是57：</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE bittest(a bit(8));INSERT INTO bittest VALUES (b'00111001');SELECT a, a+0 FROM bittest;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+------+------+| a    | a+0  |+------+------+| 9    |   57 |+------+------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个建议就是，尽可能不使用<code>BIT</code>类型。</p><h3 id="3-String类型"><a href="#3-String类型" class="headerlink" title="3. String类型"></a>3. String类型</h3><h4 id="3-1-VARCHAR和CHAR类型"><a href="#3-1-VARCHAR和CHAR类型" class="headerlink" title="3.1 VARCHAR和CHAR类型"></a>3.1 <code>VARCHAR</code>和<code>CHAR</code>类型</h4><p><code>VARCHAR</code>和<code>CHAR</code>是两种主要的类型，虽然相似，但是在好多方面各不相同。而且，两种类型在磁盘和内存中的存储方式也和存储引擎有关，这里的描述主要是InnoDB和MyISAM。</p><p><strong>区别一：<code>VARCHAR</code>是变长的，<code>CHAR</code>是定长的。</strong></p><p><code>VARDCHAR</code>根据存储的内容使用不同的空间，最长长度定义时指定；而<code>CHAR</code>使用定义时指定的空间。如果存储的值超过了指定的空间，两种类型都会截断超过的部分。</p><p><strong>区别二：两种类型所能存储的最长字符串不同。</strong></p><p><code>VARCHAR</code>可以最多存储65535个字符；而<code>CHAR</code>最多能存储255个字符。最长字符都可以在定义时指定。</p><p><strong>区别三：填充方式</strong></p><p>由于<code>CHAR</code>是定长的，如果存储的值不够指定长度，会在末尾填充空格；而<code>VARCHAR</code>不会填充空格。</p><p><strong>区别四：空间占用</strong></p><p><code>CHAR</code>是定长的，所以指定的长度就是真正需要的空间，不过还和使用的字符集有关。如果使用latin1字符集，那么<code>CHAR(4)</code>就使用4个字节存储。</p><p><code>VARCHAR</code>是变长的，所以需要额外记录字符串的长度。对于字符数小于等于255，额外需要一个字节存储长度；字符数超过255，需要两个字节。</p><p><strong>区别五：末尾空格</strong></p><p>在区别三种提到了<code>CHAR</code>会在后面使用空格填充，但是如果数据本身后面就有空格的话，两个类型处理方式就不同了。<code>CHAR</code>当然会保存空格，但是在检索时会把空格去掉；而<code>VARCHAR</code>不会：存入什么，得到什么。</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE vc (v VARCHAR(4), c CHAR(4));INSERT INTO vc VALUES ('ab  ', 'ab  ');SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+---------------------+---------------------+| CONCAT('(', v, ')') | CONCAT('(', c, ')') |+---------------------+---------------------+| (ab  )              | (ab)                |+---------------------+---------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面的表格演示了两者的区别：</p><table><thead><tr><th>Value</th><th><code>CHAR(4)</code></th><th>Storage Required</th><th><code>VARCHAR(4)</code></th><th>Storage Required</th></tr></thead><tbody><tr><td><code>&#39;&#39;</code></td><td><code>&#39;    &#39;</code></td><td>4 bytes</td><td><code>&#39;&#39;</code></td><td>1 byte</td></tr><tr><td><code>&#39;ab&#39;</code></td><td><code>&#39;ab  &#39;</code></td><td>4 bytes</td><td><code>&#39;ab&#39;</code></td><td>3 bytes</td></tr><tr><td><code>abcd</code></td><td><code>&#39;abcd&#39;</code></td><td>4 bytes</td><td><code>&#39;abcd&#39;</code></td><td>5 bytes</td></tr><tr><td><code>abcdefgh</code></td><td><code>&#39;abcd&#39;</code></td><td>4 bytes</td><td><code>&#39;abcd&#39;</code></td><td>5 bytes</td></tr></tbody></table><p><code>VARCHAR</code>可以节省空间，不过由于是变长的，在更新时可能会比原来的长，这就需要额外的操作。如果一个行占用的空间增长，并且在页中没有更多的空间的话，不同的存储引擎处理方式不同。MyISAM会将行拆分成不同的片段存储；InnoDB则需要分裂页来使行可以放进页内。</p><p><code>CHAR</code>适合存储很短的字符串，或者所有值都接近同一个长度，比如MD5值。对于经常变更的数据，<code>CHAR</code>也比<code>VARCHAR</code>好，因为不会产品碎片。</p><h4 id="3-2-VARBINARY和BINARY类型"><a href="#3-2-VARBINARY和BINARY类型" class="headerlink" title="3.2 VARBINARY和BINARY类型"></a>3.2 <code>VARBINARY</code>和<code>BINARY</code>类型</h4><p><code>VARBINARY</code>和<code>BINARY</code>两种类型和<code>VARCHAR</code>和<code>CHAR</code>类似，不同在于，前两者储存的是二进制字符串（二进制字符码），而后两者存储的是常规字符串（字符）。</p><p>这样有一个问题就是，虽然前两者的长度限制和后两者的一样，但是前两者计算的是字节数，而后两者计算的字符数，这在有些单个字符使用多个字节的字符集中会有所不同。</p><p>还有一点需要注意，<code>BINARY</code>会在数据后面填充<code>\0</code>而不是空格，在检索的时候也不会删除后面的<code>\0</code>。</p><p>二进制字符的优势在于比较。MySQL比较<code>BINARY</code>字符串时，每次按一个字节，并且根据该字节的数值比较。这会比字符比较更快。</p><h4 id="3-3-BLOB和TEXT类型"><a href="#3-3-BLOB和TEXT类型" class="headerlink" title="3.3 BLOB和TEXT类型"></a>3.3 <code>BLOB</code>和<code>TEXT</code>类型</h4><p><code>BLOB</code>和<code>TEXT</code>都是为了存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。</p><p>其实它们也有各自的类型族：<code>TINYBLOB</code>、<code>BLOB</code>、<code>MEDIUMBLOB</code>、<code>LONGBLOB</code>和<code>TINYTEXT</code>、<code>TEXT</code>、<code>MEDIUMTEXT</code>和<code>LONGTEXT</code>。</p><p>当<code>BLOG</code>和<code>TEXT</code>过大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1-4个字节来存储一个指针，指向外部存储区域的实际值。</p><p>MySQL对于<code>BLOB</code>和<code>TEXT</code>列进行排序与其它类型不同：只对最前面的<code>max_sort_length</code>字节而不是整个字符串进行排序。</p><p>MySQL不能将<code>BLOB</code>和<code>TEXT</code>列全部长度的字符串进行索引，也不能使用这些索引消除排序。</p><h4 id="3-4-ENUM类型"><a href="#3-4-ENUM类型" class="headerlink" title="3.4 ENUM类型"></a>3.4 <code>ENUM</code>类型</h4><p>有时候可以使用枚举类型代替常用的字符串类型。枚举类型可以把一些不重复的字符串存储成一个预定义的集合。枚举类型使用一个或两个字节来编码枚举值，最多可以用65535个不同的枚举值。</p><p>创建一个枚举值：</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE shirts (    name VARCHAR(40),    size ENUM('x-small', 'small', 'medium', 'large', 'x-large'));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这也是使用枚举类型的一个缺点，当需要增加枚举值时，只能使用<code>ALTER TABLE</code>：</p><pre class="line-numbers language-mysql"><code class="language-mysql">ALTER TABLE shirts MODIFY COLUMN size ENUM('x-small', 'small', 'medium', 'large', 'x-large', 'xx-large');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>存储枚举值时使用的是数字而不是对应的字符串：</p><pre class="line-numbers language-mysql"><code class="language-mysql">INSERT INTO shirts (name, size) VALUES ('dress shirt','large'), ('t-shirt','medium'),  ('polo shirt','small');SELECT * FROM shirts;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+-------------+--------+| name        | size   |+-------------+--------+| dress shirt | large  || t-shirt     | medium || polo shirt  | small  |+-------------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过在数字上下文中，可以看到真实存储的值：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT size+0 FROM shirts;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-mysql"><code class="language-mysql">+--------+| size+0 |+--------+|      4 ||      3 ||      2 |+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此：<strong>千万不要使用数字作为枚举值</strong>。</p><p>还有一点，枚举字段是根据存储的数字来排序的而不是定义的字符串：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT size FROM shirts ORDER BY size;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-shell"><code class="language-shell">+--------+| size   |+--------+| small  || medium || large  |+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-5-SET类型"><a href="#3-5-SET类型" class="headerlink" title="3.5 SET类型"></a>3.5 <code>SET</code>类型</h4><p>一位可以存储一个只有<code>true/false</code>值，如果有很多<code>true/false</code>值的话，可以使用<code>SET</code>类型，它在MySQL中打包存储，可以有效节省空间，最多可以存储64个<code>true/false</code>值，只需要8个字节。</p><p>和<code>ENUM</code>一样，一个主要的缺点是添加新的定义时需要使用<code>ALTER TABLE</code>。而且，也不能在<code>SET</code>上使用索引。</p><p>作为一个替代方案，可以使用一个整数来包装一系列的位，然后再应用中操作这个整数。不过是使用这个方法还是使用<code>SET</code>依据每个人的偏好。</p><h3 id="4-Date-and-Time类型"><a href="#4-Date-and-Time类型" class="headerlink" title="4. Date and Time类型"></a>4. Date and Time类型</h3><p>MySQL中的时间和日期类型有如下几种：<code>DATE</code>、<code>TIME</code>、<code>DATETIME</code>、<code>TIMESTAMP</code>和<code>YEAR</code>。每种类型都有自己对应的零值和取值范围：</p><table><thead><tr><th>Data Type</th><th>“Zero” Value</th><th>Time Range</th></tr></thead><tbody><tr><td><code>Date</code></td><td><code>&#39;0000-00-00&#39;</code></td><td><code>&#39;1000-01-01&#39;</code> 到<code>&#39;9999-12-31&#39;</code></td></tr><tr><td><code>TIME</code></td><td><code>&#39;00:00:00&#39;</code></td><td><code>&#39;-838：59：59&#39;</code>到<code>&#39;838:59:59&#39;</code></td></tr><tr><td><code>DATETIME</code></td><td><code>&#39;0000-00-00 00:00:00&#39;</code></td><td><code>&#39;1000-01-01 00:00:00&#39;</code>到<code>&#39;9999-12-31 23:59:59&#39;</code></td></tr><tr><td><code>TIMESTAMP</code></td><td><code>&#39;0000-00-00 00:00:00&#39;</code></td><td><code>&#39;1970-01-01 00:00:01&#39;</code>到<code>&#39;2038-01-19 03:14:07&#39;</code></td></tr><tr><td><code>YEAR</code></td><td><code>0000</code></td><td><code>&#39;1901&#39;</code>到<code>&#39;2155&#39;</code>或<code>&#39;0&#39;</code>到<code>&#39;99&#39;</code></td></tr></tbody></table><h4 id="4-1-DATE、DATETIME和TIMESTAMP类型"><a href="#4-1-DATE、DATETIME和TIMESTAMP类型" class="headerlink" title="4.1 DATE、DATETIME和TIMESTAMP类型"></a>4.1 <code>DATE</code>、<code>DATETIME</code>和<code>TIMESTAMP</code>类型</h4><p>这三种类型都含有年月日的信息，但是三种类型又有一些不同。</p><p><code>DATE</code>类型只有日期而没有时间；<code>DATETIME</code>和<code>TIMESTAMP</code>除了日期还有具体的时间。</p><p><code>DATETIME</code>和<code>TIMESTAMP</code>的一个区别是两者的范围不同。<code>DATETIME</code>将日期存储为<code>YYYYMMDDHHMMSS</code>格式的整数中，使用8个字节；而<code>TIMESTAMP</code>使用4个字节存储从1970年1月1日以来的秒数，所以范围小了很多。</p><p>另外一个区别就是<code>TIMESTAMP</code>依赖时区而<code>DATETIME</code>不包含时区。MySQL服务器、操作系统以及客户端连接都可以设置时区。</p><p><code>TIMESTAMP</code>也有一些<code>DATETIME</code>没有的属性，比如可以设置插入和更新时<code>TIMESTAMP</code>列的行为。</p><p>在MySQL 5.6之后<code>DATETIME</code>和<code>TIMESTAMP</code>增加了时间的精确度，在原来秒的基础上精确度增加到了微秒级别，不过需要在定义中指定精确度，比如<code>DATETIME(6)</code>，括号中的数字就是时间的精确度，取值范围是0-6。</p><p>如果指定了额外的精确度的话，MySQL需要额外的空间来存储，所需的空间和精度有关：</p><table><thead><tr><th>fsp</th><th>Storage Required</th></tr></thead><tbody><tr><td>0</td><td>0 bytes</td></tr><tr><td>1, 2</td><td>1 byte</td></tr><tr><td>3, 4</td><td>2 bytes</td></tr><tr><td>5, 6</td><td>3 bytes</td></tr></tbody></table><h4 id="4-2-TIME类型"><a href="#4-2-TIME类型" class="headerlink" title="4.2 TIME类型"></a>4.2 <code>TIME</code>类型</h4><p><code>TIME</code>类型的存储范围并不是感觉上的<code>&#39;00:00:00&#39;</code>到<code>&#39;23:59:59&#39;</code>，而是<code>&#39;-838：59：59&#39;</code>到<code>&#39;838:59:59&#39;</code>，这样就可以表示是两个事件之间的时间差了。</p><p>MySQL中<code>TIME</code>的格式是<code>hh:mm:ss</code>，使用3个字节来存储。</p><p>在对<code>TIME</code>列进行赋值时，需要注意的是，<code>11:12</code>的结果是<code>&#39;11:12:00&#39;</code>，而不是<code>00:11:12</code>；<code>&#39;1112&#39;</code>的结果是<code>&#39;00:11:12&#39;</code>；<code>&#39;12&#39;</code>的结果是<code>&#39;00:00:12&#39;</code>。不过建议不要这么做。</p><p>同样，<code>TIME</code>类型在MySQL 5.6 版本之后添加了微秒级的精度，只需要在定义的时候指定精度即可，所需的额外空间就是上面的表格。</p><h4 id="4-3-YEAR类型"><a href="#4-3-YEAR类型" class="headerlink" title="4.3 YEAR类型"></a>4.3 <code>YEAR</code>类型</h4><p><code>YEAR</code>类型是使用1个字节来存储的数据类型，用来表示年份。在MySQL中，有两种：<code>YEAR(4)</code>和<code>YEAR(2)</code>。</p><p><code>YEAR(4)</code>可以表示的范围是<code>&#39;1901&#39;</code>到<code>&#39;2155&#39;</code>；</p><p><code>YEAR(2)</code>可以的取值范围是<code>&#39;0&#39;</code>到<code>&#39;99&#39;</code>，可以表示的范围是<code>&#39;1970&#39;</code>到<code>&#39;2069&#39;</code>。</p><p>由于范围小，尽量不要使用<code>YEAR(2)</code>。</p><h3 id="5-选择优化的数据类型"><a href="#5-选择优化的数据类型" class="headerlink" title="5. 选择优化的数据类型"></a>5. 选择优化的数据类型</h3><p>MySQL支持的数据类型非常多，选择正确的类型对于性能来说也很重要。下面是选择数据类型时的一些原则。</p><ol><li>一般情况下，应该尽量使用可以正确存储数据的最小数据类型；</li><li>使用简单的数据类型。比如，使用MySQL的内建类型来存储时间而不是字符串，使用整型次数IP地址而不是字符串；</li><li>通常情况下最好指定列为<code>NOT NULL</code>，除非真的需要存储<code>NULL</code>值；</li><li>尽量使用相同的数据类型来存储相似或相关的值，尤其是需要在关联条件中使用的列；</li><li>注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存；</li><li>避免使用MySQL已经遗弃的特性，比如指定浮点数的精度，或者整数的显示宽度；</li><li>小心使用<code>ENUM</code>和<code>SET</code>，不要滥用；</li><li>谨慎使用<code>BIT</code>，对于大部分应用，最好避免使用这个类型。</li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> data_type </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File to Redis</title>
      <link href="/file-to-redis/"/>
      <url>/file-to-redis/</url>
      
        <content type="html"><![CDATA[<p>问题是这样的，现在需要把一个文件里的所有数据上传到redis的set中，文件里存储的就是ID，每行一个：</p><pre class="line-numbers language-shell"><code class="language-shell">head id.list10000100011000210003100041000510006100071000810009<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了将这一万条记录添加到redis中的某个set中，需要写一个脚本来执行这个操作。</p><p>主要的思路就是构造一个如下命令组成的一堆命令：</p><pre class="line-numbers language-shell"><code class="language-shell">sadd setname 10000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后使用<code>redis-cli</code>将命令通过pipeline的形式发送到服务器。流程如下：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Redis/file2redis.PNG"><p>下面就是生成命令的shell脚本：</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bashINFILE=$1SETKEY=$2TOFILE=${SETKEY}'.data'echo $TOFILErm $TOFILE >/dev/null 2>&1while IFS= read -r line; do    echo "sadd $SETKEY $line" >> $TOFILEdone < $INFILEunix2dos $TOFILEcat $TOFILE | ./redis-cli --pipe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在脚本的最后，通过下面的命令将所有的redis命令发送到了redis服务器中：</p><pre class="line-numbers language-shell"><code class="language-shell">cat $TOFILE | ./redis-cli --pipe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以在redis中查看是否正确。</p><p>对于将数据导入redis的其它格式中，也是类似的过程，只需要把循环中添加的命令改成需要的形式就可以了。</p><p>Done</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Character Sets and Collations in MySQL</title>
      <link href="/character-sets-and-collations-in-mysql/"/>
      <url>/character-sets-and-collations-in-mysql/</url>
      
        <content type="html"><![CDATA[<p>最近遇到一个关于MySQL字符乱码的问题，比较好解决，但是为了更好地理解MySQL中的字符系统，参考MySQL的文档整理一下关于MySQL中字符集合字符序的问题。</p><h3 id="1-什么是字符集和字符序"><a href="#1-什么是字符集和字符序" class="headerlink" title="1. 什么是字符集和字符序"></a>1. 什么是字符集和字符序</h3><p>MySQL是存储数据的数据库，既然是存储数据的，那么数据就需要一个编码的规则，因为计算机对于所有的数据都是通过二进制编码的方式存储的。字符集（Character Sets），就是字符到二进制编码映射的集合。由于不同的语言所包含的字符不同，所以为了支持不同的语言，MySQL定义了许许多多不同的字符集。</p><p>举一个简单的例子，假如我们有一种语言只有四个字符：<code>A, B, a, b</code>。</p><p>我们规定了这四个字符到二进制编码的规则：</p><table><thead><tr><th>Symbol</th><th>Encoding</th></tr></thead><tbody><tr><td><code>A</code></td><td>0</td></tr><tr><td><code>B</code></td><td>1</td></tr><tr><td><code>a</code></td><td>2</td></tr><tr><td><code>b</code></td><td>3</td></tr></tbody></table><p>在这里，<code>A</code>就是一个字符，而数字0就是字符<code>A</code>的编码，这四个字符和编码组合在一起就是字符集。</p><p>接下来看看什么是字符序（Collations）。</p><p>对于上面的字符集，我们需要有一个比较的规则。比如，我们想比较<code>A</code>和<code>B</code>，当然结果有三种：等于、小于或大于。但我们熟悉的还是<code>A&lt;B</code>。一种简单的方式就是比较他们的编码数字。因为<code>0&lt;1</code>，所以对应的字符<code>A&lt;B</code>。</p><p>这样就构成了一条字符比较的规则。这样的一条规则就可以构成一个字符序。</p><p>进一步，如果我们规定大写字母和对应的小写字母相等呢？这样就又多了一条规则：</p><blockquote><p><code>a</code>=<code>A</code>, <code>b</code>=<code>B</code></p></blockquote><p>这样，两条比较的规则就又构成了一个字符序。</p><p>通过这个简单的例子，我们可以知道：</p><ol><li>字符集就是字符到二进制编码的映射集合；</li><li>字符序是比较字符集的规则集合；</li><li>一个字符集可能有多个字符序。</li></ol><p>在MySQL中，定义了许多字符集合字符序。这些字符集合字符序可以帮助我们处理很多字符相关的问题。</p><h3 id="2-MySQL中的字符集合字符序"><a href="#2-MySQL中的字符集合字符序" class="headerlink" title="2. MySQL中的字符集合字符序"></a>2. MySQL中的字符集合字符序</h3><p>在MySQL中，我们可以使用如下的语句来查看字符集：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SHOW CHARACTER SET;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这会列出所有的字符集。如果想筛选的话，可以加上<code>LIKE</code>条件：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SHOW CHARATER SET LIKE 'utf%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下：</p><pre class="line-numbers language-shell"><code class="language-shell">+---------+------------------+--------------------+--------+| Charset | Description      | Default collation  | Maxlen |+---------+------------------+--------------------+--------+| utf16   | UTF-16 Unicode   | utf16_general_ci   |      4 || utf16le | UTF-16LE Unicode | utf16le_general_ci |      4 || utf32   | UTF-32 Unicode   | utf32_general_ci   |      4 || utf8    | UTF-8 Unicode    | utf8_general_ci    |      3 || utf8mb4 | UTF-8 Unicode    | utf8mb4_0900_ai_ci |      4 |+---------+------------------+--------------------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果返回了字符集的名称、描述、默认字符序以及单个字符最大长度等信息。</p><p>每一个字符集都有一个默认的字符序，有的字符集有多个字符序，可以通过下面的语句查看一个字符集的字符序：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SHOW COLLATION WHERE Charset = 'utf8mb4';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回的结果会列出所有的字符序以及相关的信息，这里就不展示了。</p><p>字符序有下面的特点：</p><ol><li>两个不同的字符集不会有相同的字符序。也就是每个字符集都有自己单独的字符序小弟，大家不会有交集；</li><li>每一个字符集都有一个默认的字符序；</li><li>字符序的名字是以对应的字符集名称为前缀的。</li></ol><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/characterset.PNG"><h3 id="3-在MySQL中使用字符集"><a href="#3-在MySQL中使用字符集" class="headerlink" title="3. 在MySQL中使用字符集"></a>3. 在MySQL中使用字符集</h3><p>MySQL中有很多可以控制字符集的选项，这些选项过于复杂很容易混淆。不过记住一点：</p><blockquote><p>只有基于字符的值才真正的“有”字符集的概念。</p></blockquote><p>对于其他类型的值，字符集只是一个设置，用来指定用哪一种字符进行比较或操作。基于字符的值能存放在某列中、查询的字符中、表达式的计算结果中或者某个用户变量中，等等。</p><p>MySQL中字符集的设置可以分为两类：创建对象时的默认值、在服务器和客户端通信时的设置。</p><h4 id="3-1-创建对象时的默认设置"><a href="#3-1-创建对象时的默认设置" class="headerlink" title="3.1 创建对象时的默认设置"></a>3.1 创建对象时的默认设置</h4><p>在MySQL中，从上到下一共有四层字符集的设置，分别是服务器（Server）、数据库（Database）、表（Table）和列（Column），在每一层都可以指定一个默认的字符集：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/charset_layers.PNG"><p>其中，服务器和数据库的字符集设置有对应的参数：<code>character_set_server</code>和<code>character_set_database</code>，表和列的字符集设置在对应的DDL语句中。</p><p>由于真正存放数据的是列，所以更高层次的字符集设置仅仅是指定一个默认值，如果在创建列时没有知道字符集，就会从下到上寻找设置的字符集。如果指定了一个字符集，那么上面所有层次的设置都没有效果了。</p><p>在MySQL 5.5、5.6和5.7中，默认的字符集是latin1，在最新的MySQL 8中，默认的字符集是utf8。</p><h4 id="3-2-服务器和客户端通信时的设置"><a href="#3-2-服务器和客户端通信时的设置" class="headerlink" title="3.2 服务器和客户端通信时的设置"></a>3.2 服务器和客户端通信时的设置</h4><p>当服务器和客户端进行通信时，可能各自使用不同的字符集。这时，服务器需要进行字符的转换工作。这涉及到MySQL中的三个参数：<code>character_set_client</code>、<code>character_set_connection</code>和<code>character_set_results</code>。</p><p>这三个参数的影响效果如下图所示：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/MySQL/charset_communacate.PNG"><p>这里服务器进行了两次翻译过程：</p><ol><li>SQL语句从客户端离开时的字符集是<code>character_set_client</code>；</li><li>SQL语句进入服务器后服务器转换成<code>character_set_connection</code>；</li><li>服务器处理完SQL语句后，将结果的字符集设置成了<code>character_set_results</code>。</li></ol><p>根据需要，可以使用<code>SET NAMES</code>或者<code>SET CHARACTER SET</code>语句来改变上面的设置：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SET NAMES 'utf8';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，会将<code>character_set_client</code>、<code>character_set_connection</code>和<code>character_set_results</code>都设置成utf8。</p><p>不过在服务器上使用这个命令只能改变服务器端的设置，客户端程序也需要设置正确的字符集才能避免出现问题。</p><h4 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h4><p>可以通过<code>SHOW VARIABLES LIKE &#39;character%&#39;</code>命令来查看这些参数的值：</p><pre class="line-numbers language-shell"><code class="language-shell">+--------------------------+-----------------------------------------------------------+| Variable_name            | Value                                                     |+--------------------------+-----------------------------------------------------------+| character_set_client     | latin1                                                    || character_set_connection | latin1                                                    || character_set_database   | utf8mb4                                                   || character_set_filesystem | binary                                                    || character_set_results    | latin1                                                    || character_set_server     | utf8mb4                                                   || character_set_system     | utf8                                                      || character_sets_dir       | /usr/local/mysql-8.0.13-macos10.14-x86_64/share/charsets/ |+--------------------------+-----------------------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-字符集的选择"><a href="#4-字符集的选择" class="headerlink" title="4. 字符集的选择"></a>4. 字符集的选择</h3><p>使用不同的字符集会带来更多的CPU操作，可能也会消耗更多的内存和磁盘空间。因此，为了方便，最好先为服务器（或者数据库）设置一个合理的字符集，然后根据不同的情况让某些列选择合适的字符集，</p><p>如果统一使用utf8字符集，整个世界都清净了。这也是很常见的一种做法。不过有的时候并不需要使用utf8，使用utf8之后会增加磁盘空间的消耗。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> charset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What is physics</title>
      <link href="/what-is-physics/"/>
      <url>/what-is-physics/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是阅读《费恩曼物理学讲义 第一卷 新千年版》第1-3章的阅读笔记。</p></blockquote><h3 id="1-从一片沙滩开始"><a href="#1-从一片沙滩开始" class="headerlink" title="1. 从一片沙滩开始"></a>1. 从一片沙滩开始</h3><p>我们生活在一个多姿多彩的世界中。</p><p>想象一下，去年的某一天，我们正在一个美丽的海边沙滩享受着没有工作烦恼的美妙时光。你躺在柔软细密的沙滩上，不远处就是蔚蓝的大海，海水波光粼粼，海风吹拂，你感受到了凉爽，海水在海风的吹拂下翻起阵阵海浪；海水拍打在海中岩石上，激起浪花与泡沫；海水中生活着许许多多不同的生物，也许海绵宝宝和派大星正在不远处的海底捉水母；太阳挂在天上，持续不断发着光；望着这一切，作为观察者的你在想着什么呢？或许是晚上吃啥以及和她那美好的回忆与幸福。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/beach.jpg" alt=""></p><p>除了这些，我们生活的世界还有许许多多的错综复杂以及变化无穷。那么，这些事物到底是什么呢？是什么使得它们如此不同，但在某些方面又表现得如此相同？面对这一切，作为智慧生物，我们的好奇心驱使我们，提出种种问题，把事物联系起来，而将它们的种种表现理解为或许是由较少量的基本事物和相互作用以无穷多的方式组合后所产生的的结果。毕竟，阿瑟·克拉克说，“心智”是宇宙间最珍贵的东西。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/A%20Space%20Odyssey.jpg" alt="2001：太空漫游"></p><p>比如，沙粒和岩石是两回事儿吗？也许沙粒就是小小的岩石？那月亮是否也是岩石呢？如果我们了解了岩石，是不是就了解了沙粒和月亮呢？</p><p>再比如，风是不是和海洋里的水流类似，就是一种空气的流动？不同的运动有什么共同性质呢？</p><p>等等。我们就是希望试图了解我们所生活环境中的所有问题，将乍看起来不同的事物联系起来，减少不同事物的数目，从而能更好地理解它们。</p><h3 id="2-什么是理解"><a href="#2-什么是理解" class="headerlink" title="2. 什么是理解"></a>2. 什么是理解</h3><p>既然我们希望理解所有的事物，那么首先就应该先问问自己，<strong>什么是理解？</strong>毕竟，有目标才能更好达成目标。</p><p>想象一下，整个世界的运作方式是无所不能的神们所下的一盘巨大的琪。下棋有下棋的规则，我们就是这盘棋的观众。作为普通的观众我们不知道神们下棋的规则，只能看神们是如何下棋的，并以此来猜测棋的规则。就像小时候在旁边看父亲下棋一样。</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/chess.jpg" alt="" width="50%" height="50%"><p>如果我们看得够多了，我们就能猜出一些规则来。但即使我们能够猜出一些规则，我们也不能很好地理解某一步棋为什么要那么走，这仅仅是因为情况太复杂了，而我们的智力又是有限的。</p><p>如果你会下象棋，就会知道，知道象棋的规则与如何下好是很不同的。</p><p>自然界也是如此，但是自然更加复杂。</p><p>我们要做的，就是尽可能知道更多的规则，知道了这些规则，就可以说“理解”了世界。</p><h3 id="3-如何理解"><a href="#3-如何理解" class="headerlink" title="3. 如何理解"></a>3. 如何理解</h3><p>几百年前，人们就已经想出了一些方法，那就是：观察、推理和实验，这就是通常所说的科学方法。更详细一点，就是下面这样：</p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/science.JPG" alt="" width="50%" height="50%"><p>虽然通过上面的方法我们可以得到一些规则，但是，这些规则都是对大自然整个真理的近似，因为我们不知道所有的规则，所以只能一步一步去近似，这样我们才能更好地理解。</p><p>对于理解的检验，有一条科学的原则：实验是一切知识的试金石。</p><h3 id="4-怎么知道我们理解的对呢？"><a href="#4-怎么知道我们理解的对呢？" class="headerlink" title="4. 怎么知道我们理解的对呢？"></a>4. 怎么知道我们理解的对呢？</h3><p>之前我们说过，我们不能全面地理解神们下的棋。既然这样，我们怎么知道我们已经知道的规则就是正确的呢？</p><p>一共有三种办法。第一个，我们首先将大自然安排得非常简单，只有几个部分组成。因为简单，我们可以正确地预测会发生什么事。</p><p>比如，对于象棋，我们知道棋盘上有格子和线条的交叉点。通过几次（甚至一次）观察我们就知道，棋子是放在线条交叉点上的而不是格子里（国际象棋是放在格子里）。</p><p>第二个，利用由已知规则推导出来的较一般性法则来检验已知规则本身。</p><p>比如，我们可能发现，“卒”和“兵”只能前进，不能后退，因此我们可以推断，“卒”和“兵”只能在最开始所在的那条直线上。但是随着更多的观察我们发现，有的“卒”和“兵”在越过中间的楚河汉界之后，还能左右移动，但不管怎样，它们还是不能后退而只能前进。这样，我们通过新发生的现象，更好地理解了之前已知的规则。</p><p>第三个比较粗糙，就是用粗略的近似方法来加以辨别。我们可能不知道公园老大爷那么走的原因，但我们可以猜测，那肯定是为了化解对方的一次将军。同样，根据我们对自然的理解，即使我们不能看出所有事物的规则，我们也能更多地理解我们的自然。</p><h3 id="5-什么是物理"><a href="#5-什么是物理" class="headerlink" title="5. 什么是物理"></a>5. 什么是物理</h3><p>说了这么多，终于到了主题：<strong>什么是物理。</strong></p><p>“物理”一词在英文里是“physics”，最先出自于古希腊文“φύσις”，原意是“自然”。在中文里，这词最早可在战国时期佚书《鹖冠子·王𫓧篇》找到，“愿闻其人情物理所以啬万物与天地总与神明体正之道。”在这里，“物理”指的是一切事物之道理。</p><p>上面说了好多自然啊、事物啊、理解啊、规则啊什么的，其实物理就是研究万物运行的道理。</p><h3 id="6-物理学与其他科学的关系"><a href="#6-物理学与其他科学的关系" class="headerlink" title="6. 物理学与其他科学的关系"></a>6. 物理学与其他科学的关系</h3><p>假如人类遭遇了末日，所有的科学知识都丢了，只能把一句话留给后人，那么怎么用最少的字传递最多的知识呢？</p><blockquote><p>所有的物体都是由原子构成的——这些原子是一些小小的粒子，它们一直不停地运动着，当彼此略微离开时相互吸引，当彼此过于挤紧时又相互排斥。</p></blockquote><p>这一句话，包含了关于这个世界的大量信息。</p><p>这也是物理和其他科学的关系的基石。因为所有的物体都是由原子构成的，其他的科学研究的也是各种物体，不管是化学研究的有机物和无机物，生物研究的各种生命体，天文学研究各种天体，以及地质学研究的各种地质问题，归根结底研究的都是“物体”，而所有的物体都是由原子构成的。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/relations.png" alt=""></p><p>这并不是没有了物理学我们就不能开展其他科学研究了。仅仅是研究的不同角度而已。物理不能回答为什么青蛙会跳，但是物理知道青蛙是什么，就是一堆堆不同的分子组成的一个物体，仅此而已。</p><h3 id="7-那么，开始吧"><a href="#7-那么，开始吧" class="headerlink" title="7. 那么，开始吧"></a>7. 那么，开始吧</h3><p>最后，跟着费恩曼的脚步，逐渐理解我们的世界，慢慢品味物理的美酒。</p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/blogs/Physics/feynman.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> physics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> physics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go struct to json</title>
      <link href="/go-struct-to-json/"/>
      <url>/go-struct-to-json/</url>
      
        <content type="html"><![CDATA[<p>最近做了一些将go中结构体输出到json的事情，各种花样输出，在这里整理一下。</p><h3 id="问题1：如何将struct转成json？"><a href="#问题1：如何将struct转成json？" class="headerlink" title="问题1：如何将struct转成json？"></a>问题1：如何将struct转成json？</h3><p>这是最简单的一种情况，直接使用<code>encoding/json</code>包中的函数就可以了：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"encoding/json"</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">type</span> Item <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Label <span class="token builtin">string</span>    Value <span class="token builtin">int32</span>    URL   <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    item <span class="token operator">:=</span> Item<span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token string">"http://test.com"</span><span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"Label"</span><span class="token operator">:</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token property">"Value"</span><span class="token operator">:</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token property">"URL"</span><span class="token operator">:</span><span class="token string">"http://test.com"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题2：我想自定义输出json的key怎么弄？"><a href="#问题2：我想自定义输出json的key怎么弄？" class="headerlink" title="问题2：我想自定义输出json的key怎么弄？"></a>问题2：我想自定义输出json的key怎么弄？</h3><p>使用struct的tag即可：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Item <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Label <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>    Value <span class="token builtin">int32</span>  <span class="token string">`json:"value"`</span>    URL   <span class="token builtin">string</span> <span class="token string">`json:"url"`</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token property">"value"</span><span class="token operator">:</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token property">"url"</span><span class="token operator">:</span><span class="token string">"http://test.com"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题3：有的字段不是必须的，如果为空就不输出呢？"><a href="#问题3：有的字段不是必须的，如果为空就不输出呢？" class="headerlink" title="问题3：有的字段不是必须的，如果为空就不输出呢？"></a>问题3：有的字段不是必须的，如果为空就不输出呢？</h3><p>比如URL字段可能为空，如果为空的话就不希望输出了。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    item <span class="token operator">:=</span> Item<span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"label"</span><span class="token operator">:</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token property">"value"</span><span class="token operator">:</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token property">"url"</span><span class="token operator">:</span><span class="token string">""</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用<code>omitempty</code>标签来达到这个目的：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Item <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Label <span class="token builtin">string</span> <span class="token string">`json:"label"`</span>    Value <span class="token builtin">int32</span>  <span class="token string">`json:"value"`</span>    URL   <span class="token builtin">string</span> <span class="token string">`json:"url,omitempty"`</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"label"</span><span class="token operator">:</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token property">"value"</span><span class="token operator">:</span><span class="token number">127</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题4：我想忽略某一个具体的字段"><a href="#问题4：我想忽略某一个具体的字段" class="headerlink" title="问题4：我想忽略某一个具体的字段"></a>问题4：我想忽略某一个具体的字段</h3><p>方法一：可以直接使用这个标签：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name     <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>    Email    <span class="token builtin">string</span> <span class="token string">`json:"email"`</span>    Password <span class="token builtin">string</span> <span class="token string">`json:"-"`</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：如果struct是别人定义的不允许我们修改这个标签，除了我们自定义一个struct外，还可以使用匿名struct：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    user <span class="token operator">:=</span> User<span class="token punctuation">{</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span> <span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>User        Password <span class="token builtin">bool</span> <span class="token string">`json:"password,omitempty"`</span>    <span class="token punctuation">}</span><span class="token punctuation">{</span>        User<span class="token punctuation">:</span> <span class="token operator">&amp;</span>user<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span><span class="token property">"email"</span><span class="token operator">:</span><span class="token string">"1749118121@qq.com"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里使用了嵌套结构体的概念，外面的<code>Password</code>字段覆盖了里面<code>User</code>的<code>Password</code>字段，然后通过问题3里的技巧，达到忽略某个字段的目的。</p><h3 id="问题5：临时添加一个或多个字段"><a href="#问题5：临时添加一个或多个字段" class="headerlink" title="问题5：临时添加一个或多个字段"></a>问题5：临时添加一个或多个字段</h3><p>这个就比较简单了，自定义一个struct即可：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name     <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>    Email    <span class="token builtin">string</span> <span class="token string">`json:"email"`</span>    Password <span class="token builtin">string</span> <span class="token string">`json:"password"`</span><span class="token punctuation">}</span><span class="token keyword">type</span> PublicUser <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token operator">*</span>User    Password <span class="token builtin">bool</span>   <span class="token string">`json:"password,omitempty"`</span>    Token    <span class="token builtin">string</span> <span class="token string">`json:"token"`</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    user <span class="token operator">:=</span> User<span class="token punctuation">{</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span> <span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">}</span>    publicUser <span class="token operator">:=</span> PublicUser<span class="token punctuation">{</span>        User<span class="token punctuation">:</span>  <span class="token operator">&amp;</span>user<span class="token punctuation">,</span>        Token<span class="token punctuation">:</span> <span class="token string">"test_token"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>publicUser<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span><span class="token property">"email"</span><span class="token operator">:</span><span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span><span class="token property">"token"</span><span class="token operator">:</span><span class="token string">"test_token"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题6：将多个struct组合成一个json"><a href="#问题6：将多个struct组合成一个json" class="headerlink" title="问题6：将多个struct组合成一个json"></a>问题6：将多个struct组合成一个json</h3><p>可能一个服务的数据来自不同的接口，需要组合到一个json里，那么同样自定义一个struct就可以了：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name     <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>    Email    <span class="token builtin">string</span> <span class="token string">`json:"email"`</span>    Password <span class="token builtin">string</span> <span class="token string">`json:"password"`</span><span class="token punctuation">}</span><span class="token keyword">type</span> Analytics <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Blogs <span class="token builtin">int32</span> <span class="token string">`json:"blogs"`</span>    Read  <span class="token builtin">int32</span> <span class="token string">`json:"read"`</span><span class="token punctuation">}</span><span class="token keyword">type</span> PublicUser <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token operator">*</span>User    Password <span class="token builtin">bool</span> <span class="token string">`json:"password,omitempty"`</span>    <span class="token operator">*</span>Analytics<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    user <span class="token operator">:=</span> User<span class="token punctuation">{</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span> <span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">}</span>    analytics <span class="token operator">:=</span> Analytics<span class="token punctuation">{</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">}</span>    publicUser <span class="token operator">:=</span> PublicUser<span class="token punctuation">{</span>        User<span class="token punctuation">:</span>      <span class="token operator">&amp;</span>user<span class="token punctuation">,</span>        Analytics<span class="token punctuation">:</span> <span class="token operator">&amp;</span>analytics<span class="token punctuation">,</span>    <span class="token punctuation">}</span>    bdata<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>publicUser<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bdata<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"valineliu"</span><span class="token punctuation">,</span><span class="token property">"email"</span><span class="token operator">:</span><span class="token string">"1749118121@qq.com"</span><span class="token punctuation">,</span><span class="token property">"blogs"</span><span class="token operator">:</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token property">"read"</span><span class="token operator">:</span><span class="token number">200</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="问题7：我能自定义一个struct如何转换成json吗？"><a href="#问题7：我能自定义一个struct如何转换成json吗？" class="headerlink" title="问题7：我能自定义一个struct如何转换成json吗？"></a>问题7：我能自定义一个struct如何转换成json吗？</h3><p>比如，我们有这样的结构：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Article <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Title   <span class="token builtin">string</span>    <span class="token string">`json:"title"`</span>    PubTime time<span class="token punctuation">.</span>Time <span class="token string">`json:"pubtime"`</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>直接<code>Marshal</code>后会是这样：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"title"</span><span class="token operator">:</span><span class="token string">"my_title"</span><span class="token punctuation">,</span><span class="token property">"pubtime"</span><span class="token operator">:</span><span class="token string">"2019-12-05T20:52:50.759801+08:00"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果我们想<code>pubtime</code>输出的时间是时间戳，可以自定义输出形式：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>a Article<span class="token punctuation">)</span> <span class="token function">MarshalJSON</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">type</span> Alias Article    <span class="token keyword">return</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token punctuation">{</span>        PubTime <span class="token builtin">int64</span> <span class="token string">`json:"pubtime"`</span>        Article    <span class="token punctuation">}</span><span class="token punctuation">{</span>        PubTime<span class="token punctuation">:</span> a<span class="token punctuation">.</span>PubTime<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        Article<span class="token punctuation">:</span>   a<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而这样是不行的，执行后会报一个<code>fatal error: stack overflow</code>的错误。这是因为，在自定义的<code>MarshalJSON</code>函数里直接调用了<code>Article.MarshalJSON</code>函数，这样就无限调用了，直到报错。</p><p>为了避免出现这个错误，可以定义一个别名（Alias）：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>a Article<span class="token punctuation">)</span> <span class="token function">MarshalJSON</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">type</span> Alias Article    <span class="token keyword">return</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token punctuation">{</span>        PubTime <span class="token builtin">int64</span> <span class="token string">`json:"pubtime"`</span>        Alias    <span class="token punctuation">}</span><span class="token punctuation">{</span>        PubTime<span class="token punctuation">:</span> a<span class="token punctuation">.</span>PubTime<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        Alias<span class="token punctuation">:</span>   <span class="token punctuation">(</span>Alias<span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"pubtime"</span><span class="token operator">:</span><span class="token number">1575638467</span><span class="token punctuation">,</span><span class="token property">"title"</span><span class="token operator">:</span><span class="token string">"my_title"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>完美。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>这篇文章的结束不是这个话题的结束。关于go语言中使用json还有很多话题可以讨论，这里仅仅是将go中的struct转换成json输出，此外，还有将json转换成struct，以及自定义<code>Marshal</code>和<code>Unmarshal</code>函数等话题。</p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><p><img src="https://deuterium-figure-1251214161.cos.ap-beijing.myqcloud.com/lufy.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
